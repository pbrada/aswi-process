<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_EHni0NwuEdmRU7lXzo6lKQ" name="designing_enterprise_javabeans_ejbs,2.8082009592332426E-306" guid="_EHni0NwuEdmRU7lXzo6lKQ" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>&lt;/a>Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This guideline focuses on designing EJBs. Additional guidance on EJBs, such as how to identify and model them, is&#xD;
    provided by &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/guidelines/enterprise_javabean_ejb_7F0C3AFF.html&quot;&#xD;
    guid=&quot;1.5078998518719443E-305&quot;>Guideline: Enterprise JavaBean (EJB)&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Specific guidance on designing specific types of EJBs is provided in the following guidelines:&#xD;
&lt;/p>&#xD;
&lt;ul type=&quot;disc&quot;>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLink&quot;&#xD;
        href=&quot;./../../../tech.j2ee/guidances/guidelines/designing_session_beans_BDBA5DEB.html&quot;&#xD;
        guid=&quot;5.207478815358005E-306&quot;>Designing Session Beans&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLink&quot; href=&quot;./../../../tech.j2ee/guidances/guidelines/designing_entity_beans_7CD45D28.html&quot;&#xD;
        guid=&quot;5.953653009453999E-307&quot;>Designing Entity Beans&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLink&quot;&#xD;
        href=&quot;./../../../tech.j2ee/guidances/guidelines/designing_message-driven_beans_DE3F4EC4.html&quot;&#xD;
        guid=&quot;7.497484412493539E-306&quot;>Designing Message-Driven Beans&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Local&quot; name=&quot;Local&quot;>Local vs. Remote Interfaces&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Local and remote interfaces are described in &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html#Enterprise_JavaBeans&quot;&#xD;
     guid=&quot;1.527482214591853E-307&quot;>Concept: Java 2 Platform Enterprise Edition (J2EE) Overview&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Local interfaces are more efficient than remote interfaces. Local interfaces should be provided if there are specific&#xD;
    clients which are always local to the EJB.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    More specific guidance on this topic is provided in the guidelines for the specific types of EJBs.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Parameter&quot; name=&quot;Parameter&quot;>&lt;/a>Parameter Passing&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Performance can be dramatically affected by the number of remote calls and the amount of data transferred on each call.&#xD;
    This can be addressed by providing specific calls that return all the data that the remote client requires. For&#xD;
    example, a session bean, acting as a facade for a set of related entity beans, can copy data from multiple entity beans&#xD;
    into serializable value objects, and return this data in a single remote call. This is described in detail in &lt;i>Core&#xD;
    J2EE Patterns - Value Object Pattern&lt;/i> ([&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/supportingmaterials/java_references_110189E3.html#ALU01&quot;&#xD;
    guid=&quot;1.4494927535802764E-304&quot;>ALU01&lt;/a>].&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This must be balanced by the concerns of keeping interfaces as general as possible, and avoiding sending too much&#xD;
    un-needed data.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Transactions&quot; name=&quot;Transactions&quot;>Transactions&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Demarcating transactions means initiating, committing and aborting transactions. An EJB designer must decide whether to&#xD;
    implement bean-managed transaction demarcation or container-managed transaction demarcation. You must decide on the&#xD;
    locations of the transaction boundaries in the sequences of business logic performed by your application. For more&#xD;
    information, see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/use_case_design_92D13EEE.html#Modeling%20Transactions&quot;&#xD;
    guid=&quot;{76E2B93D-051C-4B8C-BEA1-B40A40CBD986}&quot;>Task: Use-Case Design, Modeling Transactions&lt;/a> and the section titled&#xD;
    &lt;i>Transaction Management&lt;/i> in &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html&quot;&#xD;
    guid=&quot;1.527482214591853E-307&quot;>Concept: Java 2 Platform Enterprise Edition (J2EE) Overview&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Use container-managed transactions where possible. This will keep your code simple and allow developers to focus on the&#xD;
    business logic of the application.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In general, larger granularity transactions will result in better overall performance. Suppose you make a sequence of&#xD;
    method calls to an EJB (for example, getX, getY and setZ). By default, each method will execute in a new transaction,&#xD;
    resulting in reduced performance. To call these within the same transaction, create another method, for example method&#xD;
    processXYZ of a session EJB, and set the transaction attributes of the called methods to &lt;i>Required&lt;/i>, so that they&#xD;
    use the existing transaction (i.e. the transaction of the calling method in the session bean).&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Security&quot; name=&quot;Security&quot;>Security&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Basic EJB security concepts are covered in &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html#Security&quot;&#xD;
     guid=&quot;1.527482214591853E-307&quot;>Concept: Java 2 Platform Enterprise Edition (J2EE) Overview&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You define your EJB?s security requirements by defining &lt;i>security roles&lt;/i> and &lt;i>method permissions&lt;/i>.&amp;nbsp;&#xD;
    Security roles and method permissions are defined in the EJB?s deployment descriptor.&amp;nbsp; It is up to the server&#xD;
    (using administration tools) to map security roles onto users or groups of users.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A security role defines a set of similar types of activities that are grouped under a single name. A method permission&#xD;
    grants a particular security role the right to call the method.&amp;nbsp; For example, consider an entity EJB&#xD;
    &lt;i>Employee&lt;/i>, with methods &lt;i>setAddress&lt;/i>, &lt;i>setSalary&lt;/i> etc. A security role of &lt;i>manager&lt;/i> may be granted&#xD;
    method permission for the methods setAddress and setSalary, while a security role of &lt;i>employee&lt;/i> may only be&#xD;
    granted method permission for the method setAddress.&amp;nbsp;&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In some situations it is impossible to support the security requirements of an application using declarative method&#xD;
    permissions in the deployment descriptor. In this case you use the getCallerPrincipal and isCallerInRole methods of the&#xD;
    javax.ejb.EJBContext interface.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Timer_Service&quot; name=&quot;Timer_Service&quot;>Timer Service&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Since J2EE 1.4 (more exactly EJB 2.1) stateless sessions beans and message-driven beans can use timers to schedule&#xD;
    batch processes through the EJB Timer Service.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The EJB Timer Service that provides methods to allow callbacks to be scheduled for time-based events. The container&#xD;
    provides a reliable and transactional notification service for timed events. Timer notifications may be scheduled to&#xD;
    occur at a specific time, after a specific elapsed duration, or at specific recurring intervals.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Timer Service is implemented by the EJB container and an enterprise bean can access this service through the&#xD;
    EJBContext interface.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The EJB Timer Service is a coarse-grained timer notification service that is designed for use in the modeling of&#xD;
    application-level processes and not intended for modeling real-time events.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Direct_Access_vs._Entity_EJBs&quot; name=&quot;Direct_Access_vs._Entity_EJBs&quot;>&lt;/a>Direct Access vs. Entity beans&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Using entity beans for persistent data provides a standard, feature-rich mechanism for accessing persistent data. The&#xD;
    decision to use bean-managed persistence or container-managed persistence can be hidden from clients, giving the design&#xD;
    some flexibility. EJBs can take advantage of transactions, resource management, load-balancing, and other features&#xD;
    provided by the J2EE environment.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    However, there could be situations where you might want to access the database directly and avoid using entity beans.&#xD;
    For example, if the data is always accessed as read-only by a single client, direct access to the database would be&#xD;
    more efficient.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you're accessing the database directly (for example, from a stateless session bean), encapsulate all database access&#xD;
    within a Data Access Object class. This is just a Java class that hides and encapsulates the underlying storage&#xD;
    mechanism, and isolates changes when, and if, the interface to the data source changes. See &lt;i>Core J2EE Patterns -&#xD;
    Data Access Object Pattern&lt;/i> ([&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/supportingmaterials/java_references_110189E3.html#ALU01&quot;&#xD;
    guid=&quot;1.4494927535802764E-304&quot;>ALU01&lt;/a>].&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Database_Connections&quot; name=&quot;Database_Connections&quot;>Database Connections&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Virtually all EJB containers provide support for connection pooling-sharing a set of already-created connections&#xD;
    between clients. These connections are assigned to EJBs as needed. The EJB profits by obtaining a connection without&#xD;
    the expense of creating and initializing it. When the connection is returned to the pool, it's recycled. The size of&#xD;
    the pool should have enough ready connections available to recycle the used ones.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For entity beans with container-managed persistence, the container manages the database connection and access to the&#xD;
    database connection pool.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For entity beans with bean-managed persistence (or for session or message-driven EJBs that access a database), the&#xD;
    developer is responsible for coding the connection routine. The following guidelines apply:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Isolate your database access code in a DAO class.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Don't hardcode the actual URL of the database-instead, use a logical name that can be retrieved using Java Naming&#xD;
        and Directory Interface (JNDI) lookup. This allows you to reuse the EJB in multiple applications, possibly with&#xD;
        different database names.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        In general, use connection pools, and only hold the connection for as long as it's needed. For example, an entity&#xD;
        bean might connect, update a row in a table, and then disconnect. This will allow many EJBs to share the same&#xD;
        connection. The JDBC specification includes support for connection pooling.&#xD;
    &lt;/li>&#xD;
&lt;/ul></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
