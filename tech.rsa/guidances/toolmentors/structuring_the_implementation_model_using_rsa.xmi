<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_VhOo8Me0EdmYjcUf1_oIew" name="structuring_the_implementation_model_using_rsa,{0BBB35DD-097A-41D2-8CC9-59AD9AA93E53}" guid="_VhOo8Me0EdmYjcUf1_oIew" changeDate="2006-04-28T10:52:36.426-0700" version="7.1.0">
  <mainDescription>&lt;h3>&#xD;
    Overview&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This tool mentor assumes that you have defined the top level structure of your Implementation Model as described in the&#xD;
    &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.rsa/guidances/whitepapers/model_structure_guidelines_for_rational_software_developer_DF8E00EB.html&quot;&#xD;
     guid=&quot;1.128046228219609E-305&quot;>Model Structure Guidelines for RSx&lt;/a>.&amp;nbsp;The steps in this tool mentor permit this&#xD;
    initial structure to be refined.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The following steps are performed in this tool mentor:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Establish%20the%20Implementation%20Model%20Structure&quot;>Establish the Implementation Model Structure&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Adjust%20Subsystems&quot;>Adjust Implementation Subsystems&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Define%20Imports%20for%20Each%20Subsystem&quot;>Define Imports for Each Implementation Subsystem&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Decide%20how%20to%20treat%20executables%20(and%20other%20derived%20objects)&quot;>Decide How to Treat&#xD;
        Executables (and Other Derived Objects)&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Decide%20how%20to%20treat%20test%20assets&quot;>Decide How to Treat Test Assets&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Update%20the%20Implementation%20View&quot;>Update the Implementation View&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Evaluate%20the%20implementation%20model&quot;>Evaluate the Implementation Model&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Establish the Implementation Model Structure&quot; name=&quot;Establish the Implementation Model Structure&quot;>Establish the&#xD;
    Implementation Model Structure&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The recommended approach is MDD - Model Driven Development (see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.rsa/guidances/concepts/mdd_and_mda_8F9B3685.html&quot; guid=&quot;4.227832989444728E-303&quot;>Model&#xD;
    Driven Development and Model Driven Architecture&lt;/a>). If this approach is followed by the development team, the&#xD;
    Implementation Model is strongly driven by the organization of the Design Model. As Implementation Subsystems are&#xD;
    identified, they should be modeled as packages or subsystems in the Design Model. Generally speaking, when you identify&#xD;
    the packages in the Design Model, you should be considering how those will map to tool specific&amp;nbsp;projects. Larger&#xD;
    subsystems typically map to their own projects, finer-grained packages typically map to source folders within projects.&#xD;
    Refer to the sections of the &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.rsa/guidances/whitepapers/model_structure_guidelines_for_rational_software_developer_DF8E00EB.html&quot;&#xD;
     guid=&quot;1.128046228219609E-305&quot;>Model Structure Guidelines for RSx&lt;/a> that discuss Project Structures and the internal&#xD;
    organization of the Implementation and Design Models.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/guidances/concepts/implementation_view_E373E3B6.html&quot;&#xD;
    guid=&quot;4.693519701160983E-305&quot;>Implementation View&lt;/a> could be defined by using &amp;lt;&amp;lt;perspective&amp;gt;&amp;gt; packages,&#xD;
    containing diagrams which show dependencies between the subsystems. Depending upon what kind of transformation is&#xD;
    applied to the Design Model, the dependencies you define among the packages/subsystems might map to 3GL import&#xD;
    declarations and project dependency declarations in the project metadata.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Once code has been generated, more detailed UML diagrams could be produced, showing the implementation-level constructs&#xD;
    and their relationships, by creating Class Diagrams directly in the projects and populating them by dragging&#xD;
    implementation artifacts onto them. Refer to online Help topics related to the UML Visual Editor for Java.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you require references to specific classes, interfaces, packages, etc. from a code library to be represented in you&#xD;
    implementation model you can use the code visualization capabilities of the product to create those representations.&#xD;
    The following jar files contain files that may be of interest to you as you design and develop J2EE applications:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        j2ee.jar, jsf-api.jar, soap.jar, soap-sec.jar (all under the lib directory)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        core.jar, xml.jar, security.jar (all under java\jre\lib directory)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    When you need to reference an element from one of these libraries in your model, perform the following steps:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Create a new Java project and add references to libraries&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Open the diagram that you wish to add the visualized element&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Switch to the Java Perspective&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Find the element (package, class, interface, etc.) that you wish to add your model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the element and select Visualize &amp;gt; Add to Current Diagram&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    If there is a need to represent the actual projects and packages in which you expect the code and related files to&#xD;
    reside, prior to any code generation, an Implementation Overview Model might be useful. For more information, see the&#xD;
    Implementation Model related topics in the &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.rsa/guidances/whitepapers/model_structure_guidelines_for_rational_software_developer_DF8E00EB.html&quot;&#xD;
     guid=&quot;1.128046228219609E-305&quot;>Model Structure Guidelines for RSx&lt;/a> white paper.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Adjust Subsystems&quot; name=&quot;Adjust Subsystems&quot;>Adjust Implementation Subsystems&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The following is a sequence of steps that will help you adjusting the implementation subsystems:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Identify subsystems causing issues,&amp;nbsp;for example cyclic dependency, using:&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Topic and browse diagrams&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Architectural Discovery&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Code Review / Structural Code&amp;nbsp;Analysis&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Create a new subsystem&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Move the identified elements to the new subsystem&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Draw new dependencies&amp;nbsp;&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Define Imports for Each Subsystem&quot; name=&quot;Define Imports for Each Subsystem&quot;>Define Imports for Each&#xD;
    Implementation Subsystem&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In an MDD environment, the dependencies in the Implementation Model will mirror very closely the ones defined&#xD;
    explicitly or implicitly in the Design Model. The specifics are determined by the code generation transformations&#xD;
    applied to the Design Model.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In addition to the input model, there are other artifacts that are necessary to perform a transformation. A&#xD;
    transformation process requires a transformation definition and its transformation rules.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A transformation rule provides a description that the transformation process uses to convert one element in the source&#xD;
    model to zero or more elements in the target model. Specifically, it maps elements from one level of abstraction to its&#xD;
    more detailed counterparts at a lower level of abstraction.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you are using manual transformation â€“ you will need to ensure that you are providing sufficient guidance to your&#xD;
    developers as they transform the design model to code. In essence, you need to provide a transformation definition,&#xD;
    which includes a set of transformation rules. This additional guidance can be in the form of:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Elements from documented profiles&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Notes in the model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Additional information in the Software Architecture Document&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Development Guidelines&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    If an Implementation Overview Model is used, this will be the place to show the anticipated dependencies among the&#xD;
    projects and packages, which can prove helpful in identifying system build requirements (see &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.rsa/guidances/whitepapers/model_structure_guidelines_for_rational_software_developer_DF8E00EB.html&quot;&#xD;
     guid=&quot;1.128046228219609E-305&quot;>Model Structure Guidelines for RSx&lt;/a>).&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Decide how to treat executables (and other derived objects)&quot;&#xD;
    name=&quot;Decide how to treat executables (and other derived objects)&quot;>Decide How to Treat Executables (and Other Derived&#xD;
    Objects)&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In an MDD environment, depending upon what kind of transformation is applied to the Design Model, various types of&#xD;
    deployable artifacts might be generated. For example, from elements such as &amp;lt;&amp;lt;control&amp;gt;&amp;gt; and&#xD;
    &amp;lt;&amp;lt;entity&amp;gt;&amp;gt; classes, session and entity EJB might be generated for a J2EE target, including: the code for&#xD;
    the implementation classes plus the interfaces plus deployment descriptor content that allocates the EJBs to EJB JARs&#xD;
    and maps those JARs to EARs.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You can choose to model deployable artifacts at the conceptual level, using a deployment model. If you choose to do so,&#xD;
    you will model them using UML nodes and artifacts. At the current time, the&amp;nbsp;transformations packaged with the&#xD;
    tool&amp;nbsp;do not leverage the semantics of such diagrams to generate deployment data, so your diagrams will be purely&#xD;
    conceptual and useful only as documentation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Optionally, you could also depict actual implementation artifacts in such diagrams by dropping them onto the canvas and&#xD;
    connecting them (using dependencies) to the conceptual elements of the diagram.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Decide how to treat test assets&quot; name=&quot;Decide how to treat test assets&quot;>Decide How to Treat Test Assets&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A key consideration that will impact the structure of your test assets will be the decision as to how you create your&#xD;
    test assets.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You can choose to use the Automated Component test capabilities to create your tests. If that is the case, then one or&#xD;
    more separate test case projects&amp;nbsp;are set up for you as part of the creation process. One key benefit of using this&#xD;
    feature is that you can utilize an initial code generation and use the stubs of the code to drive the test case&#xD;
    creation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Keep the project repository organized as a set or hierarchy of directories. It is recommended that the test assets be&#xD;
    kept in separate test directories segregating the different types of test; unit test, integration test, system test.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Update the Implementation View&quot; name=&quot;Update the Implementation View&quot;>Update the Implementation View&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    If there is a separate Implementation View, it must be maintained. The general recommendation presented in the &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.rsa/guidances/whitepapers/model_structure_guidelines_for_rational_software_developer_DF8E00EB.html&quot;&#xD;
     guid=&quot;1.128046228219609E-305&quot;>Model Structure Guidelines for RSx&lt;/a> white paper is to use the&#xD;
    &amp;lt;&amp;lt;perspective&amp;gt;&amp;gt; packages, containing diagrams which show dependencies between the subsystems.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Evaluate the implementation model&quot; name=&quot;Evaluate the implementation model&quot;>Evaluate the Implementation&#xD;
    Model&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    You want to make sure that your subsystem dependencies (and other dependencies) continue to follow best practices as&#xD;
    the system evolves. To this end, use Architectural Discovery, Code Review in general and Structural Analysis in&#xD;
    particular to verify that the models are following best practices.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As mentioned earlier, you may also want to take time to introduce custom rules that can be used to enforce the&#xD;
    dependencies that you have identified. During the manual portion of the review, you will want to make note of any rules&#xD;
    that have not yet been developed and add them into the set of rules for the next iteration.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It can be helpful to publish models to html format. Also note that diagrams can be copied to Microsoft Word and other&#xD;
    programs.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For more information, refer to &lt;img height=&quot;16&quot; alt=&quot;help book icon&quot; src=&quot;../../../core.base_rup/resources/helpbook.gif&quot;&#xD;
    width=&quot;16&quot; />&lt;i>Publishing Models&lt;/i> and to the &lt;img height=&quot;16&quot; alt=&quot;help book icon&quot;&#xD;
    src=&quot;../../../core.base_rup/resources/helpbook.gif&quot; width=&quot;16&quot; />&lt;i>Publishing a Model to Web&lt;/i> tutorial.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
