<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_q0mY4PS3EdmIX5Pw7v8pRw" name="service_data_encapsulation,1.6727924656888407E-305" guid="_q0mY4PS3EdmIX5Pw7v8pRw" changeDate="2006-10-31T23:29:09.064-0800" version="1.0.0">
  <mainDescription>&lt;a id=&quot;XE_service_data_encapsulation__guidelines_for&quot; name=&quot;XE_service_data_encapsulation__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    It has been common practice in both object-oriented and component-based development to have a set of components&#xD;
    representing persistent entities residing in a shared database. In fact, it was often a vision of many IT organizations&#xD;
    to have a single database schema containing all the persistent elements used in the enterprise. While this has had&#xD;
    limited success for some organizations, for many of them, the common enterprise schema has not been developed. There&#xD;
    are many reasons why such an approach fails, many of them non-technical, but relating to multiple applications;&#xD;
    accessing, locking, and changing the same shared data are very difficult issues to resolve across organizational&#xD;
    boundaries.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In this guideline, we will address two concerns that are very much related: the notion that a service should be a&#xD;
    complete encapsulation of the data it requires and that the only sharing of information between services be conducted&#xD;
    via message exchange.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This guideline provides additional detail to the topic of data-driven service identification.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Data_Fiefdoms&quot; name=&quot;Data_Fiefdoms&quot;>Services as Fiefdoms&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    One of the terms most often used when describing the notion of object-oriented development is the notion of&#xD;
    encapsulation, that an object should encapsulate its state (private data) and its implementation logic. In a services&#xD;
    world, we cleanly separate the notion of a&amp;nbsp;&lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../soa.rup_soma/workproducts/soa_svce_model_service_1EE4C96C.html&quot;&#xD;
    guid=&quot;{FF65B0A2-6C53-4F01-9727-AACDB0D542C8}&quot;>Artifact: Service&lt;/a> (implementation) from its &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../../soa.rup_soma/workproducts/soa_svce_model_svce_spec_37E89A91.html&quot;&#xD;
    guid=&quot;{20F06B5E-95D5-422C-AB68-7C213D28533A}&quot;>Artifact: Service Specification&lt;/a>. This section will address the need&#xD;
    for encapsulation of state. This concept has been documented, initially in [HELLAND] and more recently in [SESSIONS]&#xD;
    and was focused on the development of autonomous, therefore more easily evolvable systems.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;217&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_encapsulation-01.gif&quot;&#xD;
    width=&quot;98&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The commonly used analogy [HELLAND] is that in applying for new insurance you tend to use an agent. The agent is&#xD;
    responsible for helping you fill out the forms for application and usually does this with access to data for types of&#xD;
    policies kinds and rates. The insurance agent is acting as the emissary on behalf of the insurance company's fiefdom.&#xD;
    In fact the insurance company may only accept policy applications from an approved agent. The fiefdom is responsible&#xD;
    for distributing up-to-date policy, rate, and form information to agents as well as processing applications. However,&#xD;
    even though the fiefdom has provided the policy information to the agent and the agent has been certified by the&#xD;
    fiefdom, the first thing the insurance company does with the application is validate it completely - the fiefdom still&#xD;
    does not trust the emissary.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The following sections outline the role of the two primary elements in more detail. While this is not presented as a&#xD;
    concrete pattern or as a prescriptive approach, the principles embodied are important in considering service-oriented&#xD;
    solutions.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Role of the Fiefdom&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The fiefdom is an autonomous service; it only allows communication via messages that are generally assumed to be&#xD;
    created by emissaries who act on behalf of the consumer. The fiefdom is secure, autonomous, and completely defines a&#xD;
    data boundary. No data sources or other persistent data is shared between fiefdoms or between fiefdoms and other&#xD;
    software elements. Now, it is possible that a single database server may underpin more than one service for&#xD;
    persistence, but different table spaces or database containers for each fiefdom ensure data integrity, security, and so&#xD;
    on.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another key aspect of the pattern is that to ensure that the emissary can act as a reasonable agent, that it can&#xD;
    interact with the consumer with the minimum of required communication with the fiefdom, and that the fiefdom will&#xD;
    distribute copies of certain reference data to the emissaries for them to store and use locally. So in the insurance&#xD;
    example above, the catalog of available policies, their requirements, restrictions and prices is distributed&#xD;
    periodically to agents. Of course, it is important that the agent be able to use this information, but also that they&#xD;
    understand that this information is a copy of the data and not necessarily the data the fiefdom is using, and that the&#xD;
    information may be out of date. It may be updated once per month and if the update is received, the emissary may not be&#xD;
    able to process new applications or it may process them based on the older data.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As mentioned above, the fact that an emissary acts on behalf of a fiefdom does not imply any form of trust relationship&#xD;
    between the two parties. To ensure that the emissary has not been usurped, all messages will be validated for syntax,&#xD;
    semantics and policy before being accepted.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The detailed responsibilities of the fiefdom are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Managing and distributing reference data to all emissaries, clearly identifying the effective dates of the data.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Managing the state of transactional data; all transactions are managed entirely on the inside.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Validate all communication with emissaries.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Role of the Emissary&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The emissary acts as an agent and may be located as a per-consumer component, an Internet-based component, or a&#xD;
    specifically deployed component, but critically it has the characteristics that it manages the reference data required&#xD;
    to fill out messages sent the fiefdom processes. It is also responsible for managing local copies of per-transaction&#xD;
    messages. So, for example, customers may identify themselves as having an existing policy, this can be looked up by the&#xD;
    emissary first to pre-populate the form with some information, and this copy of the existing policy can be cached by&#xD;
    the emissary for the duration of the application completion transaction.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In general, an emissary is used when the communication between fiefdom and consumer represents some more complex&#xD;
    transaction that the emissary is now able to manage more efficiently, such as filling out complex requests, as in the&#xD;
    current example. This pattern can be seen in many organizations today where the order-fulfillment system that processes&#xD;
    orders and schedules them for delivery is often the same system that has been in place for many years. As these&#xD;
    organizations have started selling products interactively over the Web, the web application acts as an emissary that&#xD;
    has a local copy of the product catalog and helps the customer prepare an order. Of course it is not the web&#xD;
    application that processes the order; it submits the orders to the existing system. Because the emissary completes this&#xD;
    order based on reference data, it is reasonable to expect that the order will not be rejected because it is not&#xD;
    correct. On the other hand, as we said above, the existing order system is going to validate the order before accepting&#xD;
    it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The detailed responsibilities of the emissary are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Act as an agent, on behalf of the consumer, to complete messages and interact with the fiefdom.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Manage, where appropriate, a logical transaction querying reference data, populating messages, and submitting&#xD;
        information on behalf of the consumer.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Manage a local copy of the reference data, updating as advised by the fiefdom.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Manage caching policies on time-sensitive data as identified by the fiefdom.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Data_Boundaries&quot; name=&quot;Data_Boundaries&quot;>Service Data Boundaries&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In general, many applications are developed as vertically integrated sets of components (see the concept &lt;i>&lt;a&#xD;
    class=&quot;elementLink&quot; href=&quot;./../../../soa.rup_soma/guidances/concepts/service-oriented_architecture_8328ABAD.html&quot;&#xD;
    guid=&quot;8.613638237693525E-307&quot;>Service-Oriented Architecture&lt;/a>&lt;/i> for more information). This tends to lead to&#xD;
    applications that have few natural integration points. The most common approach for integration, mainly because it&#xD;
    sounds so easy, is to have two or more applications share a common data store. So, where Inventory and Ordering share&#xD;
    the notion of a &quot;Product,&quot; they are accessing the same tables in the database. This leads to a number of potential&#xD;
    concurrency and performance issues and interrelations that now couple these applications that affect their individual&#xD;
    evolution and the ability of the business to rehost, redevelop, or simply change one of the applications.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;194&quot; alt=&quot;Diagram is described in the textual content.&quot;&#xD;
    src=&quot;../concepts/resources/co_soa_portfolio-02.gif&quot; width=&quot;206&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For development of service-oriented solutions, we recommend that a service manage a specific, bounded, and coherent&#xD;
    data model. So, analysis of the usage of the two applications shown above should identify the usage of the data by them&#xD;
    and how it can be separated to be managed by two autonomous services. This is not to say that there are no&#xD;
    interconnections between the data models as they are separated. For example, both the Inventory and Ordering services&#xD;
    will need a common definition of products and also locations where inventory is stored and where orders are sourced.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Approaches to dealing with this are to either create a third service for the shared concept (here, a product catalog&#xD;
    service would be relevant) or to manage the concept in just one of the new services. For example, location would&#xD;
    logically be managed by Inventory. Now, messages sent to and from one of these services will need to contain the&#xD;
    identifier for the shared elements so they can be queried or retrieved if needed. For example, in the case of the&#xD;
    inventory, a query for the products currently managed by a location would return a list of product identifiers (and one&#xD;
    assumes quantities on hand); if the details of the products are required, this would be retrieved from the product&#xD;
    catalog service.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Obviously a key work product in the analysis of the data boundaries is the &lt;i>&lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_data_model_65B46980.html&quot; guid=&quot;{9DCF1723-1A21-4F48-BEDE-DBC543489682}&quot;>Data&#xD;
    Model&lt;/a>&lt;/i>. Data models will need to be created for the existing database and carefully separated out at the&#xD;
    physical data model or preferably at the logical data model.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Data_Views&quot; name=&quot;Data_Views&quot;>Service Messages as Data Views&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    If all data is stored only within the service and access is denied to all outside the service, all communication has to&#xD;
    be through messages identified in the Service Specification. However, it is always important to note that these&#xD;
    messages, because they are representing a query and return of data from the database to the consumer, are specifically&#xD;
    copies of data held by the service. As such, they may actually represent a stale state of the service. For example, by&#xD;
    querying for the quantity on-hand of product &quot;234,&quot; a message is returned identifying that location &quot;562&quot; has a&#xD;
    quantity of &quot;12.&quot; The operation will fail, though, if another consumer takes eight items from the stock and the&#xD;
    original consumer tries to acquire 12 items.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This is, in effect, issues of design and traditional transaction management; managing the scope and boundaries of&#xD;
    transactions made a little more complex or at least more visible due to the loosely coupled nature of services and&#xD;
    service consumers. Therefore, messages not only&amp;nbsp;have to be considered as views of the data, but also as copies of&#xD;
    data. Some guidance has been written in a number of places including &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../soa.rup_soma/guidances/whitepapers/soa_cbd_paper_5703509E.html&quot; guid=&quot;2.48704851646278E-307&quot;>SOA&lt;/a>&#xD;
    to relate how messages can specifically identify their lifetime and applicability.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another effect of this transformation to the messaging-based approach inherent to service-oriented solutions is that we&#xD;
    can now refocus the idea of a common data model for applications into a common message model for integration. What this&#xD;
    means is that, wherever possible, messages defined for service specifications are based on common structures, possibly&#xD;
    separated into cohesive schema that can be reused across services. This is a far more flexible approach to integration&#xD;
    in that it also matches the loose coupling approach of services themselves. Also, most of the technologies used in&#xD;
    service implementation include either technologies, tools, or runtimes that provide message-transformation capabilities&#xD;
    where message schema do not exactly match.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For more information, specifically on message leasing and caching, see the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../soa.rup_soma/tasks/soa_service_message_design_D1BA096D.html&quot; guid=&quot;_ObqZoCwUEduKcvYAyaKSaA&quot;>Task:&#xD;
    Message Design&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;References&quot; name=&quot;References&quot;>References&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    [HELLAND] &lt;i>Fiefdoms and Emissaries&lt;/i>, Pat Helland, Microsoft.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    [SESSIONS] &lt;i>Software Fortresses: Modeling Enterprise Architectures&lt;/i>, Roger Sessions, Addison Wesley, 2003.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
