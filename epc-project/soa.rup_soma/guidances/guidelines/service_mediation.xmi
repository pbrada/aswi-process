<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_q4IOAPS3EdmIX5Pw7v8pRw" name="service_mediation,2.5614739075754752E-306" guid="_q4IOAPS3EdmIX5Pw7v8pRw" changeDate="2005-08-07T17:29:09.342-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;XE_service_mediation__guidelines_for&quot; name=&quot;XE_service_mediation__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Mediation is the act of intervention between conflicting parties to promote reconciliation or compromise. In&#xD;
    particular, three common forms of reconciliation are required in distributed systems in general and service-oriented&#xD;
    solutions in particular.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Interface mediation&lt;/b>; in object- or component-based systems interface, mediation is the change between&#xD;
        operation definitions between sender and receiver. In a service-oriented solution, this is seen as a mismatch in&#xD;
        message content/schema between sender and receiver.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Protocol mediation&lt;/b>; most common object- or component-based solutions tend to be based around a common&#xD;
        protocol or set of protocols for communication. In service-oriented solutions, a mix of protocols across the entire&#xD;
        solution is common and it is one of the advantages of the architecture. To communicate between services, messages&#xD;
        will have to span different protocols between sender and receiver.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Operation mediation&lt;/b>; this form of mediation may also look familiar to developers. It is related to the&#xD;
        common &lt;i>strategy pattern&lt;/i>. A component is able to select between one of a set of implementations of a&#xD;
        particular service or operation based on runtime parameters or content of the request. This is also known as&#xD;
        content-based routing.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    It is important to note that more and more middleware platforms provide capabilities for advanced mediation without&#xD;
    having to develop explicit mediation components. In this case, as the middleware detects mismatches in data structure&#xD;
    or communications protocols, it can perform the mediation in its runtime. It is also possible for these platforms to&#xD;
    provide mediators that act as switches based on message content and business rules to select the correct implementation&#xD;
    of a given consumer request.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Data_Mediation&quot; name=&quot;Data_Mediation&quot;>Data Mediation in Activities&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In terms of connecting services where the definition of messages do not match or the messages require transformation&#xD;
    between sender and receiver, it is possible to use a capability provided by UML 2.0 Activities to denote the&#xD;
    transformation between the sender and receiver. This capability, the association of a UML 2.0 Behavior to an ObjectFlow&#xD;
    between two Actions, allows for the identification of a reusable transformation behavior that can turn one message into&#xD;
    another (specifically from the UML 2.0 specification &lt;i>Changes or replaces data tokens flowing along edge&lt;/i>).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As noted above, the transformation is a reusable element. As such, it can be identified to transform one message type&#xD;
    to another and then be used wherever needed in mediating messages between a sending and receiving service. Note that,&#xD;
    although the UML does provide a set of actions for navigating, reading, and updating a structure, these are relatively&#xD;
    complex and may prove too hard to use in defining transforms. It is expected that the transform will either link to a&#xD;
    more compact representation (consider the XSL/T language) or a new way of expressing UML actions needs to be provided.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Data mediation can also be treated as a concrete pattern of service iteration. For example, there is an explicit&#xD;
    mediation service responsible for the implementation of one or more data transformations. In this case, the mediator&#xD;
    has to respond to messages sent by the consumer, transform the message, and pass on to the service, as shown below.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;150&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_mediation-04.gif&quot;&#xD;
    width=&quot;326&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Protocol_Mediation&quot; name=&quot;Protocol_Mediation&quot;>Protocol Mediation on Service Gateways&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Mediation of protocol on the other hand is well understood and supported explicitly in the model. As the protocol&#xD;
    information is specified as the binding for a service channel, it is possible to introduce either additional &amp;lt;&amp;lt;&lt;a&#xD;
    class=&quot;elementLink&quot; href=&quot;./../../../soa.rup_soma/workproducts/soa_svce_model_service_1EE4C96C.html&quot;&#xD;
    guid=&quot;{FF65B0A2-6C53-4F01-9727-AACDB0D542C8}&quot;>Service&lt;/a>&amp;gt;&amp;gt; or &amp;lt;&amp;lt;&lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../soa.rup_soma/workproducts/soa_svce_model_svce_gtway_4D9ADED2.html&quot;&#xD;
    guid=&quot;{B0BF4414-0382-4605-9EE9-82F0DEC7292C}&quot;>Service Gateway&lt;/a>&amp;gt;&amp;gt; model elements that alter the protocol&#xD;
    specification. For example, in the following composite structure diagram you see two partitions, one for Web-facing&#xD;
    services and one for internal services, and there is a service channel between the partitions with a binding of&#xD;
    &quot;HTTP-SOAP&quot;, something that is common for Web-facing services.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;125&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_mediation-01.gif&quot;&#xD;
    width=&quot;203&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The issue is that, to support the required level of performance and other non-functional requirements, all&#xD;
    communication within the internal partition takes place over platform-specific protocols. The following diagram shows&#xD;
    how a service is connected to the service gateway &quot;Port : ISvcTwo&quot; using the Java RMI protocol, but how is it then that&#xD;
    the Web partition connects to the same gateway using HTTP-SOAP?&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;132&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_mediation-02.gif&quot;&#xD;
    width=&quot;348&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The answer is that the service gateway itself can mediate the protocol by converting message structures and invocations&#xD;
    from one format to another. This is common functionality usually provided by middleware such as Object Request Brokers&#xD;
    (ORBs) or Message Brokers. In fact, it would be possible to generate from the model above to such middleware if&#xD;
    required, or to reify &quot;Port : ISvcTwo&quot; as a service in its own right which takes calls from the Web partition and&#xD;
    resends them to the enclosed services.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Again, it is possible for the mediation to be modeled explicitly as a service, rather than a service gateway, that&#xD;
    exposes the correct interface with the consumer-side binding and delegates implementation to the provider service with&#xD;
    a different binding.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Invocation_Mediation&quot; name=&quot;Invocation_Mediation&quot;>Invocation Mediation using Service Composition&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    As we described in the introduction, it is common to define a structure where one service is dependent on another&#xD;
    service for some operation.However, the actual service which will be called for any particular request is dependent on&#xD;
    details embedded in the request, who the requester is, and business rules applied using this information. The commonly&#xD;
    given example for this is a customer request, the receiving service may choose one of two implementations based on the&#xD;
    level of the customer. For example, customers who are known to spend more money might get preferential treatment.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;109&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_mediation-03.gif&quot;&#xD;
    width=&quot;157&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As we described earlier, it is important in this kind of mediation to try to externalize the rules used to choose&#xD;
    between one or more providers of the actual operation implementation. In the diagram above, we show this as a rule&#xD;
    component attached to the mediating service. Obviously it is possible to build the solution as a set of services where&#xD;
    the mediator, rules, and all implementers are separate services. This can be seen below.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;245&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_mediation-05.gif&quot;&#xD;
    width=&quot;285&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As you can see, the mediation component owns not only its realized service specification, but also a service&#xD;
    specification required to be implemented by all the services it mediates. This allows us to define both the composite&#xD;
    structure of the service (shown above) and the dynamic behavior shown below. Note that in the structure above, the part&#xD;
    representing the mediated services is denoted by the required interface and shown with an unbounded multiplicity.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;189&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_mediation-06.gif&quot;&#xD;
    width=&quot;405&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Again, it is possible that this kind of content-based or rule-based routing of messages can be accomplished by the&#xD;
    middleware platform chosen as part of the solution architecture.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
