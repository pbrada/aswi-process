<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_C9y0ANwuEdmRU7lXzo6lKQ" name="identifying_entity_beans,4.3141371110020564E-306" guid="_C9y0ANwuEdmRU7lXzo6lKQ" version="7.1.0">
  <mainDescription>&lt;h2>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>&lt;/a>Introduction&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    This guideline focuses on identifying Entity Beans. Additional guidance on Entity Beans is provided in &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../../tech.j2ee/guidances/guidelines/entity_bean_E721D57E.html&quot;&#xD;
    guid=&quot;4.528918585369678E-307&quot;>Guideline: Entity Bean&lt;/a> General guidance on EJBs is provided by &lt;a&#xD;
    class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/guidelines/enterprise_javabean_ejb_7F0C3AFF.html&quot;&#xD;
    guid=&quot;1.5078998518719443E-305&quot;>Guideline: Enterprise JavaBean (EJB)&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;Guidelines&quot; name=&quot;Guidelines&quot;>&lt;/a>Identifying Entity Beans&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    Entity analysis classes (see&lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_analysis_class_DAF7CE03.html&quot;&#xD;
    guid=&quot;{1E20603F-A5B8-42D5-BDBC-69DCE9C0FCDB}&quot;>Artifact: Analysis Class&lt;/a>) are often good candidates for entity beans,&#xD;
    as entity beans are geared to persistent data. Entity beans correspond to business entities that contain persistent&#xD;
    state. They provide services that implement business entity-specific logic. Another characteristic of entity beans is&#xD;
    that they can provide their services to many simultaneous clients. The EJB container handles the coordination of these&#xD;
    clients and their transactions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Entity beans are used to provide persistency, but can also encapsulate business logic. Generally, an entity bean should&#xD;
    only contain business logic related to the data persisted by the entity bean and any dependent data objects. Generally&#xD;
    inter-entity bean logic should be pulled out into session beans to minimize coupling between entity beans.&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;Modeling&quot; name=&quot;Modeling&quot;>&lt;/a>Modeling Entity Beans&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/guidelines/identifying_enterprise_javabeans_ejbs_2581AEE5.html&quot;&#xD;
    guid=&quot;9.931732120190802E-307&quot;>Guideline: Identifying Enterprise JavaBeans (EJBs)&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;Granularity&quot; name=&quot;Granularity&quot;>&lt;/a>Granularity&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    Granularity refers to the size of the data represented by the entity EJB. The appropriate granularity may depend on the&#xD;
    version of the EJB specification being used.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Prior to EJB 2.0, entity EJBs were recommended to always have a large granularity - typically representing large&#xD;
    groupings of data grouped from multiple database tables. This is because each entity EJB carried significant overheads&#xD;
    - in particular overheads related to being remoteable. For example, line items in an invoice or cells in a spreadsheet&#xD;
    are too fine-grained and shouldn't be accessed frequently over a network. In contrast, logical groupings of an&#xD;
    invoice's entries, or a subset of cells in a spreadsheet could be modeled as an entity EJB if additional business logic&#xD;
    is required for the data.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This changes somewhat in EJB 2.0-the introduction of local interfaces reduces some of these overheads and allows&#xD;
    finer-grained objects to be modeled as EJBs. Local and remote interfaces are described in &lt;a&#xD;
    class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html&quot;&#xD;
    guid=&quot;1.527482214591853E-307&quot;>Concept: Java 2 Platform Enterprise Edition (J2EE) Overview&lt;/a>. A local interface&#xD;
    doesn't have the overhead associated with a remote interface, allowing tightly coupled beans to interact more&#xD;
    efficiently. Local interfaces are particularly useful for fine-grained entities that are used to compose a larger&#xD;
    entity, the larger entity being responsible for the creation and destruction of the parts. Clients use the remote&#xD;
    interface of the larger entity, which, in turn, uses the local interfaces to interact with its parts.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Nevertheless, if an entity bean has a composition relationship to another class, then you may choose to model that&#xD;
    other class as an ordinary Java class rather than an entity bean. If using container-managed persistence, then such a&#xD;
    Java class is referred to as a &quot;dependent value class&quot;. Dependent value classes are simpler and quicker to develop and&#xD;
    test than entity beans, and are a good option, assuming the composed class doesn't require entity bean features. Some&#xD;
    limitations of dependent value classes are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        they cannot contain entity bean references&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        are &quot;get&quot; and &quot;set&quot; by value, which has some performance cost, but enables access from the remote interface&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;Encapsulation&quot; name=&quot;Encapsulation&quot;>&lt;/a>Encapsulation&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    Consider wrapping a set of related entity beans with a session bean facade to provide a logical interface for the&#xD;
    manipulation of the business entities that correspond to the entity EJBs. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/guidelines/identifying_session_beans_5E45D5DA.html&quot;&#xD;
    guid=&quot;6.241144674389355E-307&quot;>Guideline: Identifying Session Beans&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A similar approach is for one entity bean to encapsulate a set of other, generally dependent, local entity beans.&#xD;
    Remote clients access all data through the &quot;main&quot; entity bean. &lt;i>Core J2EE Patterns - Composite Entity Pattern&lt;/i>&#xD;
    ([&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/supportingmaterials/java_references_110189E3.html&quot;&#xD;
    guid=&quot;1.4494927535802764E-304&quot;>ALU01&lt;/a>] discusses this alternative - however, it recommends the session bean facade&#xD;
    as an easier method for managing entity bean relationships.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
