<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_C8dXQNwuEdmRU7lXzo6lKQ" name="describing_the_run-time_architecture_for_j2ee_applications,1.7390519818410197E-305" guid="_C8dXQNwuEdmRU7lXzo6lKQ" version="7.1.0">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>&lt;/a>Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The run-time architecture of an application is described in the Process View, an architectural view that describes the&#xD;
    concurrent elements of a system. These guidelines provide specific guidance on how to model the Process View for a J2EE&#xD;
    Application.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Also see &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/concepts/process_view_E3DD0B09.html&quot;&#xD;
    guid=&quot;6.45284088262517E-306&quot;>Concept: Process View&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Modeling&quot; name=&quot;Modeling&quot;>&lt;/a>Modeling the Process View&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    J2EE components (see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html#J2EE_Components&quot;&#xD;
     guid=&quot;1.527482214591853E-307&quot;>Concept: J2EE Overview: J2EE Components&lt;/a>) are deployed to environments called&#xD;
    Containers. See &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html#J2EE_Containers&quot;&#xD;
     guid=&quot;1.527482214591853E-307&quot;>Concept: J2EE Overview: J2EE Containers&lt;/a> for a description of each of the kinds of&#xD;
    containers defined by J2EE.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Each container is a concurrent element, and so should appear in the Process View of the architecture. Other important&#xD;
    concurrent elements that typically appear in the high-level process view are external systems.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The following is a typical diagram of the high level process view for a J2EE Application.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/process_view.gif&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In a real example, we would see a specific vendor's Message Oriented Middleware (MOM) represented, as well as specific&#xD;
    legacy systems and application clients. However, Web Container and EJB container are standard containers that should&#xD;
    appear in all J2EE process views.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that this diagram does not show the physical distribution of these systems over specific hardware nodes. That is&#xD;
    shown in the Deployment Model (see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../tech.j2ee/guidances/guidelines/describing_distribution_for_j2ee_applications_93B5A232.html&quot;&#xD;
    guid=&quot;2.0306406686133254E-306&quot;>Guideline: Describing Distribution for J2EE Applications&lt;/a>).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In this example, we see the selected inter-process communication mechanisms employed between the containers. J2EE&#xD;
    provides specific inter-process communication mechanisms. These are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Java Remote Method Invocation (RMI) for synchronous communication between Java classes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        RMI-IIOP for inter-operation with CORBA clients (typically legacy applications)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        HTTP/HTTPS for communication with web-based clients (although other web protocols may also be supported, such as&#xD;
        when interacting with XML Web services)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Java Message Service (JMS) for messaging and interactions with Message Oriented Middleware (MOM)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In defining the process view, one important decision is when to use JMS vs. RMI or RMI-IIOP. In this example, the&#xD;
    Application Client, EJB Container, and Another Legacy System use messaging to communicate. However, it is not clear&#xD;
    which elements communicate with which. To resolve the ambiguity, consider dropping the MOM System from the diagram, and&#xD;
    showing JMS as the association between elements that communicate by messaging.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another ambiguity is whether EJBs communicate amongst themselves via messaging. This can be clarified by showing a JMS&#xD;
    association from the EJB container to itself. The final diagram then becomes:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/process_view_simplified.gif&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The process view, however, is more than just containers and high level systems. It also addresses concurrency within&#xD;
    these containers and systems.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The process view should identify and model the following kinds of active classes.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Java threads&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        message destinations&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        message-driven beans (because they are invoked asynchronously via messages). See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
        href=&quot;./../../../tech.j2ee/guidances/guidelines/identifying_enterprise_javabeans_ejbs_2581AEE5.html&quot;&#xD;
        guid=&quot;9.931732120190802E-307&quot;>Guideline: Identifying Enterprise JavaBeans (EJBs)&lt;/a> for specific stereotypes used&#xD;
        to model message-driven beans.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        additional processes that are part of the overall system design. A separate timer process is an example of such a&#xD;
        process.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    When using JMS, you can choose to relate message producers and consumers directly, or model the relationship more&#xD;
    precisely by modeling topics and queues.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Interaction diagrams are used to show both synchronous and asynchronous communication between design elements. They can&#xD;
    also be used to analyze concurrent behavior for performance and logic problems. In particular, the software architect&#xD;
    can look for frequent messaging or high volumes of data transfer across the network. This may cause the architect to&#xD;
    redesign interfaces, or reassign design elements between threads of control, between servers, or between client and&#xD;
    server.&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that within an EJB container, threads and processes are managed by the EJB container - EJBs cannot create or&#xD;
    manage threads. Logically every EJB should be considered an active class, however, since calls to session beans and&#xD;
    entity beans are synchronous blocking calls, these are generally not modeled as active classes. The process view for an&#xD;
    EJB container is generally limited to the one concurrency mechanism available - JMS with JMS message-driven beans.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Even though session beans and entity beans are not generally modeled as active classes, there are concurrency issues -&#xD;
    such as one EJB reading the database while another writes. These issues are handled using transactions. The approach to&#xD;
    using transactions should be documented in the project-specific guidelines.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Allocating&quot; name=&quot;Allocating&quot;>&lt;/a>Allocating Design Elements to Active Classes&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/tasks/describe_runtime_architecture_2F8E190.html&quot;&#xD;
    guid=&quot;{4D35C038-A2D0-48B8-9ECD-52717FEAE33A}&quot;>Task: Describe the Run-time Architecture&lt;/a> talks about the need to&#xD;
    allocated design elements to processes and threads. In a J2EE application, all web components are allocated to the web&#xD;
    container, and all EJBs to the EJB container. Because of this simple relationship, there is no need to model this&#xD;
    allocation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If, however, your design includes additional concurrent processes (such as two different application clients) it may be&#xD;
    useful to specify which design elements execute on each application.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For Java threads, message-driven beans, and JMS topics and queues, the issues are more to do with how these&#xD;
    inter-communicate, in order to avoid deadlock, inconsistent data, and so forth. This is best explored by examining&#xD;
    use-case realizations that include these elements.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Alternatives&quot; name=&quot;Alternatives&quot;>&lt;/a>Other Modeling Alternatives&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Because of the affinity between the Process View and Deployment View, the high level diagrams for these views are often&#xD;
    combined.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Also, because each J2EE container is not only a process, but is also an execution environment, it may be modeled as a&#xD;
    &quot;logical node&quot; instead of as an active class.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
