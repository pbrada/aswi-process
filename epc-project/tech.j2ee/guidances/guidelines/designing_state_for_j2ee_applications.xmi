<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_C8pkgtwuEdmRU7lXzo6lKQ" name="designing_state_for_j2ee_applications,7.896195949843941E-306" guid="_C8pkgtwuEdmRU7lXzo6lKQ" version="7.1.0">
  <mainDescription>&lt;h3>&#xD;
    Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Effective management of application state is an important aspect of designing distributed applications. This guideline&#xD;
    provides an overview of some of the common design considerations and mechanisms for state management in a J2EE&#xD;
    application.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Design considerations related to state management should be addressed during the Elaboration Phase of the&#xD;
    project.&amp;nbsp; The software architect should examine general approaches to state management as part of the activities&#xD;
    associated with the Analysis &amp;amp; Design Discipline &lt;u>&lt;a&#xD;
    href=&quot;./../../../core.base_rup/capabilitypatterns/define_a_candidate_architecture_A3651DA3.html&quot;&#xD;
    guid=&quot;{71ADFE9A-34A0-41BD-8A17-BEA3210E2BBD}&quot; class=&quot;elementlinkwithtype&quot;>Activity: Define a Candidate&#xD;
    Architecture&lt;/a>&lt;/u>.&amp;nbsp; During the &lt;u>&lt;a href=&quot;./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot;&#xD;
    guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot; class=&quot;elementlinkwithtype&quot;>Task: Architectural Analysis&lt;/a>&lt;/u>, the&#xD;
    software architect should examine the scalability and performance requirements for the application to determine what&#xD;
    state management techniques will need to be used to enable the application to meet the performance objectives.&amp;nbsp; As&#xD;
    the design of the application is refined during the course of the Elaboration Phase, the architect will need to&#xD;
    define&amp;nbsp;J2EE specific design and implementation mechanisms for managing state information with the application in&#xD;
    the&lt;a href=&quot;./../../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html&quot;&#xD;
    guid=&quot;{C7A26BD7-3820-48D9-830F-684C3AF155F9}&quot; class=&quot;elementlinkwithtype&quot;>Task: Identify Design Mechanisms&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As described in &lt;a href=&quot;./../../../tech.j2ee/guidances/concepts/j2ee_deployment_configurations_C0F819AF.html&quot;&#xD;
    guid=&quot;7.671163061311939E-306&quot; class=&quot;elementlinkwithtype&quot;>Concept: J2EE Deployment Configurations&lt;/a>, J2EE&#xD;
    applications can be composed of several logical layers distributed across one to many physical tiers (machines).&amp;nbsp;&#xD;
    After a brief technical overview of state management, the remaining sections of this guideline will discuss the&#xD;
    different state management design and implementation mechanisms that can be used across the many application tiers.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that the software architect should document which mechanisms have been selected as part of the &lt;a&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
    guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot; class=&quot;elementlinkwithtype&quot;>Artifact: Software Architecture Document&lt;/a>,&#xD;
    and should provide guidelines for using these mechanisms as part of project-specific design guidelines.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a name=&quot;Topic 1&quot; id=&quot;Topic 1&quot;>&lt;/a>Technical Overview&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    There is growing trend to build distributed applications that interact with the Internet in one form or another. Even&#xD;
    though&amp;nbsp;the underpinnings of the Internet are by nature stateless, more often than not, there is a need to manage&#xD;
    state for building any kind of business application. Consider an Internet application where a&amp;nbsp; user clicks on a&#xD;
    link from page-a to page-b. The application processing the request for page-b no longer has access to the information&#xD;
    used to process page-a.&amp;nbsp; This behavior may be acceptable for static web pages, but most business applications&#xD;
    require some information about the previous processing. This is where state management mechanisms provided by J2EE come&#xD;
    in.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a name=&quot;Topic 1a&quot; id=&quot;Topic 1a&quot;>&lt;/a>Transient vs. Persistent State&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Before delving into the state management guidelines it is important to differentiate between types of state&#xD;
    information. State information can be broadly divided into two categories: transient&amp;nbsp;(only exists as long as the&#xD;
    application is active) and persistent (exists after the application has terminated).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Transient state information exists as long as the entity holding this information is alive. For example, state&#xD;
    information stored as a field in an ordinary Java class. If the container hosting this class is terminated for any&#xD;
    reason, the state information will be lost, unless the data has been replicated elsewhere, such as on a backup server.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Persistent state exists as long as the data store used to maintain state information exists.&amp;nbsp; Persistent state&#xD;
    information is generally stored in a file or database, and is loaded when needed by the application.&amp;nbsp; Any changes&#xD;
    to persistent state information must be written back to the database.&amp;nbsp; The integrity and recoverability aspects of&#xD;
    the persistent data store should be consistent with those of the data being accessed by the application. An example of&#xD;
    persistent state is information stored in a data store such as a relational database.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Session State&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Web clients often require the ability to make multiple browser requests, navigating from page to page, while retaining&#xD;
    client-specific information, such as items in a shopping cart. Web applications handle this by creating a session ID,&#xD;
    and associating state data with this session ID. The session ID and associated state is referred to as session state.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Session state is data associated with a particular client's interaction with a web application over a short period of&#xD;
    time (minutes or hours, rather than days). Thus, session state is short-lived data that is commonly deleted after some&#xD;
    time-out period, in order to avoid consuming resources.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Session state can be stored at the client or at the server, as described in later sections. The J2EE platform provides&#xD;
    mechanisms specifically tailored to managing session state, because of its importance in web-based applications.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Basic Persistence Mechanisms&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The following are common mechanisms used by web applications to store state.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a name=&quot;Topic 2a&quot; id=&quot;Topic 2a&quot;>&lt;/a>Cookies&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Cookies are small text files stored on web-based clients. A server can store cookies on the client. Subsequent client&#xD;
    requests send the cookie to the server, giving the server access to the state data stored in the cookie.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Some issues with cookies are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Many users believe that cookies compromise security and/or privacy and, therefore, they disable cookies.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        There are limitations on the size of cookie headers, and so this limits how much data can be stored.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Some protocols, such as Wireless Access Protocol (WAP) do not support cookies.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If a client logs in from another location (such as another machine) cookies stored in the other location are not&#xD;
        available.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        State data must be representable by string values.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a name=&quot;Topic 2a1&quot; id=&quot;Topic 2a1&quot;>&lt;/a>URL Rewriting&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    URL rewriting is a mechanism for embedding session state into the URLs referenced in each page. When a web server&#xD;
    generates pages to be delivered to a client, it encodes the session state into the URLs of the page. Then when the user&#xD;
    clicks on a URL, the state data stored in the URL is sent back to the server, allowing it to re-establish the session&#xD;
    context. A similar mechanism uses HTML hidden fields. Issues with these mechanisms are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        All pages in a given session must be handled by the server, otherwise the server may lose track of the session.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        State does not survive when the client shuts down her browser, or links to a specific URL by typing or using a&#xD;
        bookmark.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        As with cookies, the state data is not available when the client logs in from another location.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        As with cookies, the state data must be representable by string values.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a name=&quot;Topic 2d1&quot; id=&quot;Topic 2d1&quot;>&lt;/a>Flat File&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A flat file is one of the simplest methods of maintaining persistent state information.&amp;nbsp; Upon initialization, the&#xD;
    flat file is read to establish the initial state values.&amp;nbsp; Each time the state is changed, the file must be&#xD;
    rewritten to save the state.&amp;nbsp; Some disadvantages of maintaining application-state in a flat file are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The scalability of the application is adversely impacted, since the application must lock the application object to&#xD;
        prevent access to the global data while the application-state variables are being updated and rewritten to the flat&#xD;
        file.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        In most cases, updating data will require rewriting the entire file.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Flat files do not always provide recoverability in the event of an error.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a name=&quot;Topic 2d2&quot; id=&quot;Topic 2d2&quot;>&lt;/a>XML&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Maintaining persistent state information in an XML file is a step up from a flat file.&amp;nbsp; Some advantages of&#xD;
    maintaining application state in an XML file as opposed to a flat file are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        An XML file provides structure that is not present in a flat file.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        An XML file can be parsed using standard APIs.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        An XML file is generally more portable.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a name=&quot;Topic 2d3&quot; id=&quot;Topic 2d3&quot;>&lt;/a>Database&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Maintaining persistent state information in a database provides the maximum recoverability.&amp;nbsp; Some advantages of&#xD;
    maintaining application state in a database are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The design of the tables provides structure.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The entire application state does not need to be rewritten when an application variable is updated.&amp;nbsp; Only the&#xD;
        updated information needs to be rewritten.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Consistency can be maintained by coordinating application state recovery with recovery of the production database.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        For high reliability situations, the database server can be clustered.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Databases can be accessed using the Java Database Connectivity (JDBC) API. JDBC can also be used for accessing other&#xD;
    tabular data sources including spreadsheets, and flat files.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a name=&quot;J2EE Mechanisms&quot; id=&quot;J2EE Mechanisms&quot;>&lt;/a>J2EE-Specific Mechanisms&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The J2EE platform provides specific mechanisms for managing state. These are higher-level mechanisms that can be&#xD;
    configured to use one or more of the basic mechanisms described thus far.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Servlet Context&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Servlets can use the servlet context to save data applicable to multiple clients and client sessions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Data stored in the servlet context are essentially global variables for the J2EE application.&amp;nbsp; As a result, the&#xD;
    use of application state can have a significant impact on application design.&amp;nbsp; The software architect needs to&#xD;
    factor in the following items during the &lt;a href=&quot;./../../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html&quot;&#xD;
    guid=&quot;{C7A26BD7-3820-48D9-830F-684C3AF155F9}&quot; class=&quot;elementlinkwithtype&quot;>Task: Identify Design Mechanisms&lt;/a> in&#xD;
    determining if the servlet context is appropriate:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Servlet context can be maintained in a single process, thus not shared across multiple servers (clusters).&amp;nbsp; If&#xD;
        this does not match the application's scalability needs, the architect needs to consider storing the state as&#xD;
        session-state.&amp;nbsp;&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Servlet context is part of the process memory, therefore it is typically not maintained when the process is&#xD;
        terminated.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Multiple threads can access the global data.&amp;nbsp; Locking and synchronization of the global data may impact the&#xD;
        scalability of the application.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    HTTP Session Object&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Servlets and JSPs can store data associated with a particular client session in the HTTP Session Object. If storing&#xD;
    data in session objects, then there may be issues around how session data is made available across multiple servers.&#xD;
    Some vendors provide the ability to route client requests to the same server, a practice known as &quot;server affinity&quot;.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The HTTP Session Object is available at the server during the processing of client requests, but may or may not be&#xD;
    stored at the server between requests. The server could be configurable to use any of the basic persistency mechanisms&#xD;
    described previously, including storing the session state in cookies on the client, or in files or a database on the&#xD;
    server. It could also provide the ability to replicate session data in memory across servers.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The mechanism is selected by configuring the server - JSPs and servlets are coded independently of the selected&#xD;
    mechanism, accessing the session object using an API specified by the Servlet specification.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Enterprise JavaBeans&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Enterprise JavaBeans include high level mechanisms for storing state, which are based on the lower level mechanisms&#xD;
    previously described, such as databases and files. Stateful session beans are used to store data associated with a&#xD;
    particular client session, while entity beans are used to store longer-term data. See &lt;a&#xD;
    href=&quot;./../../../tech.j2ee/guidances/guidelines/enterprise_javabean_ejb_7F0C3AFF.html&quot;&#xD;
    guid=&quot;1.5078998518719443E-305&quot; class=&quot;elementlinkwithtype&quot;>Guideline: Enterprise JavaBean (EJB)&lt;/a> for discussion of&#xD;
    state stored by EJBs.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Designing Session State&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Web clients often require the ability to make multiple browser requests, navigating from page to page, while retaining&#xD;
    client-specific information, such as items in a shopping cart. Web applications handle this by creating a session ID,&#xD;
    and associating state data with this session ID.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The session ID itself is stored on the client by one or two mechanisms:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        cookie - The client browser sends this cookie&amp;nbsp;to the server on each request allowing the server to&#xD;
        re-establish session-state.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        URL rewriting - the URLs in pages delivered to the client by the server have the session ID encoded. When the user&#xD;
        clicks on such a URL, the session ID is sent to the server, allowing the server to re-establish session state.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The server is configured to use the selected approach. Servlets and JSP should be coded to work regardless of the&#xD;
    method configured. Specifically, use the HttpServletResponse.encodeURL() method to encode all URLs. This method checks&#xD;
    if URL rewriting is enabled, and if so, performs the encoding.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The data associated with a session ID can be stored in the HTTP session object, where it can be accessed by JSPs and&#xD;
    servlets, or in session beans.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Both the session ID and associated data should be set to time-out, so that session data that has not been used in a&#xD;
    long time does not consume resources indefinitely. The architect should select an appropriate time-out period.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a name=&quot;Topic 2b2&quot; id=&quot;Topic 2b2&quot;>&lt;/a>Selecting the Right Mechanism&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Architects should consider storing session state in the client for reasons of simplicity and performance. When the&#xD;
    state is managed and stored at the client, servers do not have to expend resources to store state information or to&#xD;
    ensure its consistency. The downside of storing the state information with the client is that the information needs to&#xD;
    be sent up to the server whenever needed, thus causing network latency related issues. There may be also be security&#xD;
    considerations, if there is session state data that you do not wish to be exposed to the client. In this case,&#xD;
    encryption may be an option.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If your application has large amounts of session state, it is generally preferable to store this state on the server,&#xD;
    where there are generally fewer size and type limitations.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Generally session state related to presentation concerns should be stored in the HTTP session object, while stateful&#xD;
    session beans should contain state required for correctly implementing business logic. Duplication of state data should&#xD;
    be avoided - instead, move any duplicated state data into the HTTP session, and pass this data into the session bean as&#xD;
    parameters on session bean method invocations, as required.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If session data stored on the server must survive the failure of a server node, then consider using a mechanism to&#xD;
    persist or replicate session data.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Designing Longer-Lived State&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Session data is for short-lived client data that times out. There may also be a need for data that survives for much&#xD;
    longer periods of time.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The right mechanism for such data depends on the nature of the data being stored. Cookies, flat files, XML files, and&#xD;
    databases are all options. For database access, an entity bean is generally the best choice. See &lt;a&#xD;
    href=&quot;./../../../tech.j2ee/guidances/guidelines/entity_bean_E721D57E.html&quot; guid=&quot;4.528918585369678E-307&quot;&#xD;
    class=&quot;elementlinkwithtype&quot;>Guideline: Entity Bean&lt;/a>s for details.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
