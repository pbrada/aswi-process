<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_xy155MezEdmYjcUf1_oIew" name="implementing_classes,6.392513032248068E-306" guid="_xy155MezEdmYjcUf1_oIew" changeDate="2005-10-18T21:06:39.642-0700" version="7.1.0">
  <mainDescription>&lt;div align=&quot;left&quot;>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            &lt;a href=&quot;#Implement%20Operations&quot;>Implementing Operations&lt;/a>&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;a href=&quot;#Implement%20States&quot;>Implementing States&lt;/a>&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;a href=&quot;#Use%20Delegation%20to%20Reuse%20Implementation&quot;>Using Delegation to Reuse Implementation&lt;/a>&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;a href=&quot;#Implement%20Associations&quot;>Implementing Associations&lt;/a>&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;a href=&quot;#Implement%20Attributes&quot;>Implementing Attributes&lt;/a>&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Implement Operations&quot; href=&quot;#Implement%20Attributes&quot; name=&quot;Implement Operations&quot;>Implementing Operations&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    To implement operations, do the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Choose an algorithm.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Choose data structures appropriate to the algorithms.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Define new classes and operations as necessary.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Code the operation.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h5>&#xD;
    Choose an Algorithm&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Many operations are simple enough to be implemented from the operation and its specification.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Nontrivial algorithms are primarily needed for two reasons: to implement complex operations for which a specification&#xD;
    is given, and to optimize operations for which a simple but inefficient algorithm serves as definition.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Choose Data Structures Appropriate To the Algorithms&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Choosing algorithms involves choosing the data structure they work on. Many implementation data structures are&#xD;
    container classes, such as, arrays, lists, queues, stacks, sets, bags, and variations of these. Most object-oriented&#xD;
    languages, and programming environments provide class libraries with these kinds of reusable components.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Define New Classes and Operations as Necessary&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    New classes may be found to hold intermediate results, for example. New low-level operations may be added on the class&#xD;
    to decompose a complex operation. These operations are often private to the class, that is, not visible outside the&#xD;
    class itself.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Code the Operation&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Write the code for the operation starting with its interface statement. Follow applicable programming guidelines.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Implement States&quot; href=&quot;#Top&quot; name=&quot;Implement States&quot;>Implementing States&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The state of an object may be implemented by reference to the values of its attributes, with no special representation.&#xD;
    The state transitions for such an object will be implicit in the changing values of the attributes, and the varying&#xD;
    behaviors are programmed through conditional statements.&amp;nbsp; This solution is not satisfactory for complex behavior&#xD;
    because it usually leads to complex structures which are difficult to change as more states are added or the behavior&#xD;
    changes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the design element (or its constituents') behavior is state-dependent, there will typically be one or more&#xD;
    statechart diagrams that describe the behavior of the model elements in the design element. These statechart diagrams&#xD;
    serve as an important input during implementation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The state machines shown in statechart diagrams make an object's state explicit, and the transitions and required&#xD;
    behavior are clearly delineated. A state machine may be implemented in the following ways:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Simple state machines can be implemented by defining an attribute which enumerates the possible states, and using&#xD;
        the attribute to select the behavior for incoming messages. For example, in a switch statement in Java or C++. This&#xD;
        solution does not scale very well for complex state machines and may lead to poor run-time performance. See [&lt;a&#xD;
        class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot;&#xD;
        guid=&quot;7.755968586980351E-308&quot;>DOUG98&lt;/a>], Chapter 4, 4.4.3 for an example of this method&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        More complex state machines may use the State pattern. See [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
        href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; guid=&quot;7.755968586980351E-308&quot;>GAM94&lt;/a>] for a&#xD;
        description of the State pattern. [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
        href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; guid=&quot;7.755968586980351E-308&quot;>DOUG98&lt;/a>], Chapter&#xD;
        6, 6.2.3, &lt;i>State Pattern&lt;/i>, also describes this approach&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A table-driven approach works well for very complex state machines where ease of change is a criterion. In this&#xD;
        approach, there are entries for each state in a table where each entry maps inputs to succeeding states and&#xD;
        associated transition actions. See [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
        href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; guid=&quot;7.755968586980351E-308&quot;>DOUG98&lt;/a>], Chapter&#xD;
        6, 6.2.3, &lt;i>State Table Pattern,&lt;/i> for an example of this method.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    State machines with concurrent substates may be implemented by delegating state management to active objects, one for&#xD;
    each concurrent substate, because concurrent substates represent independent computations (which may, nevertheless,&#xD;
    interact). Each substate may be managed using one of the techniques described above.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Use Delegation to Reuse Implementation&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot;&#xD;
    name=&quot;Use Delegation to Reuse Implementation&quot; guid=&quot;7.755968586980351E-308&quot;>Using Delegation to Reuse&#xD;
    Implementation&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    If a class or parts of a class can be implemented by reusing an existing class, use delegation rather than inheritance.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Delegation means that the class is implemented with the help of other classes. The class references an object of the&#xD;
    other class by using a variable. When an operation is called, it calls an operation in the referenced object (of the&#xD;
    reused class) for actual execution. Thus, it delegates responsibility to the other class.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Implement Associations&quot; href=&quot;#Top&quot; name=&quot;Implement Associations&quot;>Implementing Associations&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A one-way association is implemented as a pointer - an attribute which contains an object reference. If the&#xD;
    multiplicity is &lt;b>one&lt;/b>, then it is implemented as a simple pointer. If the multiplicity is &lt;b>many&lt;/b>, then it is&#xD;
    a set of pointers. If the &lt;b>many&lt;/b> end is ordered then a list can be used instead of a set.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A two-way association is implemented as attributes in both directions, using techniques for one-way associations.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A qualified association is implemented as a lookup table (for example, a Smalltalk Dictionary class) in the qualifying&#xD;
    object. The selector values in the lookup table are the qualifiers, and the target values are the objects of the other&#xD;
    class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the qualifier values must be accessed in order, then the qualifiers can be arranged into a sorted array or a tree.&#xD;
    In this case, access time will be proportional to log N where N is the number of qualifier values.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the qualifiers are drawn from a compact finite set, then the qualifier values can be mapped into an integer range&#xD;
    and the association can be efficiently implemented as an array. This approach is more attractive if the association is&#xD;
    mostly full rather than sparsely populated, and it is ideal for fully populated finite sets.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Most object-oriented languages and programming environments provide class libraries with reusable components to&#xD;
    implement different kinds of associations.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Implement Attributes&quot; href=&quot;#Top&quot; name=&quot;Implement Attributes&quot;>Implementing Attributes&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Implement attributes in one of three ways: use built-in primitive types, use an existing class, or define a new class.&#xD;
    Defining a new class is often more flexible, but introduces unnecessary indirection. For example, an employee's Social&#xD;
    Security number can either be implemented as an attribute of type String or as a new class.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;37&quot; alt=&quot;Alternative Attribute Implementations Illustration&quot; src=&quot;resources/ac_impc1.gif&quot; width=&quot;430&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Alternative implementations of an attribute.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It may also be the case that groups of attributes are combined into new classes, as the following example shows. Both&#xD;
    implementations are correct.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;78&quot; alt=&quot;Point Class Line Implementation Attributes&quot; src=&quot;resources/ac_impc2.gif&quot; width=&quot;381&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    The attributes in Line are implemented as associations to a Point class.&lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
