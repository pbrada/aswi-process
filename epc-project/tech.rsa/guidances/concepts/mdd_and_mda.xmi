<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_VY7Bg8e0EdmYjcUf1_oIew" name="mdd_and_mda,4.227832989444728E-303" guid="_VY7Bg8e0EdmYjcUf1_oIew" changeDate="2006-05-05T10:26:34.971-0700" version="7.1.0">
  <mainDescription>&lt;h3>&#xD;
    Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Models are an important kind of&amp;nbsp;work product&amp;nbsp;in the Rational Unified Process and are typically expressed (in&#xD;
    RUP) using the Unified Modeling Language (UML), in a tool and environment-neutral way, so that RUP may be deployed and&#xD;
    enacted with many toolsets in many environments. The &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/supportingmaterials/model_visually_uml_5FB6F965.html&quot;&#xD;
    guid=&quot;2.2182245081579854E-305&quot;>Supporting Material: Visual Modeling&lt;/a> explores some of the reasons for modeling,&#xD;
    including:&#xD;
&lt;/p>&#xD;
&lt;div style=&quot;MARGIN-LEFT: 2em&quot;>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            To aid in the understanding of complex systems&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            To explore and compare design alternatives at a low cost As a foundation for implementation&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            To capture requirements precisely&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            To communicate decisions unambiguously&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Models are seen as a way to reason about system behavior (both desired and realized) and structure, and communicate the&#xD;
    results of these deliberations to interested stakeholders. MDD and MDA emphasize the role of models as foundational&#xD;
    elements for implementation, in the expectation that they will be more than blueprints based on which human developers&#xD;
    will write code, but are themselves enactable or executable to a degree depending on the capability of the supporting&#xD;
    toolset. This follows a trend, begun a long time ago, of increasing the level of abstraction at which the human&#xD;
    developer works. This shifts the spotlight from code as we know it, to models expressed in a yet higher, perhaps&#xD;
    graphical, language. RUP, by identifying certain artifacts as models rather than documents (capturing requirements and&#xD;
    design, for example) containing pictures of models, implicitly supports this possibility.&lt;a id=&quot;Viewpoints and Views&quot;&#xD;
    name=&quot;Viewpoints and Views&quot;>&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Viewpoints and Views &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot;&#xD;
    width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A viewpoint, as its name implies, is a notional position from which some aspects or concerns about the system (or the&#xD;
    set of models representing the system) are made visible, implying the application of a set of concepts and rules to&#xD;
    form a conceptual filter. The term &quot;perspective&quot; is used similarly, to describe a way of viewing and understanding&#xD;
    models that best serves the many different orientations and concerns of the diverse stakeholders.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Views are projections of models, which show entities that are relevant from a particular viewpoint or perspective.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In MDD, viewpoints and views are used to separate concerns, for example, to deal with the logical structure&#xD;
    independently of the physical structure and independently of the process structure. The closer the models are to the&#xD;
    problem domain, the more strongly the viewpoints or perspectives map to the business concerns of the stakeholders; as&#xD;
    the models are developed closer to executable form, the more computational concerns intrude. In either case, the aim is&#xD;
    not simply to produce passive illustrations, but models that are, at least potentially, generative of implementations&#xD;
    that satisfy these separate concerns.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Elaboration and Translation&quot; href=&quot;#Top&quot; name=&quot;Elaboration and Translation&quot;>&lt;/a>Elaboration and Translation&#xD;
    (Transformation) &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    These terms are often used informally to distinguish between model changes done by hand (elaboration) and model changes&#xD;
    done by a tool (translation). In RUP, elaboration has a quite different formal meaning - it is the name of a life-cycle&#xD;
    phase - but in this section, we are using it informally to illustrate apparently differing approaches to the evolution&#xD;
    of models.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There is also a sense of different step size in translation and elaboration - a sense that a model is elaborated in&#xD;
    several small steps until there is sufficient detail (including language, infrastructure or operating system detail) to&#xD;
    generate code from it, either by a tool or manually. By manually, we mean that a human can look at the model and write&#xD;
    Java, C++, or other languages, possibly elaborating further in the process. In contrast, in translation, the model,&#xD;
    still at a level of abstraction unsullied by language, infrastructure or operating system concerns, is converted into&#xD;
    something that executes and produces the desired result with little or no further elaboration. Note that the desired&#xD;
    result includes performance and other non-functional characteristics. Therefore, implicit in this approach, is that&#xD;
    such cross-cutting architectural concerns are addressed in the way the model is constructed and the way in which it&#xD;
    describes resource requirements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another word, &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/transformation_B58336DE.html&quot; guid=&quot;_yZF5hNnmEdmO6L4XMImrsA&quot;>Term&#xD;
    Definition: transformation&lt;/a>, has come into currency, to describe the process of generating a target model from a&#xD;
    source model by following a set of rules and working according to a set of parameters. Note that we use the term&#xD;
    &quot;model&quot; here in the same way as RUP, so the target model could be the implementation elements, for example, code or&#xD;
    text. Of course, transformation can be done by hand, which makes successive transformations (adding detail) equivalent&#xD;
    to elaboration, and the rules may be very complex and rooted in deep experience of the available technology and the&#xD;
    domain. The default meaning however, is that transformation is done automatically, which is examined again in the next&#xD;
    section on Model Driven Architecture&amp;reg;.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that the idea of transformation simply involves a source model and a target model. The usual case is that the&#xD;
    target model is less abstract than the source model, that is, that the target is somehow more specific than the source,&#xD;
    but this is not implicit in the idea of transformation. Note that transformation can also add detail to a model,&#xD;
    producing a target model that is more refined, while remaining broadly at the same level of abstraction, in that no&#xD;
    information relevant to another domain is introduced. Contrast this with a transformation that produces code from a UML&#xD;
    model, much is introduced into this target model that is of no concern to the business stakeholder, provided required&#xD;
    behavior and nonfunctional characteristics are maintained.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The ability to realize the translation ideal depends on the capabilities of the tool and our ability to codify, capture&#xD;
    and reuse the knowledge employed by an experienced human. The amount of knowledge that must be captured and codified&#xD;
    depends on the level of abstraction from which we make our translation step - the higher the level, the more knowledge&#xD;
    and the more domain dependence, typically.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In MDD, we strive to raise the level of abstraction from which we can automatically generate an operational system. A&#xD;
    model is elaborated to the point where it can be used to generate something. Then the strong preference is that the&#xD;
    output does not have to be elaborated further to execute. Further, our ambition is to make the preceding elaboration,&#xD;
    as far as possible, through successive automated transformations. Thus, the two approaches converge: translation is&#xD;
    realized by successive transformation steps, automated as far as possible. The final transformation to executing system&#xD;
    occurs with the model description still at a high level of abstraction, and with the technology, infrastructure, and&#xD;
    target language selections encoded in the transformation engine, and the rules and data supplied to it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An additional benefit of MDD is that we hope to be able to reuse transformations, by having them codify platform and&#xD;
    domain knowledge and best practices through creation by experts in the corresponding domains. In this way, we&#xD;
    facilitate reuse by less skilled developers and avoid re-creation from scratch with each new application.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    What is a High Level of Abstraction? &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    There are a few ways to look at this. One is along the spectrum of language, and we are seeing the emergence of forms&#xD;
    of executable UML, for example. Another is from the perspective of domain engineering, where the language and modeling&#xD;
    concepts may be specialized for the domain. For example, UML is a general-purpose language, so, along this dimension&#xD;
    you find the use of &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/uml_profile_1B75E5A2.html&quot; guid=&quot;_yZilc9nmEdmO6L4XMImrsA&quot;>Term&#xD;
    Definition: UML profile&lt;/a> to specialize the use of UML. Yet another way is the felt need to avoid vendor-specific,&#xD;
    infrastructure-specific models so as to remain open to new technology.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In terms of expression of the detailed dynamics, the work done on &lt;a&#xD;
    href=&quot;http://www.omg.org/technology/documents/formal/uml.htm&quot; target=&quot;_blank&quot;>UML Action Semantics&lt;/a> has made&#xD;
    executable forms of UML a possibility, but the concrete syntax and notation are not standardized and the level of the&#xD;
    Action Semantics is akin to other OO languages. Therefore, UML plus Action Semantics is probably not the final answer,&#xD;
    but it is an indication of where things are headed.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    We conclude that a model expressed in UML, or using a UML profile, that contains no vendor-dependent elements, is not&#xD;
    dependent on a particular infrastructure platform, such as J2EE or Microsoft&amp;reg; .NET, and is semantically complete in&#xD;
    structure and behavior without recourse to a particular procedural language (Java, C#, ...) is at a high level of&#xD;
    abstraction by this definition, although the issue of the level of the Action Semantics remains.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    From a problem-domain perspective, that is, the user or business customer viewpoint, a possible and attractive solution&#xD;
    is the formulation of domain-specific modeling languages. These are languages that are abstract, in the sense that they&#xD;
    are couched in terms and concepts familiar to workers in the particular domain, yet are complete in their ability to&#xD;
    express model dynamics, while still being UML based.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;How does this relate to RUP&quot; href=&quot;http://www.omg.org/technology/documents/formal/uml.htm&quot; target=&quot;_blank&quot;&#xD;
    name=&quot;How does this relate to RUP&quot;>&lt;/a>How does this relate to RUP? &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot;&#xD;
    alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The relationship of the RUP Analysis, Design and Implementation Models illustrates these ideas: the &lt;a&#xD;
    class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/workproducts/rup_analysis_model_76C3B70C.html&quot;&#xD;
    guid=&quot;{98EA224C-36F6-46E6-AB36-2999382B58B3}&quot;>Analysis Model&lt;/a> represents an early view of how the behavior expressed&#xD;
    in use cases will be realized; it is naturally skewed descriptively towards the domain of the problem being addressed,&#xD;
    and the &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/workproducts/rup_analysis_class_DAF7CE03.html&quot;&#xD;
    guid=&quot;{1E20603F-A5B8-42D5-BDBC-69DCE9C0FCDB}&quot;>Analysis Classes&lt;/a> it contains are regarded as conceptual groupings of&#xD;
    the required responsibilities and behavior. The Analysis Model is not usually complete enough to execute, except&#xD;
    perhaps in a thought experiment by a human reading the model and filling in the gaps, because too much is left unsaid.&#xD;
    Instead, the Analysis Model has to go through a process of refinement, adding detail and precision, resulting in the &lt;a&#xD;
    class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/workproducts/rup_design_model_2830034D.html&quot;&#xD;
    guid=&quot;{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}&quot;>Design Model&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    RUP allows a project to maintain a separate Analysis Model or to regard the Analysis Model as something that evolves&#xD;
    into the Design Model. The process of refinement is described at some length in RUP's tasks, with the default&#xD;
    interpretation that humans playing the roles of Software Architect and Designer will accomplish this evolution,&#xD;
    probably with considerable tool assistance. Note that this refinement can be regarded as a sequence of model&#xD;
    transformations, some of which may potentially be automated, for example, in the application of &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/termdefinitions/analysis_pattern_86D515F0.html&quot;&#xD;
    guid=&quot;_x613Q9nmEdmO6L4XMImrsA&quot;>Term Definition: analysis pattern&lt;/a> and &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/design_pattern_4AEB9B64.html&quot; guid=&quot;_yF4CnNnmEdmO6L4XMImrsA&quot;>Term&#xD;
    Definition: design pattern&lt;/a> patterns in the RUP tasks &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot;&#xD;
    guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot;>Architectural Analysis&lt;/a> and &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html&quot;&#xD;
    guid=&quot;{C7A26BD7-3820-48D9-830F-684C3AF155F9}&quot;>Identify Design Mechanisms&lt;/a> .&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;When is the Design Model Complete&quot; href=&quot;./../../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html&quot;&#xD;
    name=&quot;When is the Design Model Complete&quot; guid=&quot;{C7A26BD7-3820-48D9-830F-684C3AF155F9}&quot;>&lt;/a>When is the Design Model&#xD;
    Complete? &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The Design Model evolves throughout the life of the project, through several iterations; therefore, when is the Design&#xD;
    Model (or some portion of it) able to be turned into code, that is, when can we start to produce &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/workproducts/rup_implementation_element_49BB163E.html&quot;&#xD;
    guid=&quot;{E1E0DDA3-914F-4CC1-9D0A-ED4B8E8BBA89}&quot;>Implementation Elements&lt;/a> and integrate them into interesting &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/workproducts/rup_build_BA336272.html&quot;&#xD;
    guid=&quot;{53728CD9-FA47-4B58-A443-E9F9DC196916}&quot;>Builds&lt;/a> of the system? RUP offers some guidance on &lt;a&#xD;
    class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/guidances/concepts/mapping_from_design_to_code_D1454680.html&quot;&#xD;
    guid=&quot;1.424219730601675E-305&quot;>Mapping from Design to Code&lt;/a> but fundamentally there are no hard and fast answers. You&#xD;
    move to implementation when, through review for example, you judge that you can, and that point can vary considerably&#xD;
    between organizations and projects. RUP offers a number of ways to proceed from design to code, two of which we discuss&#xD;
    here to illustrate how decisions about design completeness are made:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>1. Sketch and Code&lt;/strong>&lt;br />&#xD;
     RUP says: &lt;em>&quot;One common approach to design is to sketch out the design at a fairly abstract level, and then move&#xD;
    directly to code. Maintenance of the design model is manual.&quot;&lt;/em>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To be successful with this approach requires that the developer is able to bridge the abstraction gap between the&#xD;
    design and implementation levels. Often maintenance of the design model is a secondary concern and the code becomes the&#xD;
    focus!&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>2. Round-Trip Engineering (RTE) with Single Evolving Design Model&lt;/strong>&lt;br />&#xD;
     RUP says: &lt;em>&quot;In this approach, there is a single Design Model. Initial sketches of design elements evolve to the&#xD;
    point where they can be synchronized with code.&quot;&lt;/em>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Here the developers close the abstraction gap with a sequence of modeling steps. The difference between this approach&#xD;
    and &quot;sketch and code&quot; is that the intermediate steps are manifest and, at the end, the abstract version of the design&#xD;
    model has disappeared.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In both cases, the potential value of an abstract design model is lost: in &quot;sketch and code&quot; because the abstract&#xD;
    design model is typically not maintained and, over time, loses touch with the code and in &quot;single evolving design&#xD;
    model&quot; because the abstract version disappears. Even if an initial version is kept, it usually suffers the same fate as&#xD;
    the sketch and code design model. Note that the end point for the design model with RTE is really code visualization,&#xD;
    and a similar visualization could be reverse-engineered from code produced in sketch and code with appropriate tooling.&#xD;
    In RUP, we mitigate the loss of the abstract design model, to some extent, by capturing significant architectural views&#xD;
    and design rationale, at critical points, in the Software Architecture Document.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    MDD offers the hope that the abstract design model will become foundational to code generation and have longevity. It&#xD;
    becomes the primary basis for maintenance and, in fact, may be the only basis for maintenance. It also offers a clear&#xD;
    definition of the end point for design, that is, that point at which, as far as the transformation engine is concerned,&#xD;
    the model is complete, consistent and unambiguous and able to be turned into an executable system. How abstract the&#xD;
    model can be depends on the available technology and toolset (for an example see &lt;img height=&quot;16&quot; alt=&quot;helpbook icon&quot;&#xD;
    src=&quot;../../../core.base_rup/resources/helpbook.gif&quot; width=&quot;16&quot; /> Tour: Rational Software Architect Overview) and may also be&#xD;
    domain dependent. Note that as far as MDD is concerned, this is simply another transformation (design to code) but an&#xD;
    important one that jumps across abstraction levels.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The next section describes an emerging framework standard for MDD, an initiative of the Object Management Group (OMG)&#xD;
    called Model Driven Architecture&amp;reg; (MDA&amp;reg;).&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;Model Driven Architecture MDA&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/mapping_from_design_to_code_D1454680.html&quot; name=&quot;Model Driven Architecture MDA&quot;&#xD;
    guid=&quot;1.424219730601675E-305&quot;>&lt;/a>Model Driven Architecture (MDA) &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h2>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Motivation&quot; href=&quot;#Top&quot; name=&quot;Motivation&quot;>&lt;/a>Motivation &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    MDA is an initiative of the OMG, an industry consortium of some 800 members with a mission to establish standard&#xD;
    guidelines and specifications to provide a common vendor-neutral framework for application development and encourage&#xD;
    interoperability across major hardware and software infrastructure platforms. The Unified Modeling Language is a&#xD;
    product of the OMG. The OMG now promotes MDA as its flagship specification and with the OMG's stance as the promulgator&#xD;
    of practical standards intended to be supported by industry IC, practice, products and tools, and noting the success of&#xD;
    UML, MDA is worthy of study. There is a wealth of information on MDA, including the most recent MDA Guide [&lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; target=&quot;_blank&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>OMG03&lt;/a>], on the OMG's &lt;a href=&quot;http://www.omg.org&quot; target=&quot;_blank&quot;>Web site&lt;/a> .&#xD;
    There are also several books available such as [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; target=&quot;_blank&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>FRA03&lt;/a>], [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; target=&quot;_blank&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>KLE03&lt;/a>], and [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; target=&quot;_blank&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>MEL04&lt;/a>] and many articles, such as &quot;An MDA Manifesto&quot; by Grady Booch, Alan Brown,&#xD;
    Sridhar Iyengar, James Rumbaugh and Bran Selic in The MDA Journal, May 2004.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;MDAs Core Ideas&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; target=&quot;_blank&quot;&#xD;
    name=&quot;MDAs Core Ideas&quot; guid=&quot;7.755968586980351E-308&quot;>&lt;/a>MDA's Core Ideas &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot;&#xD;
    alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    MDA introduces some specific concepts and terminology that distinguish it from more general approaches to MDD, and&#xD;
    these are defined and discussed in the following sections.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Building on Existing Standards&quot; href=&quot;#Top&quot; name=&quot;Building on Existing Standards&quot;>&lt;/a>Building on Existing&#xD;
    Standards &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    MDA is underpinned by existing OMG standards, including:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The Meta-Object Facility (MOF) - In addition to defining a language for the construction of metamodels, for&#xD;
        example, UML and &lt;a href=&quot;#CWM&quot;>CWM&lt;/a>, the MOF defines a framework for implementing repositories for models and&#xD;
        metamodels, allowing a consistent approach to manipulation of these models when using MDA. The MOF is thus an&#xD;
        essential technology for MDA.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The Unified Modeling Language (UML) - The &lt;a href=&quot;#PlatformIndependentModelPIM&quot;>PIM&lt;/a>s, &lt;a&#xD;
        href=&quot;#PlatformModel&quot;>PM&lt;/a>s and the &lt;a href=&quot;#PlatformSpecificModelPSM&quot;>PSM&lt;/a> s are defined in UML, which is&#xD;
        the foundational notation for MDA.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        XML Metadata Interchange (XMI) - XMI defines a UML model interchange format based on XML.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a id=&quot;CWM&quot; href=&quot;#PlatformSpecificModelPSM&quot; name=&quot;CWM&quot;>&lt;/a>The Common Warehouse Metamodel (CWM) - As UML is to&#xD;
        application modeling, so the CWM is to data modeling.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;PlatformIndependence&quot; href=&quot;#PlatformSpecificModelPSM&quot; name=&quot;PlatformIndependence&quot;>&lt;/a>Platform Independence &lt;a&#xD;
    href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An intuitive notion of a &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/platform_4197EF6C.html&quot; guid=&quot;_yQJ_-dnmEdmO6L4XMImrsA&quot;>Term Definition:&#xD;
    platform&lt;/a> is that it supports a higher architectural layer through provision of services with a well-defined set of&#xD;
    interfaces that hide the implementation details. The OMG definition (in the MDA Guide) of platform is:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;em>&quot;A set of subsystems/technologies that provide a coherent set of functionality through interfaces and specified&#xD;
    usage patterns that any subsystem that depends on the platform can use without concern for the details of how the&#xD;
    functionality provided by the platform is implemented.&quot;&lt;/em>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This is similar to the concept of a &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/layer_F3814B38.html&quot; guid=&quot;_yMbWgNnmEdmO6L4XMImrsA&quot;>Term Definition:&#xD;
    layer&lt;/a> as it is used in RUP.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The idea of &lt;em>platform independence&lt;/em> is slightly slippery: it is a quality or characteristic of a model, for&#xD;
    example, one might say a model is independent of a particular platform when it does not contain any references to&#xD;
    services or capability provided by that platform. However, the statement is relative because it is difficult to&#xD;
    envisage an absolute form of platform independence. The MDA Guide acknowledges this and also admits the possibility of&#xD;
    degrees of platform independence with respect to a particular platform where, for example, a model uses a generalized&#xD;
    form of a feature in a particular platform.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The achievement of platform independence has been assisted by the evolution of platforms such as J2EE, .NET and&#xD;
    WebSphere, to increasing levels of abstraction in terms of what is exposed to applications. This makes the&#xD;
    identification of platform-neutral constructs much more tractable and the platform-specific transformations that&#xD;
    convert them much simpler and easier to write.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;PlatformIndependentModelPIM&quot; name=&quot;PlatformIndependentModelPIM&quot;>&lt;/a>Platform Independent Model (PIM) &lt;a&#xD;
    href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    It follows that we can say a model is a PIM with respect to a particular platform when it is not bound to usage of that&#xD;
    platform and could be used with any platform of that type. In a previous section, we discussed the idea of a high level&#xD;
    of abstraction and concluded that a model expressed in UML (or using a UML profile) that contains no vendor-dependent&#xD;
    elements, is not dependent on a particular infrastructure platform, and is semantically complete in structure and&#xD;
    behavior without recourse to a particular procedural language was at least notionally executable and at a high level of&#xD;
    abstraction. Is such a model platform independent? Yes and no. No, with respect to a perhaps imaginary UML Virtual&#xD;
    Machine, and yes, with respect to a whole class of platforms on which such a virtual machine would depend.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;PlatformModel&quot; href=&quot;#Top&quot; name=&quot;PlatformModel&quot;>&lt;/a>Platform Model &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot;&#xD;
    alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The platform model is that set of concepts (representing parts and services), specifications, interface definitions,&#xD;
    constraint definitions and any other requirements that an application needs to use a particular platform. In MDA, the&#xD;
    platform models are detailed and formalized in UML, for example, and available in a MOF-compliant repository. For&#xD;
    example, platform models could be built for J2EE or .NET, among others.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;PlatformSpecificModelPSM&quot; href=&quot;#Top&quot; name=&quot;PlatformSpecificModelPSM&quot;>&lt;/a>Platform Specific Model (PSM) &lt;a&#xD;
    href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A PIM is transformed into one or more PSMs by the addition of information that makes it specific to a particular&#xD;
    platform or platforms. The PIM and the PSM still specify the same system, but the PSM is constrained to particular&#xD;
    technology and may contain platform-specific elements. Note that there is no implication that a transformation step&#xD;
    (PIM to PSM, or its associated platform) is large or small. A transformation involving the application of a small set&#xD;
    of patterns refines the model and, in some sense makes it more specific; this emphasizes the relativity of the terms&#xD;
    PIM and PSM.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;ViewpointsandView&quot; href=&quot;#Top&quot; name=&quot;ViewpointsandView&quot;>&lt;/a>Viewpoints and View &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot;&#xD;
    alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    These terms are used in the same way in MDA as we described for MDD:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A viewpoint, as its name implies, is a notional position from which some aspects or concerns about the system are&#xD;
        made visible, implying the application of a set of concepts and rules to form a conceptual filter. Given that some&#xD;
        information about the system is suppressed, it is a form of abstraction. The term &lt;em>perspective&lt;/em> is used&#xD;
        similarly.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        From a viewpoint, you can see &lt;em>views&lt;/em>, which are projections of models, showing entities that are relevant&#xD;
        from that viewpoint.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    MDA specifies three viewpoints on a system: a computation independent viewpoint, a platform independent viewpoint, and&#xD;
    a platform specific viewpoint.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;ComputationIndependentViewpoint&quot; href=&quot;#Top&quot; name=&quot;ComputationIndependentViewpoint&quot;>&lt;/a>Computation Independent&#xD;
    Viewpoint &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    From the computation independent viewpoint, you are concerned about the context for the system, the requirements and&#xD;
    constraints under which it must operate, and the things in the environment with which it must interact. From this&#xD;
    viewpoint, you do not see details of system structure or behavior.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The &lt;strong>&lt;em>Computation Independent Model (CIM)&lt;/em>&lt;/strong> is a view of the system or system-to-be from the&#xD;
    computation independent viewpoint. The CIM is similar in concept to a combination of the Domain Model in RUP, which is&#xD;
    the set of artifacts, including Business Glossary and Business Analysis Model, that is output from the Task: Develop a&#xD;
    Domain Model (in Business Modeling), and the Use-Case Model, which is the computationally-independent description of&#xD;
    the behavior of the system. The CIM, which is couched in the language of the subject-matter or domain experts, is an&#xD;
    important link in the identification, during Analysis and Design, of key abstractions in the system-to-be.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;PlatformIndependentViewpoint&quot; href=&quot;#Top&quot; name=&quot;PlatformIndependentViewpoint&quot;>&lt;/a>Platform Independent Viewpoint&#xD;
    &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The platform independent viewpoint is relative to a particular platform. From that viewpoint you can see the structure&#xD;
    and behavior of a system without the details of that platform. The PIM is a view of the system from the platform&#xD;
    independent viewpoint.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;PlatformSpecificViewpoint&quot; href=&quot;#Top&quot; name=&quot;PlatformSpecificViewpoint&quot;>&lt;/a>Platform Specific Viewpoint &lt;a&#xD;
    href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    From the platform specific viewpoint, also relative to a specific platform, you can see what was visible from the&#xD;
    platform independent viewpoint but now with the platform usage details revealed. The PSM is a view of the system from a&#xD;
    platform specific viewpoint.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;AutomationofTransformation&quot; href=&quot;#Top&quot; name=&quot;AutomationofTransformation&quot;>&lt;/a>Automation of Transformation &lt;a&#xD;
    href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The idea of transformation is fundamental to MDA and model transformation is defined simply as &lt;em>&quot;the process of&#xD;
    converting one model to another model of the same system&quot;&lt;/em>. MDA also defines a little pattern to visualize the&#xD;
    conversion and to illustrate use of some of the terminology we have seen:&lt;br />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;263&quot;&#xD;
    alt=&quot;MDA pattern, showing PIM and other information as input to a transformation, and PSM and record of transformation as output.&quot;&#xD;
     src=&quot;resources/mdapattern.gif&quot; width=&quot;293&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    The MDA Pattern&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The intention of the diagram is to show that the transformation is a first-class thing: the transformation takes the&#xD;
    PIM and other information and combines them to produce the PSM.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Model transformation can, of course, be done manually. This is little different than the way software design has always&#xD;
    proceeded. Even here, MDA is useful in delineating and formalizing the idea of transformation, the process, and the&#xD;
    additional information to be used. MDA also suggests that a record of the transformation be produced; this provides&#xD;
    strong traceability from the PIM to the PSM because it should include a map from the elements of the PIM to the&#xD;
    elements of the PSM. Most leverage comes from being able to automate transformations, even if only partially, yielding&#xD;
    the same advantages that came from the replacement of assembler programming with high-level languages.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;HowisTransformationPerformed&quot; href=&quot;#Top&quot; name=&quot;HowisTransformationPerformed&quot;>&lt;/a>How is Transformation&#xD;
    Performed? &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    MDA does not prescribe a single way to do transformation: a mapping, driven by the choice of a platform, is prepared to&#xD;
    give a specification of how to transform a PIM into a PSM for that platform; this mapping results in a transformation&#xD;
    definition (perhaps expressed as a set of transformation rules), possibly with transformation parameters, written in a&#xD;
    transformation definition language. Note that the OMG issued an RFP (MOF 2.0 Query/Views/Transformations RFP) in the&#xD;
    expectation of standardizing (for the MOF) languages for creating model views, querying a model and writing&#xD;
    transformation definitions. The MDA Guide describes several approaches to transformation, including:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Metamodel Transformation - This approach assumes there is a PIM-level MOF metamodel in the language of which the&#xD;
        PIM is built. Equally, for the chosen platform, there is a PSM-level metamodel in the language of which a PSM may&#xD;
        be constructed. A mapping between the two metamodels can be used to construct a transformation definition; this is&#xD;
        then used to transform PIM into PSM.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Marking - A mapping for the chosen platform is prepared. This mapping is used to construct a transformation&#xD;
        definition, which includes a set of marks that are used to mark elements of the PIM, yielding a 'marked PIM', and a&#xD;
        definition of what to do with elements so marked. The marked PIM is then further transformed to produce the PSM.&#xD;
        The marking is typically a manual process, but the subsequent transformation may be automated.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Model Transformation - The PIM is built using platform-independent types, also specified in a model, where the&#xD;
        elements in the PIM are subtypes of the platform-independent types. A particular platform is chosen, which is&#xD;
        associated with a set of platform-specific types. A mapping is made between the two type sets, yielding a&#xD;
        transformation definition, which is applied to the PIM, producing a PSM expressed in subtypes of the&#xD;
        platform-specific types. This approach is somewhat similar to metamodel transformation except that the&#xD;
        transformation is restricted to types in a model rather than concepts from a MOF metamodel.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Pattern Application - The PIM is built using a set of types and abstract patterns that are platform independent.&#xD;
        For the chosen platform, a set of platform-specific types and patterns exists. A mapping is made between the two&#xD;
        type and pattern sets, giving a transformation definition to be applied to the PIM. This produces a PSM where the&#xD;
        abstract patterns have been made platform specific.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    For more detail, the reader is referred to the MDA Guide [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; target=&quot;_blank&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>OMG03&lt;/a>].&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;HowisTransformationApplied&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot; target=&quot;_blank&quot;&#xD;
    name=&quot;HowisTransformationApplied&quot; guid=&quot;7.755968586980351E-308&quot;>&lt;/a>How is Transformation Applied? &lt;a href=&quot;#Top&quot;>&lt;img&#xD;
    height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The simplest scenario for the application of MDA is:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Prepare a PIM&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Select a platform&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Prepare a mapping if one does not already exist&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Apply the transformation to produce a PSM&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Turn the PSM into code. If the PSM needs no further refinement and can be directly implemented, it is an&#xD;
        implementation, as defined in the next section&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    PSMs for other platforms can be generated in the same way.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Repeated Application of the MDA Pattern &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;resources/top.gif&quot;&#xD;
    width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    However, the MDA pattern is amenable to repeated application: a generated PSM at one level becomes the PIM for the&#xD;
    next, that is, for the next, increasingly specialized, platform choice. Note that in MDD, as we describe it in RUP and&#xD;
    support it with the IBM Rational toolset, our preference is to minimize the number of refinement steps, that is, to&#xD;
    proceed from a representation that is close to the customer's problem statement to an executable form as directly as&#xD;
    possible.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;517&quot; alt=&quot;Three repeated applications of the MDA pattern, for three different platforms&quot;&#xD;
    src=&quot;resources/rptmdapatt.gif&quot; width=&quot;228&quot; align=&quot;middle&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Repeated Application of the MDA Pattern&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The intention of the above diagram is to show three applications of the MDA pattern, with the initial PIM becoming a&#xD;
    PSM dependent on platform 1, then transformed again to be dependent on platform 2 as well, then transformed again to be&#xD;
    dependent on platforms 1, 2 and 3.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    General Model-to-Model Transformation &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;resources/top.gif&quot;&#xD;
    width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The same concepts can be applied to a general transformation, that is, any model to any model. If, for example, there&#xD;
    exist two metamodels whose languages are used to express the models, then, in principle, a mapping can be made,&#xD;
    yielding a transformation definition. This is applied in the way we have already seen for PIM to PSM transformation.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Implementation&quot; href=&quot;#Top&quot; name=&quot;Implementation&quot;>&lt;/a>Implementation &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot;&#xD;
    alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The MDA Guide uses &quot;implementation&quot; in a similar way to RUP's Implementation Model. It is a specification of all the &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/workproducts/rup_implementation_element_49BB163E.html&quot;&#xD;
    guid=&quot;{E1E0DDA3-914F-4CC1-9D0A-ED4B8E8BBA89}&quot;>Implementation Elements&lt;/a> needed to construct, deploy, install and&#xD;
    operate the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A PSM may itself be an implementation or may require further refinement before it can be turned into code. Note that&#xD;
    the production of an implementation PSM can skip the step of manifesting the PSM and go straight to code. In this case,&#xD;
    the more abstract PIM is able to be turned directly into code by the transformation engine. A visualization of the code&#xD;
    may still be provided to the developer to help understanding, but this can be reverse engineered from the code.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;PutativeBenefits&quot; href=&quot;./../../../core.base_rup/workproducts/rup_implementation_element_49BB163E.html&quot;&#xD;
    name=&quot;PutativeBenefits&quot; guid=&quot;{E1E0DDA3-914F-4CC1-9D0A-ED4B8E8BBA89}&quot;>&lt;/a>Putative Benefits &lt;a href=&quot;#Top&quot;>&lt;img&#xD;
    height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;PortabilityandInteroperability&quot; href=&quot;#Top&quot; name=&quot;PortabilityandInteroperability&quot;>&lt;/a>Portability and&#xD;
    Interoperability &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    MDA offers the hope of controlling the expense and perturbation of technology churn by allowing a relatively stable set&#xD;
    of PIMs to be retargeted to whatever new technology is required. The expectation is that, with increasing acceptance of&#xD;
    MDA, the developers of new technology will also deliver mappings so that transformations can be done quickly.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    By extending the PIM-PSM mappings for two platforms, MDA suggests that 'bridges' can be built between the two PSMs, and&#xD;
    ultimately between the two implementations, so that a PIM can be distributed across platforms. Most companies are faced&#xD;
    with the reality of developing for heterogeneous environments with a mix of new and old technologies, so this ability&#xD;
    to realize interoperability is potentially of great benefit.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;ReducedLifecycleCost&quot; href=&quot;#Top&quot; name=&quot;ReducedLifecycleCost&quot;>&lt;/a>Reduced Lifecycle Cost &lt;a href=&quot;#Top&quot;>&lt;img&#xD;
    height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;Productivity&quot; href=&quot;#Top&quot; name=&quot;Productivity&quot;>&lt;/a>Productivity &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot;&#xD;
    alt=&quot;To top of page&quot; src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The focus of development with MDA becomes the more abstract PIM. With a powerful toolset to generate a PSM (or code),&#xD;
    such an environment should be more productive in much the same way that working in a high-level language is more&#xD;
    productive then working in assembler, particularly given that a PIM, or something like it, is often developed anyway,&#xD;
    for example, serving as the Design Model in RUP. The productivity gain depends critically on how much manual&#xD;
    intervention is needed in the transformation process.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;Quality&quot; href=&quot;#Top&quot; name=&quot;Quality&quot;>&lt;/a>Quality &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Ideally, in MDA, the target of maintenance is the PIM. Consequently, with the proviso that the PIM is well-architected,&#xD;
    there should be fewer defects in the life of the product because there are fewer opportunities for a human to inject&#xD;
    them, and the defects that are discovered should be less costly to fix, through the benefit of automated&#xD;
    transformation. The concentration on the PIM is also more closely aligned with domain concerns, so there should be a&#xD;
    higher probability of satisfying the users' needs.&lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
