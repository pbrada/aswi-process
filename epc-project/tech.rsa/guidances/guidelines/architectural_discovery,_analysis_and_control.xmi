<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_VZHOwce0EdmYjcUf1_oIew" name="architectural_discovery,_analysis_and_control,2.843707701997842E-305" guid="_VZHOwce0EdmYjcUf1_oIew" changeDate="2006-05-05T10:37:33.698-0700" version="7.1.0">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>&lt;/a>Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In several tasks in RUP, we canvass the need to examine the emerging &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_design_model_2830034D.html&quot; guid=&quot;{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}&quot;>Design&#xD;
    Model&lt;/a>, make judgments about various quality aspects, and then, if necessary, refactor the model. It is also&#xD;
    important to be able to maintain the architectural integrity of a system once it has moved into implementation, to&#xD;
    ensure architectural and design constraints are not violated and that the system, as implemented, continues to align&#xD;
    with the architectural vision. In RUP, these major checkpoints occur in the Tasks: &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/review_the_architecture_D27975CC.html&quot; guid=&quot;{35BAFA92-EAF9-41E8-8BDE-AB9B61A68E04}&quot;>Review&#xD;
    the Architecture&lt;/a>, &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/tasks/review_the_design_gui_design_9B030120.html&quot;&#xD;
    guid=&quot;{F599C5AF-994C-42BE-AA82-B9EF7237488A}&quot;>review_the_design_gui_design&lt;/a> and &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/review_code_27AD7580.html&quot; guid=&quot;{9EC0DF69-EEE1-4B41-8F48-9FB6B0DB7F72}&quot;>Review Code&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A different, but allied, problem arises during architectural and design synthesis: in the Tasks: &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot;&#xD;
    guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot;>Architectural Analysis&lt;/a> (see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot; guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot;>Develop&#xD;
    Architecture Overview&lt;/a> and &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot; guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot;>Survey&#xD;
    Available Assets&lt;/a>) and &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/tasks/incorporate_design_elements_D3C582B5.html&quot;&#xD;
    guid=&quot;{5C647173-4E32-4594-96A9-2548B47722FA}&quot;>Incorporate Existing Design Elements&lt;/a>, the Software Architect is&#xD;
    advised to look for opportunities to reuse existing design and code assets, incorporating them into the Design Model,&#xD;
    after reverse-engineering, if necessary. Unless the reused assets come with some type of quality certification, the&#xD;
    Software Architect will want to subject them to the same scrutiny as newly created design and code.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In both cases, the consequential needs of the Software Architect are the same for this static analysis:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        To take a coded application (or fragment thereof), discover its symbolic structure, and recover this,&#xD;
        &lt;em>ideally&lt;/em> into a Design Model, in UML form. The recovery of browsable documentary artifacts also has&#xD;
        significant value in allowing the Software Architect to see how the code is really structured, when documentation&#xD;
        does not exist, or is out of date&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To be able to analyze any Design Model, collect the quality metrics (such as&amp;nbsp;&lt;a class=&quot;elementLinkWithType&quot;&#xD;
        href=&quot;./../../../core.base_rup/guidances/termdefinitions/coupling_3996FD6F.html&quot; guid=&quot;_yErvwNnmEdmO6L4XMImrsA&quot;>Term&#xD;
        Definition: coupling&lt;/a>) that are called out in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
        href=&quot;./../../../core.base_rup/workproducts/rup_measurement_plan_E4DFAC77.html&quot;&#xD;
        guid=&quot;{5932E02C-C446-4F54-83A4-307C878811E9}&quot;>Artifact: Measurement Plan&lt;/a> and check compliance with the &lt;a&#xD;
        class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
        guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Artifact: Software Architecture Document&lt;/a> and the &lt;a&#xD;
        class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot;&#xD;
        guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>Design Guidelines&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To be made aware of significant architectural or design changes so that corrective action may be taken, if&#xD;
        necessary. Significance is judged against criteria set by the Software Architect&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In theory, these needs could be fulfilled through inspection; in practice, for larger, more complex systems, some type&#xD;
    of automated assistance is essential. The following sections provide some elaboration of these topics and examples of&#xD;
    tool support.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;architecture_discovery_recovery&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot; name=&quot;architecture_discovery_recovery&quot;&#xD;
    guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>&lt;/a>Architecture Discovery and Recovery&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    Background&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In Greenfield development, software architecture emerges from the requirements and the domain context and conventions&#xD;
    (including patterns and mechanisms); the &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_supplementary_specification_F5ACAA22.html&quot;&#xD;
    guid=&quot;{B16C2941-791C-44E6-B353-354109B5C9DE}&quot;>Supplementary Specifications&lt;/a> artifact has an important role in&#xD;
    determining the architecture. This process of shaping the software architecture is sometimes called discovery, because&#xD;
    there is rarely a straightforward, mechanical mapping from requirements to architecture. Here, however, we are using&#xD;
    &lt;em>discovery&lt;/em> in a different sense, to describe the process of helping the Software Architect understand an&#xD;
    existing application or application fragment in coded form. Architectural &lt;em>recovery&lt;/em> is more ambitious: through&#xD;
    recovery, not only does the Software Architect seek to understand an application, but also to extract a model of that&#xD;
    application, ideally at a level of abstraction compatible with the Design Model. The possibility then exists of merging&#xD;
    these models and, through &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/transformation_B58336DE.html&quot; guid=&quot;_yZF5hNnmEdmO6L4XMImrsA&quot;>Term&#xD;
    Definition: transformation&lt;/a>, generating a new application, perhaps for a different &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/platform_4197EF6C.html&quot; guid=&quot;_yQJ_-dnmEdmO6L4XMImrsA&quot;>Term Definition:&#xD;
    platform&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Discovery&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In the Tasks: &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot;&#xD;
    guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot;>Architectural Analysis&lt;/a> (see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot; guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot;>Develop&#xD;
    Architecture Overview&lt;/a> and &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot; guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot;>Survey&#xD;
    Available Assets&lt;/a>) and &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/tasks/incorporate_design_elements_D3C582B5.html&quot;&#xD;
    guid=&quot;{5C647173-4E32-4594-96A9-2548B47722FA}&quot;>Incorporate Existing Design Elements&lt;/a>, the Software Architect looks&#xD;
    for opportunities to reuse existing design and code assets. For example, an organization might have several &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/workproducts/rup_reference_architecture_13D031C0.html&quot;&#xD;
    guid=&quot;{855CE09A-D297-4373-BEEA-D38B8AB348DA}&quot;>Reference Architectures&lt;/a> in its asset base, and ideally these are&#xD;
    complete with up-to-date documentation and models. However, often there is little more than source code and, if there&#xD;
    is architectural documentation, it is not current.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In many cases, the Software Architect cannot treat such code as a black box (even if the interfaces are clearly&#xD;
    defined) but needs to understand its structure. This process is greatly assisted by the ability to automatically&#xD;
    generate browsable depictions of the code. The Software Architect can then visually 'discover' patterns and&#xD;
    antipatterns in the code. An example of this kind of assistance is found in the Rational Software Architect tool, where&#xD;
    the architecture discovery capability will automatically populate topic diagrams, such as package structure, class&#xD;
    internals, inheritance trees, and collaborations, for Java applications. For more information, see &lt;img height=&quot;16&quot;&#xD;
    alt=&quot;helpbook icon&quot; src=&quot;../../../core.base_rup/resources/helpbook.gif&quot; width=&quot;16&quot; /> Rational Software Architect documentation.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Recovery and Transformation&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    When reusable assets are complete with models, it is possible to combine those models with project-specific models and&#xD;
    then proceed into platform-specific implementation using transformation techniques. When code is all that exists, it&#xD;
    might still be possible to reuse it even with a transformation-based approach by integrating the code produced from&#xD;
    transformation with the legacy code.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Software Architect has most power and flexibility through the use of architecture recovery: recovery capability&#xD;
    will generate a semantically-rich model of the application, which can be used for code generation as well as for&#xD;
    browsing. In practice, reverse-engineering code back to a straightforward visual representation is often tractable;&#xD;
    abstracting such a model back to the same level as a &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/platform_independent_model_E0546510.html&quot;&#xD;
    guid=&quot;_yQTJ4NnmEdmO6L4XMImrsA&quot;>Term Definition: platform independent model&lt;/a> Design Model is, in general, difficult&#xD;
    to automate completely.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This is essentially a &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/platform_specific_model_9E1D3B55.html&quot;&#xD;
    guid=&quot;_yQTJ5tnmEdmO6L4XMImrsA&quot;>Term Definition: platform specific model&lt;/a> to &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/platform_independent_model_E0546510.html&quot;&#xD;
    guid=&quot;_yQTJ4NnmEdmO6L4XMImrsA&quot;>Term Definition: platform independent model&lt;/a> transformation (see &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../tech.rsa/guidances/concepts/mdd_and_mda_8F9B3685.html&quot;&#xD;
    guid=&quot;4.227832989444728E-303&quot;>Concept: Model-Driven Development (MDD) and Model Driven Architecture (MDA )&lt;/a>); the&#xD;
    recovered PIM (fragment) is then combined with the Design Model (itself a PIM) using a &lt;em>model merge&lt;/em> (see [&lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>OMG03&lt;/a>]) type of transformation.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;analysis_of_architectures&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot;&#xD;
    name=&quot;analysis_of_architectures&quot; guid=&quot;7.755968586980351E-308&quot;>&lt;/a>Analysis of Architectures&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Having browsable models allows the Software Architect to verify architectural quality through inspection. However, this&#xD;
    can be tedious and time-consuming, and checking standards and rules compliance and gathering metrics this way is error&#xD;
    prone. The Software Architect should look to automate as much as possible of this process, and thereby spend more time&#xD;
    finding and applying remedies; automation allows the Software Architect to experiment, to ask &quot;what if&quot; and quickly&#xD;
    check the result.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    What Can Be Automated?&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Automated architectural analysis can:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Find patterns and antipatterns (pathological structures) in the architecture&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Perform measurements on various structures and report &lt;em>&lt;a class=&quot;elementLink&quot;&#xD;
        href=&quot;./../../../core.base_rup/guidances/guidelines/metrics_373A077A.html&quot; guid=&quot;7.859204246016091E-305&quot;>Metrics&lt;/a>&lt;/em>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Check for compliance with constraints from the Software Architect (see Architectural Control)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/termdefinitions/pattern_E76690AA.html&quot;&#xD;
    guid=&quot;_yPtUDNnmEdmO6L4XMImrsA&quot;>Term Definition: pattern&lt;/a> is dictated by&amp;nbsp;project and organization standards, and&#xD;
    the rationale for their use is captured in the Software Architecture Document (if they have architectural significance)&#xD;
    or the Design Guidelines. Through automated analysis, the Software Architect can quickly check pattern usage, to verify&#xD;
    that the intent of the Software Architecture Document and the Design Guidelines is met. Antipatterns are pathological&#xD;
    architectural and design structures that in some way weaken the architecture, by making it less robust, more complex,&#xD;
    or more difficult to maintain, for example.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The measurements to be performed are called out in the Work Product: Measurement Plan (some suggested metrics are to be&#xD;
    found in &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/guidelines/metrics_373A077A.html&quot;&#xD;
    guid=&quot;7.859204246016091E-305&quot;>Guideline: Metrics&lt;/a>). The Measurement Plan also describes how a metric is to be used,&#xD;
    for example, whether higher or lower values are better or whether it is the trend that is important, so it is useful to&#xD;
    have the metrics analysis also identify hot spots - places in the architecture where change would yield significant&#xD;
    improvement in the collected metrics. Not surprisingly, these will often be associated with pathologies in the&#xD;
    structure. The Software Architect then has an objective basis for improvement, can make changes, or delegate follow-up&#xD;
    actions that can be tested once complete.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    What Is the Target of Analysis?&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The target of analysis can vary through the lifecycle, depending on the development approach chosen. When a project&#xD;
    uses a transformational (generational) approach, the target will normally be the Design Model, on the assumption that&#xD;
    the generated application is always synchronized with the design. When an &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_implementation_model_5858DB65.html&quot;&#xD;
    guid=&quot;{157E9B67-C619-410D-A927-F2CD217BF8FE}&quot;>Artifact: Implementation Model&lt;/a> is created and separately maintained,&#xD;
    or when code is reused, focus shifts to the code, to ensure it retains architectural integrity when measured against&#xD;
    the Software Architecture Document and the Design Guidelines.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This type of analysis (on an Implementation Model) might not actually recover an explicit Design Model from the code,&#xD;
    for analysis purposes; it is, nevertheless, concerned with architecture and design issues (as they are manifest in the&#xD;
    code), not coding standards.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    An Example of these Concepts and Capabilities&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The Rational Software Architect tool, in addition to its ability to recover documentation for Java applications through&#xD;
    architecture discovery, can identify and report against a set of pre-defined patterns that could indicate potential&#xD;
    trouble spots in the architecture. These patterns include, among others:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The Butterfly&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The Breakable&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The Hub&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The Tangle&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h5>&#xD;
    The Butterfly&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A &lt;em>butterfly&lt;/em> is an element, such as a class, that has many relationships with other dependent elements, which&#xD;
    would be affected if the butterfly were changed. If the relationships are direct, these elements are called &lt;em>local&#xD;
    butterflies&lt;/em>. Rational Software Architect can also trace relationships as they cascade through an application and&#xD;
    determine if changes to an element could affect not only the direct dependents, but their dependents in turn, and so on&#xD;
    transitively through the entire application. Such an element with many indirect dependencies is called a &lt;em>global&#xD;
    butterfly&lt;/em>. An illustration of a local butterfly is shown below. The diagram also shows that the relationships can&#xD;
    be other than UML dependencies: for example, an element is dependent on another when it realizes it; a change in the&#xD;
    specifying element will affect the element that realizes it.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;331&quot;&#xD;
    alt=&quot;A class with four dependents, two with use dependencies, one with a generalization relationship, and one with a realization relationship&quot;&#xD;
     src=&quot;resources/butterfly.gif&quot; width=&quot;255&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    A Local Butterfly&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    The Breakable&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A &lt;em>breakable&lt;/em> is an element that has many dependencies; that is, it has many relationships where it depends on&#xD;
    another element. A change to any of those other elements will affect the breakable. As with butterflies, when the&#xD;
    relationships are direct these elements are called &lt;em>local breakables,&lt;/em> and &lt;em>global breakables&lt;/em> if there&#xD;
    are many indirect relationships that impact the element. A global breakable is vulnerable to changes in many parts of&#xD;
    an application and indicates a lack of modularity. An illustration of a local breakable is shown below.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;334&quot;&#xD;
    alt=&quot;A class with four dependents, two by use dependency relationships, one by a generalization relationship, and one by a realization relationship.&quot;&#xD;
     src=&quot;resources/breakable.gif&quot; width=&quot;255&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    A Local Breakable&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    The Hub&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A &lt;em>hub&lt;/em> is an element that combines the characteristics of a butterfly and a breakable. It also has&#xD;
    &lt;em>local&lt;/em> and &lt;em>global&lt;/em> forms. The presence of global hubs is an indication of poor partitioning, resulting&#xD;
    in software that is extremely sensitive to change-changes tend to ripple through the entire application.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    The Tangle&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A tangle is a large group of elements whose relationships are so convoluted that a change in any one of them could&#xD;
    affect all of the others. Such structures are a source of major instability.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Software Architect, working with the Rational Software Architect tool, can discover these hot spots quickly and&#xD;
    work with the Designer to rectify them. For more information, see &lt;img height=&quot;16&quot; alt=&quot;helpbook icon&quot;&#xD;
    src=&quot;../../../core.base_rup/resources/helpbook.gif&quot; width=&quot;16&quot; /> Rational Software Architect documentation.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Timing&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The results of these analyses are valuable at any review milestone, as objective and quantifiable evidence of&#xD;
    architectural and design quality, or when, as in &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/incorporate_design_elements_D3C582B5.html&quot;&#xD;
    guid=&quot;{5C647173-4E32-4594-96A9-2548B47722FA}&quot;>Update the Organization of the Design Model&lt;/a> (in Task: Incorporate&#xD;
    Existing Design Elements) there are significant architectural changes.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;architectural_control&quot; href=&quot;./../../../core.base_rup/tasks/incorporate_design_elements_D3C582B5.html&quot;&#xD;
    name=&quot;architectural_control&quot; guid=&quot;{5C647173-4E32-4594-96A9-2548B47722FA}&quot;>&lt;/a>Architectural Control&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The vision of the Software Architect is captured in the Software Architecture Document and practical guidance for the&#xD;
    Designer is found in the Design Guidelines. Even when that vision is shared by all staff, it is sometimes obscured by&#xD;
    the day-to-day exigencies of project work. With deadlines to meet, corners might be cut, and the Software Architect&#xD;
    usually cannot participate in every decision. So arises the issue of control: just as the Project Manager has to set&#xD;
    thresholds and limits and monitor them (see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/monitor_project_status_1A73CCB1.html&quot; guid=&quot;{A7E3EAB8-8E5A-408C-B1EF-3CD3D3B0DEDD}&quot;>Task:&#xD;
    Monitor Project Status&lt;/a>), the Software Architect has an analogous task for the emerging software design and&#xD;
    implementation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Architectural control gives the Software Architect the capability to create rules to enforce architectural constraints.&#xD;
    For example, the Software Architect might define a rule that would raise a warning on every realization of a particular&#xD;
    interface. The simple expression of this rule without tool support would require more or less constant review to catch&#xD;
    breaches. With automation, the rules can be encoded so that violations of the ruleset can be caught during architecture&#xD;
    analysis. This is still occurring after the fact, and an advanced control environment would encode the rules into the&#xD;
    design and code production process, preventing them from being broken in the first place; even so, it greatly improves&#xD;
    the manual review process.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Rational Software Architect tool includes such a capability for Java applications: the Software Architect can set&#xD;
    rules and then run analyses to verify compliance. For more information, see &lt;img height=&quot;16&quot; alt=&quot;helpbook icon&quot;&#xD;
    src=&quot;../../../core.base_rup/resources/helpbook.gif&quot; width=&quot;16&quot; /> Rational Software Architect documentation.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
