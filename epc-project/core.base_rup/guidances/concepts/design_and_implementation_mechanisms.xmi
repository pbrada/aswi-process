<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_13RQlNnmEdmO6L4XMImrsA" name="design_and_implementation_mechanisms,6.131233324119695E-305" guid="_13RQlNnmEdmO6L4XMImrsA" changeDate="2005-11-15T22:06:14.214-0800" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction to Design and Implementation Mechanisms&quot;&#xD;
    name=&quot;Introduction to Design and Implementation Mechanisms&quot;>Introduction to Design and Implementation Mechanisms&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/guidances/termdefinitions/design_mechanism_5F46BEF2.html&quot;&#xD;
    guid=&quot;_yF4Ck9nmEdmO6L4XMImrsA&quot;>design mechanism&lt;/a> is a refinement of a corresponding &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/analysis_mechanism_4DAA970A.html&quot;&#xD;
    guid=&quot;_x6stV9nmEdmO6L4XMImrsA&quot;>analysis mechanism&lt;/a> (see also &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/analysis_mechanisms_36135B43.html&quot; guid=&quot;9.76539014099254E-305&quot;>Concept:&#xD;
    Analysis Mechanisms&lt;/a>). A design mechanism adds concrete detail to the conceptual analysis mechanism, but stops short&#xD;
    of requiring particular technology - for example, a particular vendor's implementation of, say, an object-oriented&#xD;
    database management system. As with analysis mechanisms, a design mechanism may instantiate one or more patterns, in&#xD;
    this case &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/architectural_pattern_E2E8EB79.html&quot;&#xD;
    guid=&quot;_x7JZRtnmEdmO6L4XMImrsA&quot;>&lt;b>architectural&lt;/b>&lt;/a>&amp;nbsp;or &lt;b>&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/design_pattern_4AEB9B64.html&quot; guid=&quot;_yF4CnNnmEdmO6L4XMImrsA&quot;>design&#xD;
    patterns&lt;/a>&lt;/b>&lt;i>.&lt;/i>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Similarly, an &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/implementation_mechanism_59389269.html&quot;&#xD;
    guid=&quot;_yKfc2dnmEdmO6L4XMImrsA&quot;>implementation mechanism&lt;/a> is a refinement of a corresponding design mechanism, using,&#xD;
    for example, a particular programming language and other implementation technology (such as a particular vendor's&#xD;
    middleware product). An implementation mechanism may instantiate one or more &lt;b>&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/idiom_6D91029A.html&quot; guid=&quot;_yKVr0tnmEdmO6L4XMImrsA&quot;>idioms&lt;/a>&lt;/b> or&#xD;
    implementation patterns.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_design_mechanism__characteristics_of&quot; name=&quot;XE_design_mechanism__characteristics_of&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Example: Characteristics of Design Mechanisms&quot; name=&quot;Example: Characteristics of Design Mechanisms&quot;>Example:&#xD;
    Characteristics of Design Mechanisms&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Consider the analysis mechanism for &lt;b>Persistency&lt;/b>:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        There might be a need for many (2,000) small objects (200 bytes each) to be stored for a few seconds, with no need&#xD;
        for survival.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        There might be a need for several very large objects to be stored permanently on disk for several months, never&#xD;
        updated, but with sophisticated means of retrieval.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    &lt;a id=&quot;inventory&quot; name=&quot;inventory&quot;>&lt;/a>These objects will require different support for persistency; the following&#xD;
    characteristics of design mechanisms for persistency support might be identified:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>In-memory storage&lt;/b>; characteristics: for up to 1 Mb total (size x volume); very fast access for read, write,&#xD;
        update.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Flash card&lt;/b>; characteristics: for up to 8 Mb; slow update and write access; moderate read access.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Binary file&lt;/b>; characteristics: for 100 Kb to 200 Mb; slow update; slow read and write access.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Database Management System (DBMS)&lt;/b>; characteristics: for 100 Kb and upwards (with essentially no upper&#xD;
        limit); even slower update, read and write access.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Note that these speeds are only rated 'slow' relative to in-memory storage.&amp;nbsp; Obviously, in some environments, the&#xD;
    use of caching can improve apparent access times.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;a id=&quot;mapping&quot; name=&quot;mapping&quot;>&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p align=&quot;center&quot;>&#xD;
        &lt;img height=&quot;221&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/co_dmec1.gif&quot; width=&quot;372&quot; />&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&lt;br />&#xD;
&lt;br />&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_implementation_mechanism__mapping_from_design_mechanisms_refining&quot;&#xD;
    name=&quot;XE_implementation_mechanism__mapping_from_design_mechanisms_refining&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_design_mechanism__mapping_to_implementation_mechanisms_refining&quot;&#xD;
    name=&quot;XE_design_mechanism__mapping_to_implementation_mechanisms_refining&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Refining the Mapping between Design and Implementation Mechanisms&quot;&#xD;
    name=&quot;Refining the Mapping between Design and Implementation Mechanisms&quot;>Refining the Mapping between Design and&#xD;
    Implementation Mechanisms&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Initially, the mapping between design mechanisms and implementation mechanisms is likely to be less than optimal but it&#xD;
    will get the project running, identify yet-unseen risks, and trigger further investigations and evaluations. As the&#xD;
    project continues and gains more knowledge, the mapping needs to be refined.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Proceed iteratively to refine the mapping between design and implementation mechanisms, eliminating redundant paths,&#xD;
    working both &quot;top-down&quot; and &quot;bottom-up.&quot;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Working Top-Down.&lt;/b> When working &quot;top-down,&quot; new and refined use-case realizations will put new requirements on&#xD;
    the needed design mechanisms via the analysis mechanisms needed. Such new requirements might uncover additional&#xD;
    characteristics of a design mechanism, forcing a split between mechanisms. There is also a compromise between the&#xD;
    system's complexity and its performance:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Too many different design mechanisms make the system too complex.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Too few design mechanisms can create performance issues for some implementation mechanisms that stretch the limits&#xD;
        of the reasonable ranges of their characteristics values.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    &lt;b>Working Bottom-Up.&lt;/b> When working &quot;bottom-up,&quot; investigating the available implementation mechanisms, you might&#xD;
    find products that satisfy several design mechanisms at once, but force some adaptation or repartitioning of your&#xD;
    design mechanisms. You want to minimize the number of implementation mechanisms you use, but too few of them can also&#xD;
    lead to performance issues.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Once you decide to use a DBMS to store objects of class A, you might be tempted to use it to store all objects in the&#xD;
    system. This could prove very inefficient, or very cumbersome. Not all objects which require persistency need to be&#xD;
    stored in the DBMS. Some objects may be persistent but may be frequently accessed by the application, and only&#xD;
    infrequently accessed by other applications. A hybrid strategy in which the object is read from the DBMS into memory&#xD;
    and periodically synchronized may be the best approach.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    &lt;b>Example&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    A flight can be stored in memory for fast access, and in a DBMS for long term persistency; this however triggers a need&#xD;
    for a mechanism to synchronize both.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It is not uncommon to have more than one design mechanisms associated with a client class as a compromise between&#xD;
    different characteristics.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Because implementation mechanisms often come in bundles in off-the-shelf components (operating systems and middleware&#xD;
    products) some optimization based on cost, or impedance mismatch, or uniformity of style needs to occur. Also,&#xD;
    mechanisms often are inter-dependent, making clear separation of services into design mechanisms difficult.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    &lt;b>Examples&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            &lt;p class=&quot;example&quot;>&#xD;
                The notification mechanism can be based on the inter-process communication mechanism.&#xD;
            &lt;/p>&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;p class=&quot;example&quot;>&#xD;
                The error reporting mechanism can be based on the persistency mechanism.&#xD;
            &lt;/p>&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Refinement continues over the whole elaboration phase, and is always a compromise between:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        An exact 'fit' with the requirements of the clients of the design mechanism, in terms of the expected&#xD;
        characteristics.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The cost and complexity of having too many different implementation mechanisms to acquire and integrate.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The overall goal is always to have a simple clean set of mechanisms that give conceptual integrity, simplicity and&#xD;
    elegance to a large system.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_implementation_mechanism__mapping_from_design_mechanisms_examples&quot;&#xD;
    name=&quot;XE_implementation_mechanism__mapping_from_design_mechanisms_examples&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_design_mechanism__mapping_to_implementation_mechanisms_examples&quot;&#xD;
    name=&quot;XE_design_mechanism__mapping_to_implementation_mechanisms_examples&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Example: Mapping Design Mechanisms to Implementation Mechanisms&quot;&#xD;
    name=&quot;Example: Mapping Design Mechanisms to Implementation Mechanisms&quot;>Example: Mapping Design Mechanisms to&#xD;
    Implementation Mechanisms&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The &lt;b>Persistence&lt;/b> design mechanisms can be mapped to implementation mechanisms as follows:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;216&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/co_dmec2.gif&quot; width=&quot;325&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A possible mapping between analysis mechanisms and design mechanisms. Dotted arrows mean &quot;is specialized by,&quot; implying&#xD;
    that the characteristics of the design mechanisms are inherited from the analysis mechanisms but that they will be&#xD;
    specialized and refined.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Once you have finished optimizing the mechanisms, the following mappings exist:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p align=&quot;center&quot;>&#xD;
        &lt;img height=&quot;110&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/co_dmec3.gif&quot; width=&quot;418&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;picturetext&quot;>&#xD;
        The design decisions for a client class in terms of mappings between mechanisms; the Flight class needs two forms&#xD;
        of persistency: in-memory storage implemented by a ready-made library routine, and in a database implemented with&#xD;
        an off-the-shelf ObjectStorage product.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    The map must be navigable in both directions, so that it is easy to determine client classes when changing&#xD;
    implementation mechanisms.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_design_mechanism__describing&quot; name=&quot;XE_design_mechanism__describing&quot;>&lt;/a>&lt;a id=&quot;Describing Design Mechanisms&quot;&#xD;
    name=&quot;Describing Design Mechanisms&quot;>Describing Design Mechanisms&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Design mechanisms, and details regarding their use, are documented in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot;&#xD;
    guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>Artifact: Project-Specific Guidelines&lt;/a>. The relationship (or mapping)&#xD;
    of analysis mechanisms to design mechanisms to implementation mechanisms, and the associated rationale for these&#xD;
    choices, is documented in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
    guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Artifact: Software Architecture Document&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As with analysis mechanisms, design mechanisms can be modeled using a collaboration, which may instantiate one or more&#xD;
    &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/guidances/termdefinitions/architectural_pattern_E2E8EB79.html&quot;&#xD;
    guid=&quot;_x7JZRtnmEdmO6L4XMImrsA&quot;>&lt;b>architectural&lt;/b>&lt;/a> or &lt;b>&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/design_pattern_4AEB9B64.html&quot; guid=&quot;_yF4CnNnmEdmO6L4XMImrsA&quot;>design&#xD;
    patterns&lt;/a>.&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Example: A Persistency Mechanism&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    This example uses an instance of a pattern for RDBMS-based persistency drawn from &lt;a&#xD;
    href=&quot;http://java.sun.com/products/jdbc/index.html&quot; target=&quot;_blank&quot;>JDBC&amp;trade; (Java Data Base Connectivity)&lt;/a>.&amp;nbsp;&#xD;
    Although we present the design here, JDBC does supply actual code for some of the classes, so it is a short step from&#xD;
    what is presented here to an implementation mechanism.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The figure Static View: JDBC shows the classes (strictly, the classifier roles) in the collaboration.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;382&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/jdbc1.gif&quot; width=&quot;571&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;b>Static View: JDBC&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    The yellow-filled classes are the ones which were supplied, the others (myDBClass etc.) were bound by the designer to&#xD;
    create the mechanism.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    In JDBC, a client will work with a &lt;b>DBClass&lt;/b> to read and write persistent data. The DBClass is responsible for&#xD;
    accessing the JDBC database using the &lt;b>DriverManager&lt;/b> class. Once a database &lt;b>Connection&lt;/b> is opened, the&#xD;
    DBClass can then create SQL statements that will be sent to the underlying RDBMS and executed using the&#xD;
    &lt;b>Statement&lt;/b> class. The Statement class is what &quot;talks&quot; to the database. The result of the SQL query is returned in&#xD;
    a &lt;b>ResultSet&lt;/b> object.&lt;span style=&quot;mso-spacerun: yes&quot;>&amp;nbsp;&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    The &lt;b>DBClass&lt;/b> class is responsible for making another class instance persistent. It understands the OO-to-RDBMS&#xD;
    mapping and has the behavior to interface with the RDBMS. The DBClass flattens the object, writes it to the RDBMS and&#xD;
    reads the object data&lt;span style=&quot;mso-spacerun: yes&quot;>&amp;nbsp;&lt;/span> from the RDBMS and builds the object. Every class&#xD;
    that is persistent will have a corresponding DBClass.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    The &lt;b>PersistentClassList&lt;/b> is used to return a set of persistent objects as a result of a database query (e.g.,&#xD;
    DBClass.read()).&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    We now present a series of dynamic views, to show how the mechanism actually works.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;146&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/jdbc2.gif&quot; width=&quot;285&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;b>JDBC: Initialize&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Initialization must occur before any persistent class can be accessed.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To initialize the connection to the database, the DBClass must load the appropriate driver by calling the DriverManager&#xD;
    getConnection() operation with a URL, user, and password.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The operation getConnection() attempts to establish a connection to the given database URL. The DriverManager attempts&#xD;
    to select an appropriate driver from the set of registered JDBC drivers.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;i>Parameters:&lt;/i>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>url&lt;/b>: A database url of the form jdbc:subprotocol:subname. This URL is used to locate the actual database server&#xD;
    and is not Web-related in this instance.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>user&lt;/b>: The database user on whose behalf the Connection is being made&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>pass&lt;/b>: The user's password&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;i>Returns&lt;/i>:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    a Connection to the URL.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;253&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/jdbc3.gif&quot; width=&quot;478&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;b>JDBC: Create&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    To create a new class, the persistency client asks the DBClass to create the new class. The DBClass creates a new&#xD;
    instance of PersistentClass with default values. The DBClass then creates a new Statement using the Connection class&#xD;
    createStatement() operation. The Statement is executed and the data is inserted into the database.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;352&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/jdbc4.gif&quot; width=&quot;627&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;b>JDBC: Read&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To read a persistent class, the persistency client asks the DBClass to read. The DBClass creates a new Statement using&#xD;
    the Connection class createStatement() operation. The Statement is executed and the data is returned in a ResultSet&#xD;
    object. The DBClass then creates a new instance of the PersistentClass and populates it with the retrieved data. The&#xD;
    data is returned in a collection object, an instance of the PersistentClassList class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note: The string passed to executeQuery() is not necessarily exactly the same string as the one passed into the read().&#xD;
    The DBClass will build the SQL query to retrieve the persistent data from the database, using the criteria passed into&#xD;
    the read(). This is because we do not want the client of the DBClass to need the knowledge of the internals of the&#xD;
    database to create a valid query. This knowledge is encapsulated within DBClass.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;255&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/jdbc5.gif&quot; width=&quot;473&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;b>JDBC: Update&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To update a class, the persistency client asks the DBClass to update. The DBClass retrieves the data from the given&#xD;
    PersistentClass object, and creates a new Statement using the Connection class createStatement() operation. Once the&#xD;
    Statement is built the update is executed and the database is updated with the new data from the class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Remember: It is the job of the DBClass to &quot;flatten&quot; the PersistentClass and write it to the database. That is why is&#xD;
    must be retrieved from the given PersistentClass before creating the SQL Statement.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note: In the above mechanism, the PersistentClass must provide access routines for all persistent data so that DBClass&#xD;
    can access them. This provides external access to certain persistent attributes that would have otherwise have been&#xD;
    private. This is a price you have to pay to pull the persistence knowledge out of the class that encapsulates the data.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;255&quot; alt=&quot;Diagram is detailed in the content.&quot; src=&quot;resources/jdbc6.gif&quot; width=&quot;473&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;b>JDBC: Delete&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    To delete a class, the persistency client asks the DBClass to delete the PersistentClass. The DBClass creates a new&#xD;
    Statement using the Connection class createStatement() operation. The Statement is executed and the data is removed&#xD;
    from the database.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    In the implementation of this design, some decisions would be made about the mapping of DBClass to the persistent&#xD;
    classes, e.g. having one DBClass per persistent class and allocating them to appropriate packages.&amp;nbsp; These packages&#xD;
    will have a dependency on the supplied &lt;i>java.sql&lt;/i> (see &lt;a href=&quot;http://java.sun.com/products/jdbc/index.jsp&quot;&#xD;
    target=&quot;_blank&quot;>JDBC&lt;font size=&quot;-2&quot;>&lt;sup>&amp;trade;&lt;/sup>&lt;/font> API Documentation&lt;/a>) package which contains the supporting&#xD;
    classes DriverManager, Connection, Statement and ResultSet.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
