<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_ktMewOM9EdmaZcY4PeqVxA" name="derived_requirements,_khKN4OM9EdmaZcY4PeqVxA" guid="_ktMewOM9EdmaZcY4PeqVxA" changeDate="2005-08-23T19:34:00.143-0700" version="7.1.0">
  <mainDescription>&lt;h3>&#xD;
    Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    There is inevitably a hierarchy of requirements associated with system development, from the least detailed, which&#xD;
    define the mission of the system or the summary user goals or objectives for the system, down to the most detailed,&#xD;
    perhaps through several intermediate levels. At the most detailed level, the requirements can be expressed very much in&#xD;
    the vocabulary of the technology used by the system; whereas at the highest level, they are typically expressed more&#xD;
    abstractly in the language of the domain to be served by the system, as capabilities, services, behaviors, functions,&#xD;
    features, and so on, the choice of word often being arbitrary. It is certainly possible to ascribe different meanings&#xD;
    to these words to be more precise about what is being expressed (for example, it is possible that the description of a&#xD;
    particular behavior of a system does not reveal much about the goal or intention, and some other descriptive type is&#xD;
    needed), but that is not the purpose here.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The refinement of requirements (from the highest level, adding more detail) &lt;i>can&lt;/i> proceed in a purely functional&#xD;
    way, that is by splitting functions into subfunctions or subtasks that support them - without regard to any realizing&#xD;
    architecture - and can be taken to a level where what is described would (were the system constructed this way) take&#xD;
    place deep within the system, and perhaps have no &lt;i>direct&lt;/i> communication outside the system. This would be the&#xD;
    case, for example, in a structured analysis approach that went as deep as a primitive transform bubble.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This approach is ill-advised, first, because it leads to the identification of things as requirements that are not&#xD;
    requirements at all, but simply work products of the decomposition; second, it can lead to poor architectures (for&#xD;
    example, that fail to meet, or perform poorly against, other non-functional requirements), if the designer maps the&#xD;
    realization very closely to the decomposition. However, there is a valid reason to do &lt;i>some&lt;/i> functional&#xD;
    decomposition when the vision goals are expressed at a high level, while limiting the depth of decomposition to&#xD;
    discernible capability or functions, that is, with enough detail to capture all significant (to the stakeholders)&#xD;
    behaviors, features, and so forth, so the designer can realize them correctly. Requirements refined (more or less&#xD;
    directly) from higher-level requirements are one kind of derived requirement.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Derived requirements&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Here is a straightforward&amp;nbsp;example:&#xD;
&lt;/p>&#xD;
&lt;blockquote dir=&quot;ltr&quot; style=&quot;MARGIN-RIGHT: 0px&quot;>&#xD;
    &lt;p>&#xD;
        Suppose a user requirement is &quot;the system must work outdoors, 12 months a year in Alaska.&quot;&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Several derived requirements are:&#xD;
    &lt;/p>&#xD;
    &lt;ol>&#xD;
        &lt;li>&#xD;
            The system must work in temperatures below 32 F / 0 C.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            The system must work in the snow.&#xD;
        &lt;/li>&#xD;
    &lt;/ol>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    There is another type of derived requirement. When the &lt;i>system-level&lt;/i> requirements have been expressed with&#xD;
    appropriate detail for realization, then you:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Partition the system (model) into elements (for example, using OOAD methods).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Determine how these elements collaborate to yield the desired system behavior.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Aggregate the lower-level behaviors from the collaboration to yield the &lt;i>element-level&lt;/i> requirements.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Such lower-level requirements are derived requirements; they have emerged in concert with the decomposition of the&#xD;
    system. This contrasts with a functionally based approach, where the partitioning occurs without regard to any&#xD;
    architectural decomposition, and refinement of the system-level requirements as described in the introduction.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Allocated requirements&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Allocated requirements are requirements that have been &lt;i>assigned&lt;/i> (based on functional considerations) to&#xD;
    components of a system, such as hardware or software subsystems. At the very highest level, when, for example,&#xD;
    reasoning about mission-level requirements for a system-of-systems, it might still be appropriate to elaborate such&#xD;
    requirements functionally, then partition the resulting derived requirements and allocate the groups to &lt;i>systems&#xD;
    -&lt;/i> perhaps refining further before realization. Beyond that point, the preference here is to proceed as in Derived&#xD;
    Requirements. Even at the system-of-systems level, you can consider proceeding this way, using a Business Modeling&#xD;
    approach.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that in a derived approach, one decomposes the system into entities and determines the entities' requirements by&#xD;
    studying how they collaborate to meet the higher-level requirements. In a functional, allocated approach, one&#xD;
    decomposes the requirements and specifies entities that satisfy the lower-level requirements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The approach to use depends on the context and cultural and contractual expectations. For example, the National&#xD;
    Aeronautics and Space Agency (NASA) [in the &lt;i>Software Assurance Guidebook&lt;/i>, NASA Goddard Space Flight Center&#xD;
    Office of Safety, Reliability, Maintainability and Quality Assurance, 9/89] defines requirements to exist at four&#xD;
    levels of detail:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Level 1, the mission level - these are very high-level, and stabilize very early.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Level 2, the system level (allocated) - also very stabilize very early at this level. These requirements are&#xD;
        derived from the mission level and then allocated to segments.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Level 3, subsystem (or segment) level (derived) - the requirements at this level are derived from the system-level&#xD;
        requirements allocated to the segment.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Level 4, configuration item (hardware configuration item [HWCI], software configuration item [CSCI]) level&#xD;
        (detailed) - again, allocated from the previous level and then refined.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;597&quot; src=&quot;resources/rqtlevel.gif&quot; alt=&quot;Requirements Levels and Mapping to RUP&quot; width=&quot;665&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Requirements Levels and Mapping to RUP.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Typically, contracts are bid at Level 3. NASA is accustomed to dealing with requirements in this way, and it would be&#xD;
    natural for any organization dealing with NASA to adopt a similar taxonomy. There would still be considerable&#xD;
    flexibility available to developers in how lower-level requirements are derived, but given the &lt;i>very&lt;/i> high level&#xD;
    of abstraction of mission-level requirements (these are often more like program-level requirements), the derivation of&#xD;
    system-level requirements (and allocation to segments) can occur naturally along functional lines. Even so, with the&#xD;
    interest in enterprise architectures, it is increasingly common for even system requirements to be derived using&#xD;
    architectural considerations. The figure above illustrates this and shows the mapping of the NASA levels to RUP work&#xD;
    products (including business modeling). Note how, in the RUP process, the allocation shown on the traditional flow is&#xD;
    performed in the Use-Case Realization process and subsequent behavioral aggregation. The blue dashed lines link work&#xD;
    products at a similar level.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
