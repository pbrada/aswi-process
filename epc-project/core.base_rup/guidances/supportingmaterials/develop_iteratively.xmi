<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_zZ6dUtnmEdmO6L4XMImrsA" name="develop_iteratively,3.078174280115047E-305" guid="_zZ6dUtnmEdmO6L4XMImrsA" changeDate="2005-10-11T14:18:16.668-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;What is Iterative Development&quot; name=&quot;What is Iterative Development&quot;>What is Iterative Development&lt;/a>?&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    A project using iterative development has a lifecycle consisting of several iterations. An iteration incorporates a&#xD;
    loosely sequential set of tasks in business modeling, requirements, analysis and design, implementation, test, and&#xD;
    deployment, in various proportions depending on where in the development cycle the iteration is located. Iterations in&#xD;
    the inception and elaboration phases focus on management, requirements, and design activities; iterations in the&#xD;
    construction phase focus on design, implementation, and test; and iterations in the transition phase focus on test and&#xD;
    deployment. Iterations should be managed in a &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/timeboxing_109B588A.html&quot;&#xD;
    guid=&quot;_yYy-k9nmEdmO6L4XMImrsA&quot;>&lt;i>timeboxed&lt;/i>&lt;/a> fashion, that is, the schedule for an iteration should be regarded&#xD;
    as fixed, and the scope of the iteration's content actively managed to meet that schedule.&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;Why Develop Iteratively&quot; name=&quot;Why Develop Iteratively&quot;>Why Develop Iteratively&lt;/a>?&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    An initial design is likely to be flawed with respect to its key requirements. Late discovery of design defects results&#xD;
    in costly over-runs and, in some cases, even project cancellation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    All projects have a set of risks involved. The earlier in the lifecycle you can verify that you've avoided a risk, the&#xD;
    more accurate you can make your plans. Many risks are not even discovered until you've attempted to integrate the&#xD;
    system. You will never be able to predict all risks regardless of how experienced the development team is.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;279&quot; alt=&quot;Risk and Time chart of the development process by waterfall method&quot; src=&quot;resources/risk_wf.gif&quot;&#xD;
    width=&quot;519&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;left&quot;>&#xD;
    In a waterfall lifecycle, you can't verify whether you have stayed clear of a risk until late in the lifecycle.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;232&quot;&#xD;
    alt=&quot;Risk and Time chart of the development process by waterfall method shown with the iterative method&quot;&#xD;
    src=&quot;resources/risk_it.gif&quot; width=&quot;464&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;left&quot;>&#xD;
    In an iterative lifecycle, you select what increment to develop in an iteration based on a list of key risks. Since the&#xD;
    iteration produces a tested executable, you can verify whether you have mitigated the targeted risks or not.&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;Benefits of an iterative approach&quot; name=&quot;Benefits of an iterative approach&quot;>Benefits of an Iterative&#xD;
    Approach&lt;/a>&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    An iterative approach is generally superior to a linear or waterfall approach for many different reasons.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Risks are mitigated earlier, because elements are integrated progressively.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Changing requirements and tactics are accommodated.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Improving and refining the product is facilitated, resulting in a more robust product.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Organizations can learn from this approach and improve their process.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Reusability is increased.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A customer once said: &quot;With the waterfall approach, everything looks fine until near the end of the project, sometimes&#xD;
    up until the middle of integration. Then everything falls apart. With the iterative approach, it is very difficult to&#xD;
    hide the truth for very long.&quot;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Project managers often resist the iterative approach, seeing it as endless hacking. In the Rational Unified Process,&#xD;
    the interactive approach is very controlled; iterations are planned in number, duration, and objective. The tasks and&#xD;
    responsibilities of the participants are defined. Objective measures of progress are captured. Some rework does take&#xD;
    place from one iteration to the next, but this, too, is carefully controlled.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Mitigating risks&quot; name=&quot;Mitigating risks&quot;>Mitigating risks&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    An iterative approach lets you mitigate risks earlier, because many risks are only addressed and discovered during&#xD;
    integration. As you unroll the early iteration, you go through all&amp;nbsp; disciplines, exercising many aspects of the&#xD;
    project: tools, off-the-shelf software, people skills, and so on. Perceived risks may prove not to be risks, and new,&#xD;
    unsuspected risks will show up.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Integration is not one &quot;big bang&quot; at the end-elements are incorporated progressively. In reality, the iterative&#xD;
    approach is an almost continuous integration. What used to be a long, uncertain, and difficult time-taking up to 40% of&#xD;
    the total effort at the end of a project-and what was hard to plan accurately, is divided into six to nine smaller&#xD;
    integrations that start with far fewer elements to integrate.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Accomodating changes&quot; name=&quot;Accomodating changes&quot;>Accommodating changes&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The iterative approach lets you take into account changing requirements as they &lt;b>will&lt;/b> normally change along the&#xD;
    way.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Changes in requirements and requirements &quot;creep&quot; have always been&amp;nbsp; primary sources of trouble for a project,&#xD;
    leading to late delivery, missed schedules, unsatisfied customers, and frustrated developers. Twenty-five years ago,&#xD;
    Fred Brooks wrote: &quot;Plan to throw one away, you will anyhow.&quot; Users will change their mind along the way. This is human&#xD;
    nature. Forcing users to accept the system as they originally imagined it is wrong. They change their minds because the&#xD;
    context is changing-they learn more about the environment and the technology, and they see intermediate demonstration&#xD;
    of the product as it's being developed.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An iterative lifecycle provides management with a way of making tactical changes to the product. For example, to&#xD;
    compete with existing products, you may decide to release a reduced-functionality product earlier to counter a move by&#xD;
    a competitor, or you may adopt another vendor for a given technology.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Iteration also allows for technological changes along the way. If some technology changes or becomes a standard as new&#xD;
    technology appears, the project can take advantage of it. This is particularly the case for platform changes and&#xD;
    lower-level infrastructure changes.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Higher quality&quot; name=&quot;Higher quality&quot;>Reaching higher quality&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    An iterative approach results in a more robust architecture because errors are corrected over several iterations. Early&#xD;
    flaws are detected as the product matures during the early iterations. Performance bottlenecks are discovered and can&#xD;
    be reduced, as opposed to being discovered on the eve of delivery.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Developing iteratively, as opposed to running tests once toward the end of the project, results in a more thoroughly&#xD;
    tested product. Critical functions have had many opportunities to be tested over several iterations, and the tests&#xD;
    themselves, and any test software, have had time to mature.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Learning&quot; name=&quot;Learning&quot;>Learning and improving&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Developers can learn along the way, and the various competencies and specialties are more fully employed during the&#xD;
    whole lifecycle.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Rather than waiting a long time just making plans and honing their skills, testers start testing early, technical&#xD;
    writing starts early, and so on. The need for additional training or external help can be detected in the early&#xD;
    iteration assessment reviews.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The process itself can be improved and refined as it develops. The assessment at the end of an iteration not only looks&#xD;
    at the status of the project from a product-schedule perspective, but also analyzes what needs to be changed in the&#xD;
    organization and the process to perform better in the next iteration.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Increasing reuse&quot; name=&quot;Increasing reuse&quot;>Increasing reuse&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    An iterative lifecycle facilitates reuse. It's easier to identify common parts as they are partially designed or&#xD;
    implemented, compared to having to identify all commonality up front.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Identifying and developing reusable parts is difficult. Design reviews in early iterations allow software architects to&#xD;
    identify unsuspected, potential reuse, and subsequent iterations allow them to further develop and mature this common&#xD;
    code.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Using an iterative approach makes it easier to take advantage of commercial-off-the-shelf products. You have several&#xD;
    iterations to select them, integrate them, and validate that they fit with the architecture.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
