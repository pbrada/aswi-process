<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_16jOENnmEdmO6L4XMImrsA" name="design_subsystem,1.2314266786534317E-305" guid="_16jOENnmEdmO6L4XMImrsA" changeDate="2005-06-21T10:27:27.776-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_layering__layering_guidelines_for_design_subsystems&quot;&#xD;
name=&quot;XE_layering__layering_guidelines_for_design_subsystems&quot;>&lt;/a>&lt;a id=&quot;XE_design_subsystem__guidelines_for&quot;&#xD;
name=&quot;XE_design_subsystem__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_design_subsystem__partitioning_patterns&quot; name=&quot;XE_design_subsystem__partitioning_patterns&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Subsystem Usage&quot; name=&quot;Subsystem Usage&quot;>Subsystem Usage&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    &lt;a id=&quot;XE_layering__partitioning_patterns&quot; name=&quot;XE_layering__partitioning_patterns&quot;>&lt;/a>Subsystems can be used in a&#xD;
    number of complementary ways, to partition the system into units which&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        can be independently ordered, configured, or delivered&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can be independently developed, as long as the interfaces remain unchanged&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can be independently deployed across a set of distributed computational nodes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can be independently changed without breaking other parts of the systems&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Thus, subsystems are ideal for modeling components - the replaceable units of assembly in component-based development -&#xD;
    that are larger than a single design class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In addition, subsystems can&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        partition the system into units which can provide restricted security over key resources&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        represent existing products or external systems in the design.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_design_subsystem__identifying_subsystems&quot; name=&quot;XE_design_subsystem__identifying_subsystems&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Identifying Subsystems&quot; name=&quot;Identifying Subsystems&quot;>Identifying Subsystems&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A complex analysis class is mapped to a design subsystem if it appears to embody behavior that cannot be the&#xD;
    responsibility of a single design class acting alone. A complex design class may also become a subsystem, if it is&#xD;
    likely to be implemented as a set of collaborating classes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Subsystems are also a good means of identifying parts of the system that are to be developed independently by a&#xD;
    separate team. If the collaborating design elements can be completely contained within a package along with their&#xD;
    collaborations, a subsystem can provide a stronger form of encapsulation than that provided by a simple package. The&#xD;
    contents and collaborations within a subsystem are completely isolated behind one or more interfaces, so that the&#xD;
    client of the subsystem is only dependent upon the interface. The designer of the subsystem is then completely isolated&#xD;
    from external dependencies; the designer (or design team) is required to specify how the interface is realized, but&#xD;
    they are completely free to change the internal subsystem design without affecting external dependencies. In large&#xD;
    systems with largely independent teams, this degree of de-coupling combined with the architectural enforcement provided&#xD;
    by formal interfaces is a strong argument for the choice of subsystems over simple packages.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The design subsystem is used to encapsulate these collaborations in such a way that clients of the subsystem can be&#xD;
    completely unaware of the internal design of the subsystem, even as they use the services provided by the subsystem. If&#xD;
    the participating classes/subsystems in a collaboration interact only with each other to produce a well-defined set of&#xD;
    results, the collaboration and its collaborating design elements should be encapsulated within a subsystem.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This rule can be applied to subsets of collaborations as well. Anywhere part or all of a collaboration can be&#xD;
    encapsulated and simplified, doing so will make the design easier to understand.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Hints&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;center&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;85%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;th id=&quot;row0&quot; scope=&quot;col&quot; width=&quot;35%&quot;>&#xD;
                    &lt;blockquote>&#xD;
                        &lt;p class=&quot;tableheading&quot; align=&quot;center&quot;>&#xD;
                            Hint&#xD;
                        &lt;/p>&#xD;
                    &lt;/blockquote>&#xD;
                &lt;/th>&#xD;
                &lt;td scope=&quot;col&quot; headers=&quot;row0&quot; width=&quot;65%&quot;>&#xD;
                    &lt;p class=&quot;tableheading&quot; align=&quot;center&quot;>&#xD;
                        Details&#xD;
                    &lt;/p>&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th id=&quot;row1&quot; width=&quot;35%&quot;>&#xD;
                    Look for optionality&#xD;
                &lt;/th>&#xD;
                &lt;td headers=&quot;row1&quot; width=&quot;60%&quot;>&#xD;
                    If a particular collaboration (or sub-collaboration) represents optional behavior, enclose it in a&#xD;
                    subsystem. Features which may be removed, upgraded, or replaced with alternatives should be considered&#xD;
                    independent.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th id=&quot;row2&quot; width=&quot;35%&quot; rowspan=&quot;2&quot;>&#xD;
                    Look to the user interface of the system.&#xD;
                &lt;/th>&#xD;
                &lt;td headers=&quot;row2&quot; width=&quot;60%&quot;>&#xD;
                    If the user interface is relatively independent of the entity classes in the system (i.e. the two can&#xD;
                    and will change independently), create subsystems which are horizontally integrated: group related user&#xD;
                    interface boundary classes together in a subsystem, and group related entity classes together in&#xD;
                    another subsystem.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td headers=&quot;row2&quot; width=&quot;65%&quot;>&#xD;
                    If the user interface and the entity classes it displays are tightly coupled (i.e. a change in one&#xD;
                    triggers a change in the other), create subsystems which are vertically integrated: enclose related&#xD;
                    boundary and entity classes in common subsystem.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th id=&quot;row3&quot; width=&quot;35%&quot; rowspan=&quot;2&quot;>&#xD;
                    Look to the Actors&#xD;
                &lt;/th>&#xD;
                &lt;td headers=&quot;row3&quot; width=&quot;65%&quot;>&#xD;
                    Separate functionality used by two different actors, since each actor may independently change their&#xD;
                    requirements on the system.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td headers=&quot;row3&quot; width=&quot;65%&quot;>&#xD;
                    Create subsystems to encapsulate access to an external system or device.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th id=&quot;row5&quot; width=&quot;35%&quot;>&#xD;
                    Look for coupling and cohesion between design elements&#xD;
                &lt;/th>&#xD;
                &lt;td headers=&quot;row5&quot; width=&quot;65%&quot;>&#xD;
                    Highly coupled or cohesive classes/subsystems collaborate to provide some set of services. Organize&#xD;
                    highly coupled elements into subsystems, and separate elements along lines of weak coupling. In some&#xD;
                    cases, weak coupling can be eliminated entirely by splitting classes into smaller classes with more&#xD;
                    cohesive responsibilities, or repartitioning subsystems appropriately.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th id=&quot;row6&quot; width=&quot;35%&quot;>&#xD;
                    Look at substitution&#xD;
                &lt;/th>&#xD;
                &lt;td headers=&quot;row6&quot; width=&quot;65%&quot;>&#xD;
                    If there are several levels of service specified for a particular capability (example: high, medium and&#xD;
                    low availability), represent each service level as a separate subsystem, each of which will realize the&#xD;
                    same set of interfaces. By doing so, the subsystems are substitutable for one another.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th id=&quot;row7&quot; width=&quot;35%&quot;>&#xD;
                    Look at distribution&#xD;
                &lt;/th>&#xD;
                &lt;td headers=&quot;row7&quot; width=&quot;65%&quot;>&#xD;
                    &lt;span&#xD;
                    style=&quot;mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE&quot;>Although&#xD;
                    there can be multiple instances of a particular subsystem, each executing on different nodes, in many&#xD;
                    architectures it is not possible for a single instance of a component to be split across nodes. In the&#xD;
                    cases where subsystem behavior must be split across nodes, it is recommended that you decompose the&#xD;
                    subsystem into smaller subsystems (each representing a single component) with more restricted&#xD;
                    functionality. &lt;span&#xD;
                    style=&quot;mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE; mso-spacerun: yes&quot;>&amp;nbsp;&lt;/span>&#xD;
                    Determine the functionality that must reside upon each node and create a new subsystem to 'own' that&#xD;
                    functionality, distributing the responsibilities and related elements of the original subsystem&#xD;
                    appropriately. &lt;span&#xD;
                    style=&quot;mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE; mso-spacerun: yes&quot;>&amp;nbsp;&lt;/span>&#xD;
                    The new subsystems are internal to the original subsystem.&lt;/span>&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Once the design has been organized into subsystems, update the use-case realizations accordingly.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Modeling Subsystems&quot; name=&quot;Modeling Subsystems&quot;>Modeling Subsystems&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Design Subsystems are modeled using UML components. This construct provides the following modeling capabilities:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        can group classes to define a larger granularity part of a system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can separate the visible interfaces from internal implementation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can have execution at run-time&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Some other considerations are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Each Design Subsystem must be given a name and a short description.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The responsibilities of the original analysis class should be transferred to the newly-created subsystem, using the&#xD;
        description of the subsystem to document the responsibilities&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Note: UML 2.0 also defines a stereotype for component named &amp;lt;&amp;lt;subsystem&amp;gt;&amp;gt;, indicating that this may be&#xD;
    used, for example, to represent large scale structures. A RUP Design Subsystem may or may not be a large scale&#xD;
    structure; both are Design Subsystems from the RUP perspective. This is an issue for the software architect to decide&#xD;
    (whether to choose for example to label components that are composed of components as &amp;lt;&amp;lt;subsystem&amp;gt;&amp;gt;).&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Subsystems That Represent Existing Products&quot; name=&quot;Subsystems That Represent Existing Products&quot;>Subsystems That&#xD;
    Represent Existing Products&lt;/a> &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;./../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Where an existing product is one that exports interfaces, i.e. operations (and perhaps &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/guidances/termdefinitions/reception_E5EE6A47.html&quot;&#xD;
    guid=&quot;_yS_Rg9nmEdmO6L4XMImrsA&quot;>&lt;b>receptions&lt;/b>&lt;/a>), but otherwise keeps all details of implementation hidden, then&#xD;
    it may be modeled as a subsystem in the logical view.&amp;nbsp; Examples of products the system uses that you may be able&#xD;
    to represent by a subsystem include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Communication software (middleware).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Database access support (RDBMS mapping support).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Application-specific products.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Some existing products such as collections of types and data structures (e.g. stacks, lists, queues) may be better&#xD;
    represented as packages, because they reveal more than behavior, and it is the particular contents of the package that&#xD;
    are important and useful and not the package itself, which is simply a container.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Common utilities, such as math libraries, could be represented as subsystems, if they simply export interfaces, but&#xD;
    whether this is necessary or makes sense depends on the designer's judgment about the nature of the thing&#xD;
    modeled.&amp;nbsp; Subsystems are object-oriented constructs (as they are modeled components): a subsystem can have&#xD;
    instances (if the designer so indicates). UML provides another way to model groups of global variables and procedures&#xD;
    in the &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/guidances/termdefinitions/utility_5BFC0972.html&quot;&#xD;
    guid=&quot;_ybVVMNnmEdmO6L4XMImrsA&quot;>utility&lt;/a>, which is a stereotype of class - the utility has no instances.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When defining the subsystem to represent the product, also define one or more interfaces to represent the product&#xD;
    interfaces.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Subsystem Dependency Restrictions&quot; name=&quot;Subsystem Dependency Restrictions&quot;>Subsystem Dependency&#xD;
    Restrictions&lt;/a> &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;./../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Design Subsystems (modeled as UML components) differ from packages in their semantics: a subsystem provides behavior&#xD;
    through one or more interfaces which it realizes. Packages provide no behavior; they are simply containers of things&#xD;
    which provide behavior.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The reason for using a subsystem instead of a package is that subsystems encapsulate their contents, providing behavior&#xD;
    only through their interfaces. The benefit of this is that, unlike a package, the contents and internal behaviors of a&#xD;
    subsystem can be changed with complete freedom so long as the subsystem's interfaces remain constant. Subsystems also&#xD;
    provide a 'replaceable design' element: any two &amp;lt;&amp;lt;realization&amp;gt;&amp;gt; components that realize the same interfaces&#xD;
    (or &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; component) are interchangeable.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In order to ensure that subsystems are replaceable elements in the model, a few rules need to be enforced:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A subsystem should minimize exposing of its contents. Ideally no element contained by a subsystem should have&#xD;
        'public' visibility, and thus no element outside the subsystem depends on the existence of a particular element&#xD;
        inside the subsystem. Some exceptions are as follows: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                In some technologies, the externals of a subsystem cannot be modeled as a UML interface. For example, a&#xD;
                Java interface is modeled as a stereotyped class.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                The subsystem design may require exposing classes rather than UML interfaces. For example, a &quot;delegate&quot; or&#xD;
                &quot;access&quot; class can be used to hide a complex collaboration of other classes. While an ordinary package&#xD;
                could be used instead, a subsystem could be used in order to emphasize the intent to encapsulate behavior&#xD;
                and hide internal details.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        &lt;br />&#xD;
         When a subsystem's externals are not UML interfaces, it is often helpful to have a diagram (for example named&#xD;
        &quot;External View&quot;) that shows the visible elements of the subsystem.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A subsystem should define its dependencies on subsystem interfaces (and publicly visible elements of subsystem in&#xD;
        the exceptional cases described above). In addition, a number of subsystems may share a set of interfaces or class&#xD;
        definitions in common, in which case those subsystems 'import' the contents of the packages which contain the&#xD;
        common elements. This is more common with packages in lower layers in the architecture, to ensure that common&#xD;
        definitions of classes which must pass between subsystems are consistently defined.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    An example of Subsystem and Package dependencies is shown below:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_dsub2.jpg&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Subsystem and Package Dependencies in the Design Model&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Subsystem Specification and Realization&quot; name=&quot;Subsystem Specification and Realization&quot;>Subsystem Specification&#xD;
    and Realization&lt;/a>&lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;./../../../core.base_rup/resources/top.gif&quot;&#xD;
    width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Definition&quot; name=&quot;Definition&quot;>Definition&lt;/a>&lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;./../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The UML ([&lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>UML04&lt;/a>]) states:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        A number of UML standard stereotypes exist that apply to component, e.g. &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; and&#xD;
        &amp;lt;&amp;lt;realization&amp;gt;&amp;gt; to model components with distinct specification and realization definitions, where one&#xD;
        specification may have multiple realizations.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A Component stereotyped by &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; specifies a domain of objects without defining the&#xD;
        physical implementation of those objects. It will only have provided and required interfaces, and is not intended&#xD;
        to have any realizing classes and sub components as part of its definition.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A Component stereotyped by &amp;lt;&amp;lt;realization&amp;gt;&amp;gt; specifies a domain of objects and that also defines the&#xD;
        physical implementation of those objects. For example, a Component stereotyped by &amp;lt;&amp;lt;realization&amp;gt;&amp;gt; will&#xD;
        only have realizing classes and sub components that implement behavior specified by a separate&#xD;
        &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; Component.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    The separation of specification and realization essentially allows for two separate descriptions of the subsystem. The&#xD;
    specification serves as a contract that defines everything that a client needs to know to use the subsystem. The&#xD;
    realization is the detailed internal design intended to guide the implementer. If you wish to support multiple&#xD;
    realizations, create separate &quot;realization&quot; subsystems, and draw a realization from each realization subsystem to the&#xD;
    specification subsystem.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;When and how to use&quot; name=&quot;When and how to use&quot;>When and how to use&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    If the internal state and behavior of the subsystem is relatively simple, it may be sufficient to specify the subsystem&#xD;
    by its exposed interfaces, state diagrams to describe the behavior, and descriptive text.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For more complex internal state and behavior, analysis classes can be used to specify the subsystem at a high level of&#xD;
    abstraction. For large systems of systems, the specification of a subsystem may also include use cases. See &lt;a&#xD;
    class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/whitepapers/developing_large-scale_systems_with_the_rational_unified_process_7AA2AF65.html&quot;&#xD;
     guid=&quot;1.768223108034868E-305&quot;>Developing Large-Scale Systems with the Rational Unified Process&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Providing a detailed specification separate from the realization tends to be most useful in the following situations:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        the subsystem realization's internal state or behavior is complex - and the specification needs to be expressed as&#xD;
        simply as possible in order for clients to use it effectively;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        the subsystem is a reusable &quot;assembly component&quot; intended for assembly into a number of systems (see &lt;a&#xD;
        class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/concepts/component_A2E2B3B1.html&quot;&#xD;
        guid=&quot;3.524150980437479E-305&quot;>Concept: Component&lt;/a>);&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        the subsystem's internals are expected to be developed by a separate organization;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        multiple implementations of the subsystem need to be created;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        the subsystem is expected to be replaced with another version that has significant internal changes without changes&#xD;
        to the externally visible behavior.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Maintaining a separate specification takes effort, however - as one must ensure that the realization of the subsystem&#xD;
    is compliant with the specification. The criteria for when and if to create separate specification and realization&#xD;
    classes and collaborations should be defined in &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot;&#xD;
    guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>Work Product: Project Specific Guidelines.&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Dependencies&quot; name=&quot;Dependencies&quot;>Dependencies&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A specification should define its dependencies. These are the interfaces and visible elements from other subsystems and&#xD;
    packages that must be available in all compliant realizations of the subsystem.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A realization may have additional dependencies, introduced by the designer or implementer. For example, there may be an&#xD;
    opportunity to use a utility component to simplify the implementation - but the use of this utility component is a&#xD;
    detail that need not be exposed to clients. These additional dependencies should be captured on a separate diagram as&#xD;
    part of the realization.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Relationship to Implementation&quot; name=&quot;Relationship to Implementation&quot;>Relationship to Implementation&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A fully detailed specification defines everything a client needs to use the subsystem. This means refining the exposed&#xD;
    interfaces and any publicly visible elements so that they are one-to-one with code. Analysis classes introduced to&#xD;
    specify the subsystem behavior should remain as high level abstractions, since they are intended to be independent of&#xD;
    any subsystems realizations.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The realization elements of a subsystem should align closely to the code.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    See &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/concepts/mapping_from_design_to_code_D1454680.html&quot;&#xD;
    guid=&quot;1.424219730601675E-305&quot;>Concept: Mapping from Design to Code&lt;/a> for some further discussion on this topic.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;UML_1x_Representation&quot; name=&quot;UML_1x_Representation&quot;>UML 1.x Representation&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    Modeling&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Design subsystems may be modeled as either UML 2.0 components or UML 1.5 subsystems. These constructs provide almost&#xD;
    equivalent modeling capabilities like modularity, encapsulation, and instances able to execute at run-time.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Some additional considerations about these modeling options are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        UML 1.5 subsystems explicitly included the notion of &quot;specification&quot; and &quot;realization&quot; (defined above in the&#xD;
        section titled &lt;a href=&quot;#Subsystem%20Specification%20and%20Realization&quot;>Subsystem Specification and&#xD;
        Realization&lt;/a>). The UML 2.0 components support the notion of specification (in the form of one or more provided&#xD;
        and required interfaces) and realization (internal implementation consisting of one or more classes and sub&#xD;
        components that realize its behavior).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        UML 1.5 subsystems were also packages. UML 2.0 components have packaging capabilities, which means they may own and&#xD;
        import a potentially large set of model elements.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    However, by and large, these notations can be used interchangeably. Whether to represent Design Subsystems as UML 1.5&#xD;
    subsystems or UML 2.0 components is a decision that should be documented in the &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot;&#xD;
    guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>Project-Specific Guidelines&lt;/a> tailored for your project.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If your visual modeling tool supports UML 1.5 packages but not UML 1.5 subsystems, a package stereotyped as&#xD;
    &amp;lt;&amp;lt;subsystem&amp;gt;&amp;gt; can be used to denote a subsystem.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Subsystem Dependency Restrictions&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The same dependency restrictions and discussions mentioned in the section titled &lt;a&#xD;
    href=&quot;#Subsystem%20Dependency%20Restrictions&quot;>Subsystem Dependency Restrictions&lt;/a> also apply for design subsystems&#xD;
    being modeled as UML 1.5 subsystems.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An example of Subsystem and Package dependencies in UML 1.5 is shown below:&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br />&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;240&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_dsub1.gif&quot; width=&quot;370&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Subsystem and Package Dependencies in the Design Model&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Subsystem Specification and Realization&#xD;
&lt;/h4>The UML 1.5 stated: &#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        The contents of a subsystem are divided into two subsets: 1) specification elements and 2) realization elements.&#xD;
        The specification elements, together with the operations and receptions of the subsystem, are used for giving an&#xD;
        abstract specification of the behavior offered by the realization elements. The collection of realization elements&#xD;
        model the interior of the behavioral unit of the physical system.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    The separation of specification and realization essentially allows for two separate descriptions of the subsystem. The&#xD;
    specification serves as a contract that defines everything that a client needs to know to use the subsystem. The&#xD;
    realization is the detailed internal design intended to guide the implementer.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    One option for modeling specifications and realizations, if not directly supported by the modeling environment, is to&#xD;
    place two packages, specification and realization, inside each subsystem.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    One motivation for specifications is to support multiple realizations. This was not directly supported in the UML 1.x.&#xD;
    If you wish to support multiple realizations using UML 1.5 subsystems, create separate &quot;realization&quot; subsystems, and&#xD;
    draw a realization from each realization subsystem to the specification subsystem.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Basically, the same considerations for Specification and Realization that apply for UML 2.0, also apply here (see &lt;a&#xD;
    href=&quot;#When%20and%20How%20to%20Use&quot;>When and How to Use&lt;/a>, &lt;a href=&quot;#Dependencies&quot;>Dependencies&lt;/a>, and &lt;a&#xD;
    href=&quot;#Relationship%20to%20Implementation&quot;>Relationship to Implementation&lt;/a> for explanation).&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Additional Information&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Refer to &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html&quot;&#xD;
    guid=&quot;4.792914878943572E-306&quot;>Differences Between UML 1.x and UML 2.0&lt;/a> for more information.&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
