<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1r8xYNnmEdmO6L4XMImrsA" name="capsule,7.026940817483919E-306" guid="_1r8xYNnmEdmO6L4XMImrsA" changeDate="2005-06-21T09:38:36.364-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_concurrency__capsule_guidelines&quot; name=&quot;XE_concurrency__capsule_guidelines&quot;>&lt;/a>&lt;a&#xD;
id=&quot;XE_capsule__guidelines_for&quot; name=&quot;XE_capsule__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3 class=&quot;reactive&quot;>&#xD;
    Topics&#xD;
&lt;/h3>&#xD;
&lt;ul class=&quot;reactive&quot;>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Ports&quot;>Ports&lt;/a> &#xD;
        &lt;ul class=&quot;reactive&quot;>&#xD;
            &lt;li>&#xD;
                &lt;a href=&quot;#Relay%20ports&quot;>Relay Ports&lt;/a>&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                &lt;a href=&quot;#End%20Ports&quot;>End Ports&lt;/a>&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                &lt;a href=&quot;#Port%20Visibility&quot;>Port Visibility&lt;/a>&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                &lt;a href=&quot;#Port-Based%20Triggers&quot;>Port-Based Triggers&lt;/a>&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#State%20Machines&quot;>State Machines&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Time%20Service&quot;>Time Service&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Capsule%20Taxonomy&quot;>Capsule Taxonomy&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#UML_2.0_Representation&quot;>UML 2.0 Representation&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;Ports&quot; name=&quot;Ports&quot;>Ports&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Because ports are on the boundary of a capsule, they may be visible both from outside the capsule and inside. When&#xD;
    viewed from the outside, all ports present the same impenetrable object interface and cannot be differentiated except&#xD;
    by their identity and the role that they play in their protocol. However, when viewed from within the capsule, we find&#xD;
    that ports can be one of two kinds: &lt;b>relay ports&lt;/b> and &lt;b>end ports&lt;/b>. They differ in their internal connections&#xD;
    - relay ports are connected to sub-capsules while end ports are connected to the capsule's state machine. Generally&#xD;
    speaking, relay ports serve to selectively export the &quot;interfaces&quot; of internal sub-capsules while end ports are&#xD;
    boundary objects for the state machine of a capsule. Both relay and end ports may appear on the boundary of the capsule&#xD;
    and, as noted, are indistinguishable from the outside.&#xD;
&lt;/p>&#xD;
&lt;h4 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;Relay ports&quot; name=&quot;Relay ports&quot;>&lt;font size=&quot;3&quot;>Relay Ports&lt;/font>&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    &lt;b>Relay ports&lt;/b> are ports that simply pass all signals through. They provide an &quot;opening&quot; in the encapsulation shell&#xD;
    of a capsule that can be used by its sub-capsules to communicate with the outside world without actually being exposed&#xD;
    to the outside world (and vice versa). A relay port is connected, through a connector, to a sub-capsule and is normally&#xD;
    also connected from outside to some other &quot;peer&quot; capsule. They receive signals coming from either side and simply relay&#xD;
    it to the other side keeping the direction of signal flow. This is achieved without delay or loss of information unless&#xD;
    there is no connector attached on the other side. In the latter case, the signal is lost.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Relay ports allow the direct (zero overhead) delegation of signals destined for a capsule to a sub-capsule without&#xD;
    requiring intervention by the state machine of the capsule. Relay ports can only appear on the boundary of a capsule&#xD;
    and, consequently, always have &lt;b>public&lt;/b> visibility.&#xD;
&lt;/p>&#xD;
&lt;h4 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;End Ports&quot; name=&quot;End Ports&quot;>&lt;font size=&quot;3&quot;>End Ports&lt;/font>&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    To be useful, a chain of connectors must ultimately terminate in an end port that communicates with a state machine.&#xD;
    End ports are boundary objects for the state machines of capsules (although, as we shall see, some of them also serve&#xD;
    as boundary objects for capsules as well). End ports are the ultimate sources and sinks of all signals sent by&#xD;
    capsules. These signals are generated by the state machines of capsules. To send a signal, a state machine invokes a&#xD;
    send or call operation on one of its end ports. The signal is then relayed through the attached connector, possibly&#xD;
    passing through one or more relay ports and chained connectors, until it finally encounters another end port, usually&#xD;
    in a different capsule. Since signal-based communication can be asynchronous, an end port has a queue to hold messages&#xD;
    that have been received but not yet processed by the state machine (i.e., it acts as a mailbox). The reception of the&#xD;
    signal and the dispatching of the receiving state machine is performed by the state machine according to standard UML&#xD;
    semantics.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Like relay ports, end ports may appear on the boundary of a capsule with public visibility. These ports are called&#xD;
    &lt;b>public end ports&lt;/b>. Such ports are boundary objects of both the state machine and the containing capsule. However,&#xD;
    end ports may also appear completely inside the capsule as part of its internal implementation structure. These ports&#xD;
    are used by the state machine to communicate with its sub-capsules or with external &lt;b>implementation-support&#xD;
    layers&lt;/b>. These internal end ports are called &lt;b>protected end ports&lt;/b> since they have protected visibility.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Note that the kind of port is totally determined by its internal connectivity and its visibility outside the capsule;&#xD;
    the various terms (relay port, public end port, private end port) are merely shorthand terminology. A public port that&#xD;
    is not connected internally may become either a relay port or an end port depending on how it is later connected, or it&#xD;
    may remain unconnected and be a sink for incoming signals.&#xD;
&lt;/p>&#xD;
&lt;h4 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;Port Visibility&quot; name=&quot;Port Visibility&quot;>&lt;font size=&quot;3&quot;>Port Visibility&lt;/font>&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    From an external viewpoint, a port is a port; it is not possible or even desirable to determine whether a port is a&#xD;
    relay port or an end port. However, when the decomposition of a capsule is shown, we can see inside the capsule and the&#xD;
    end port/relay port distinction is indicated graphically as shown below.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;173&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_cpsl1.gif&quot; width=&quot;451&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactivepicturetext&quot; align=&quot;center&quot;>&#xD;
    Port notation - communication diagram (internal view)&#xD;
&lt;/p>&#xD;
&lt;h4 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;Port-Based Triggers&quot; name=&quot;Port-Based Triggers&quot;>&lt;font size=&quot;3&quot;>Port-Based Triggers&lt;/font>&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    In practice, it often happens that two or more ports of the same capsule use the same protocol but are semantically&#xD;
    distinct. Also, the same signal may appear in more than one protocol role supported by different ports of a capsule. In&#xD;
    either case, it may be necessary to distinguish the specific end port that received the current signal. That allows&#xD;
    applications to handle the same signal differently depending on the source of that signal as well as the state. We&#xD;
    refer to this type of trigger as a &lt;b>port-based trigger&lt;/b>. Port-based triggers are modeled in UML by using guard&#xD;
    conditions that checks for a particular source port.&#xD;
&lt;/p>&#xD;
&lt;h3 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;State Machines&quot; name=&quot;State Machines&quot;>&lt;font size=&quot;4&quot;>State Machines&lt;/font>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    The specification for the state machine part of a capsule as well as the specification of valid protocol sequences is&#xD;
    done using standard UML state machines.&#xD;
&lt;/p>&#xD;
&lt;h3 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;Time Service&quot; name=&quot;Time Service&quot;>&lt;font size=&quot;3&quot;>&lt;font size=&quot;4&quot;>Time Service&lt;/font>&lt;/font>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    As can be expected, in most real-time systems time is a first-order concern. In general, two forms of time-based&#xD;
    situations need to be modeled: the ability to trigger tasks at a particular &lt;b>time of day&lt;/b> and, the ability to&#xD;
    trigger tasks after a certain &lt;i>interval&lt;/i> has expired from a given point in time.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Most real-time systems require an explicit and directly accessible (controllable) timing facility - a &lt;b>time&#xD;
    service&lt;/b>. This service, which can be accessed through a standard port (service access point), converts time into&#xD;
    events that can then be handled in the same way as other signal-based events. For example, with such a service, a state&#xD;
    machine can request that it be notified with a &quot;timeout&quot; event when a particular time of day has been reached or when a&#xD;
    particular interval has expired.&#xD;
&lt;/p>&#xD;
&lt;h3 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;Capsule Taxonomy&quot; name=&quot;Capsule Taxonomy&quot;>&lt;font size=&quot;4&quot;>Capsule Taxonomy&lt;/font>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Capsules as a concept may be used in a number of different ways. To reflect this, a capsule hierarchy and taxonomy can&#xD;
    be described to cover the common usages of capsules.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot; align=&quot;center&quot;>&#xD;
    &lt;map id=&quot;FPMap0&quot; name=&quot;FPMap0&quot;>&#xD;
        &lt;area shape=&quot;rect&quot; alt=&quot;Role Model Realization&quot; coords=&quot;219,297,363,349&quot; href=&quot;#Role%20Model%20Realization&quot; />&#xD;
        &lt;area shape=&quot;rect&quot; alt=&quot;Typed Role Model&quot; coords=&quot;137,216,264,265&quot; href=&quot;#Typed%20Role%20Model&quot; />&#xD;
        &lt;area shape=&quot;rect&quot; alt=&quot;Typed Role Realization&quot; coords=&quot;373,248,525,295&quot; href=&quot;#Typed%20Role%20Realization&quot; />&#xD;
        &lt;area shape=&quot;rect&quot; alt=&quot;Role Realization&quot; coords=&quot;395,110,541,154&quot; href=&quot;#Role%20Realization&quot; />&#xD;
        &lt;area shape=&quot;rect&quot; alt=&quot;Capsule&quot; coords=&quot;94,2,166,46&quot; href=&quot;#Capsule&quot; />&#xD;
        &lt;area shape=&quot;rect&quot; alt=&quot;Role Model&quot; coords=&quot;252,114,365,161&quot; href=&quot;#Role%20Model&quot; />&#xD;
        &lt;area shape=&quot;rect&quot; alt=&quot;Role Type&quot; coords=&quot;98,112,211,160&quot; href=&quot;#Role%20Type&quot; />&#xD;
    &lt;/map>&lt;img height=&quot;467&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_cpsl5.gif&quot; width=&quot;635&quot;&#xD;
    usemap=&quot;#fpmap0&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactivepicturetext&quot; align=&quot;center&quot;>&#xD;
    Capsule Taxonomy showing generalization hierarchy&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
    The basic capsule taxonomy is:&#xD;
&lt;/p>&#xD;
&lt;ul class=&quot;reactive&quot;>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            &lt;a id=&quot;Capsule&quot; name=&quot;Capsule&quot;>&lt;b>Capsule&lt;/b>&lt;/a>&#xD;
        &lt;/p>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            A basic capsule, lacking ports, internal structure or behavior is not terribly interesting - it doesn't do&#xD;
            much. Such a capsule could be used to define an abstract capsule from which other capsules are derived. Since&#xD;
            no ports, structure or behavior is defined, this capsule type is useful only to define a &quot;placeholder&quot; which&#xD;
            will be refined later.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            &lt;b>&lt;a id=&quot;Role Type&quot; name=&quot;Role Type&quot;>Role Type&lt;/a>&lt;/b>&#xD;
        &lt;/p>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            A capsule &quot;role type&quot; consists of a capsule definition which defines an abstract capsule with one or more&#xD;
            ports; there is no structure or behavior defined. This type of capsule is used in cases where the &quot;interfaces&quot;&#xD;
            (ports) of a set of capsules needs to be defined once, with the specific realizations of those interfaces&#xD;
            defined by the sub-types of the 'role type' capsule.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            &lt;a id=&quot;Role Model&quot; name=&quot;Role Model&quot;>&lt;b>Role Model&lt;/b>&lt;/a>&#xD;
        &lt;/p>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            A capsule &quot;role model&quot; consists of a capsule definition with an internal structure (defined by a specification&#xD;
            collaboration) of nested and potentially interconnected capsules, and potentially one or more ports. This type&#xD;
            of capsule is used to define a &quot;template&quot; for the structure of a system, the 'details' of which are delegated&#xD;
            to the contained capsules. If the role model capsule has ports, these ports define the 'interfaces' for the&#xD;
            capsule.&#xD;
        &lt;/p>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            The behavior of the 'role model' is unspecified (there is no state machine defined); the behavior must be&#xD;
            defined by the sub-types of the capsule.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            &lt;a id=&quot;Role Realization&quot; name=&quot;Role Realization&quot;>&lt;b>Role Realization&lt;/b>&lt;/a>&#xD;
        &lt;/p>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            A capsule &quot;role realization&quot; defines behavior (via a state machine) for the capsule, but neither internal&#xD;
            structure nor interfaces. It essentially provides an abstract definition of behavior for all derivative&#xD;
            capsules, which must then in turn define their own internal structure and interface. The behavior definition&#xD;
            can be viewed as a 'design assertion' which must be satisfied by all capsules which are derived from the 'role&#xD;
            realization' capsule.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
    There are three useful hybrids of these basic types, which represent mixtures of the basic definitions:&#xD;
&lt;/p>&#xD;
&lt;ul class=&quot;reactive&quot;>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            &lt;a id=&quot;Typed Role Realization&quot; name=&quot;Typed Role Realization&quot;>&lt;b>Typed Role Realization&lt;/b>&lt;/a>&#xD;
        &lt;/p>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            This type of capsule defines both an interface and the behavior of a set of capsules, but does not constrain&#xD;
            the internal structure of derivative capsules. It is essentially a 'role realization' capsule which further&#xD;
            defines an interface.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            &lt;a id=&quot;Typed Role Model&quot; name=&quot;Typed Role Model&quot;>&lt;b>Typed Role Model&lt;/b>&lt;/a>&#xD;
        &lt;/p>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            This type of capsule defines an interface and the structure of a set of capsules, but does not constrain the&#xD;
            behavior of those capsules. The benefit in doing this is to define a template for the interface and the&#xD;
            structure which can then be subsequently specialized as needed by derivative capsules.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            &lt;a id=&quot;Role Model Realization&quot; name=&quot;Role Model Realization&quot;>&lt;b>Role Model Realization&lt;/b>&lt;/a>&#xD;
        &lt;/p>&#xD;
        &lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
            This type of capsule defines an internal structure for the capsule and its abstract behavior, but does not&#xD;
            define the interface. This type of capsule is useful in cases where a number of capsules may share a&#xD;
            significant amount of internal structure and behavior, but have different interfaces.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p class=&quot;reactive&quot; align=&quot;left&quot;>&#xD;
    The remaining capsule type, the 'typed role model realization', which defines structure and interface, plus behavior in&#xD;
    the abstract (for the interface) and in the specific (for the internal structure) is complex and can be hard to&#xD;
    understand, let alone implement correctly. It is mentioned for the sake of the case where unit tests on the capsule&#xD;
    need to be defined as part of the capsule itself, hence the two separate state machines. In most cases, this construct&#xD;
    is best avoided.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;UML_2.0_Representation&quot; name=&quot;UML_2.0_Representation&quot;>UML 2.0 Representation&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Note that the current RUP representation for Capsules is based on UML 1.5 notation. Much of this can be represented in&#xD;
    UML 2.0 using the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html&quot; guid=&quot;1.1994826813129747E-304&quot;>Concept:&#xD;
    Structured Class&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Refer to &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html&quot;&#xD;
    guid=&quot;4.792914878943572E-306&quot;>Differences Between UML 1.x and UML 2.0&lt;/a> for more information.&lt;br />&#xD;
    &lt;br />&#xD;
    &lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
