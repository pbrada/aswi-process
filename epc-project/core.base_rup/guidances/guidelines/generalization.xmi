<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_12OuwdnmEdmO6L4XMImrsA" name="generalization,1.839540980397304E-305" guid="_12OuwdnmEdmO6L4XMImrsA" changeDate="2005-06-16T20:28:19.588-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_use-case-generalization__guidelines_for&quot;&#xD;
name=&quot;XE_use-case-generalization__guidelines_for&quot;>&lt;/a>&lt;a id=&quot;XE_generalization__guidelines_for&quot;&#xD;
name=&quot;XE_generalization__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Generalization&quot; name=&quot;Generalization&quot;>Generalization&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Many things in real life have common properties. Both dogs and cats are animals, for example. Objects can have common&#xD;
    properties as well, which you can clarify using a generalization between their classes. By extracting common properties&#xD;
    into classes of their own, you will be able to change and maintain the system more easily in the future.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A generalization shows that one class inherits from another. The inheriting class is called a descendant. The class&#xD;
    inherited from is called the ancestor. Inheritance means that the definition of the ancestor - including any properties&#xD;
    such as attributes, relationships, or operations on its objects - is also valid for objects of the descendant. The&#xD;
    generalization is drawn from the descendant class to its ancestor class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Generalization can take place in several stages, which lets you model complex, multilevel inheritance hierarchies.&#xD;
    General properties are placed in the upper part of the inheritance hierarchy, and special properties lower down. In&#xD;
    other words, you can use generalization to model specializations of a more general concept.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In the Recycling Machine System all the classes - Can, Bottle, and Crate - describe different types of deposit items.&#xD;
    They have two common properties, besides being of the same type: each has a height and a weight. You can model these&#xD;
    properties through attributes and operations in a separate class, Deposit Item. Can, Bottle, and Crate will inherit the&#xD;
    properties of this class.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_gene2.gif&quot; width=&quot;400&quot; height=&quot;275&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The classes Can, Bottle, and Crate have common properties height and weight. Each is a specialization of the general&#xD;
    concept Deposit Item.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_multiple_inheritance&quot; name=&quot;XE_multiple_inheritance&quot;>&lt;/a>&lt;a id=&quot;XE_multiple_inheritance__guidelines_for&quot;&#xD;
    name=&quot;XE_multiple_inheritance__guidelines_for&quot;>&lt;/a>&lt;a id=&quot;XE_inheritance__multiple_inheritance&quot;&#xD;
    name=&quot;XE_inheritance__multiple_inheritance&quot;>&lt;/a>&lt;a id=&quot;Multiple Inheritance&quot; name=&quot;Multiple Inheritance&quot;>Multiple&#xD;
    Inheritance&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A class can inherit from several other classes through multiple inheritance, although generally it will inherit from&#xD;
    only one.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are a couple of potential problems you must be aware of if you use multiple inheritance:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        If the class inherits from several classes, you must check how the relationships, operations, and attributes are&#xD;
        named in the ancestors. If the same name appears in several ancestors, you must describe what this means to the&#xD;
        specific inheriting class, for example, by qualifying the name to indicate its source of declaration.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If repeated inheritance is used; in this case, the same ancestor is being inherited by a descendant more than once.&#xD;
        When this occurs, the inheritance hierarchy will have a &quot;diamond shape&quot; as shown below.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_gene3.gif&quot; width=&quot;362&quot; height=&quot;218&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Multiple and repeated inheritance. The Scrolling Window With Dialog Box class is inheriting the Window class more than&#xD;
    once.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A question that might arise in this context is &quot;How many copies of the attributes of Window are included in instances&#xD;
    of Scrolling Window With Dialog Box?&quot; So, if you are using repeated inheritance, you must have a clear definition of&#xD;
    its semantics; in most cases this is defined by the programming language supporting the multiple inheritance.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In general, the programming language rules governing multiple inheritance are complex, and often difficult to use&#xD;
    correctly. Therefore using multiple inheritance only when needed, and always with caution is recommended.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_concrete_classes__guidelines_for&quot; name=&quot;XE_concrete_classes__guidelines_for&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Abstract and Concrete Classes&quot; name=&quot;Abstract and Concrete Classes&quot;>Abstract and Concrete Classes&lt;/a> &lt;a&#xD;
    id=&quot;XE_abstract_classes__guidelines_for&quot; name=&quot;XE_abstract_classes__guidelines_for&quot;>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A class that is not instantiated and exists only for other classes to inherit it, is an abstract class. Classes that&#xD;
    are actually instantiated are concrete classes. Note that an abstract class must have at least one descendant to be&#xD;
    useful.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    A Pallet Place in the Depot-Handling System is an abstract entity class that represents properties common to different&#xD;
    types of pallet places. The class is inherited by the concrete classes Station, Transporter, and Storage Unit, all of&#xD;
    which can act as pallet places in the depot. All these objects have one common property: they can hold one or more&#xD;
    Pallets.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_gene4.gif&quot; width=&quot;370&quot; height=&quot;208&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The inherited class, here Pallet Place, is abstract and not instantiated on its own.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Use&quot; name=&quot;Use&quot;>Use&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Because class stereotypes have different purposes, inheritance from one class stereotype to another does not make&#xD;
    sense. Letting a boundary class inherit an entity class, for example, would make the boundary class into some kind of&#xD;
    hybrid. Therefore, you should use generalizations only between classes of the same stereotype.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You can use generalization to express two relationships between classes:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Subtyping, specifying that the descendant is a subtype of the ancestor. Subtyping means that the descendant&#xD;
        inherits the structure and behavior of the ancestor, and that the descendant is a type of the ancestor (that is,&#xD;
        the descendant is a subtype that can fill in for all its ancestors in any situation).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Subclassing, specifying that the descendant is a subclass (but not a subtype) of the ancestor. Subclassing means&#xD;
        that the descendant inherits the structure and behavior of the ancestor, and that the descendant is not a type of&#xD;
        the ancestor.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    You can create relationships such as these by breaking out properties common to several classes and placing them in a&#xD;
    separate classes that the others inherit; or by creating new classes that specialize more general ones and letting them&#xD;
    inherit from the general classes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the two variants coincide, you should have no difficulty setting up the right inheritance between classes. In some&#xD;
    cases, however, they do not coincide, and you must take care to keep the use of inheritance understandable. At the very&#xD;
    least you should know the purpose of each inheritance relationship in the model.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_inheritance__to_support_polymorphism&quot; name=&quot;XE_inheritance__to_support_polymorphism&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_generalization__inheritance_to_support_polymorphism&quot;&#xD;
    name=&quot;XE_generalization__inheritance_to_support_polymorphism&quot;>&lt;/a>&lt;a id=&quot;Inheritance to Support Polymorphism&quot;&#xD;
    name=&quot;Inheritance to Support Polymorphism&quot;>Inheritance to Support Polymorphism&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Subtyping means that the descendant is a subtype that can fill in for all its ancestors in any situation. Subtyping is&#xD;
    a special case of polymorphism, and is an important property because it lets you design all the clients (objects that&#xD;
    use the ancestor) without taking the ancestor's potential descendants into consideration. This makes the client objects&#xD;
    more general and reusable. When the client uses the actual object, it will work in a specific way, and it will always&#xD;
    find that the object does its task. Subtyping ensures that the system will tolerate changes in the set of subtypes.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In a Depot-Handling System, the Transporter Interface class defines basic functionality for communication with all&#xD;
    types of transport equipment, such as cranes and trucks. The class defines the operation executeTransport, among other&#xD;
    things.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_gene5.gif&quot; width=&quot;387&quot; height=&quot;193&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Both the Truck Interface and Crane Interface classes inherit from the Transporter Interface; that is, objects of both&#xD;
    classes will respond to the message executeTransport. The objects may stand in for Transporter Interface at any time&#xD;
    and will offer all its behavior. Thus, other objects (client objects) can send a message to a Transporter Interface&#xD;
    object, without knowing if a Truck Interface or Crane Interface object will respond to the message.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The Transporter Interface class can even be abstract, never instantiated on its own. In which case, the Transporter&#xD;
    Interface might define only the signature of the executeTransport operation, whereas the descendant classes implement&#xD;
    it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Some object-oriented languages, such as C++, use the class hierarchy as a type hierarchy, forcing the designer to use&#xD;
    inheritance to subtype in the design model. Others, such as Smalltalk-80, have no type checking at compilation time. If&#xD;
    the objects cannot respond to a received message they will generate an error message.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It may be a good idea to use generalization to indicate subtype relationships even in languages without type checking.&#xD;
    In some cases, you should use generalization to make the object model and source code easier to understand and&#xD;
    maintain, regardless of whether the language allows it. Whether or not this use of inheritance is good style depends&#xD;
    heavily on the conventions of the programming language.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_inheritance__to_support_implementation_reuse&quot; name=&quot;XE_inheritance__to_support_implementation_reuse&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_generalization__inheritance_to_support_implementation_reuse&quot;&#xD;
    name=&quot;XE_generalization__inheritance_to_support_implementation_reuse&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Inheritance to Support Implementation Reuse&quot; name=&quot;Inheritance to Support Implementation Reuse&quot;>Inheritance to&#xD;
    Support Implementation Reuse&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Subclassing constitutes the reuse aspect of generalization. When subclassing, you consider what parts of an&#xD;
    implementation you can reuse by inheriting properties defined by other classes. Subclassing saves labor and lets you&#xD;
    reuse code when implementing a particular class.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In the Smalltalk-80 class library, the class Dictionary inherits properties from Set.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_gene6.gif&quot; width=&quot;302&quot; height=&quot;141&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The reason for this generalization is that Dictionary can then reuse some general methods and storage strategies from&#xD;
    the implementation of Set. Even though a Dictionary can be seen as a Set (containing key-value pairs), Dictionary is&#xD;
    not a subtype of Set because you cannot add just any kind of object to a Dictionary (only key-value pairs). Objects&#xD;
    that use Dictionary are not aware that it actually is a Set.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Subclassing often leads to illogical inheritance hierarchies that are difficult to understand and to maintain.&#xD;
    Therefore, it is not recommended that you use inheritance only for reuse, unless something else is recommended in using&#xD;
    your programming language. Maintenance of this kind of reuse is usually quite tricky. Any change in the class Set can&#xD;
    imply large changes of all classes inheriting the class Set. Be aware of this and inherit only stable classes.&#xD;
    Inheritance will actually freeze the implementation of the class Set, because changes to it are too expensive.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_programming_languages__designing_inheritance&quot; name=&quot;XE_programming_languages__designing_inheritance&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_inheritance__in_programming_languages&quot; name=&quot;XE_inheritance__in_programming_languages&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_generalization__inheritance_in_programming_languages&quot;&#xD;
    name=&quot;XE_generalization__inheritance_in_programming_languages&quot;>&lt;/a>&lt;a id=&quot;Inheritance in Programming Languages&quot;&#xD;
    name=&quot;Inheritance in Programming Languages&quot;>Inheritance in Programming Languages&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The use of generalization relationships in design should depend heavily on the semantics and proposed use of&#xD;
    inheritance in the programming language. Object-oriented languages support inheritance between classes, but&#xD;
    nonobject-oriented languages do not. You should handle language characteristics in the design model. If you are using a&#xD;
    language that does not support inheritance, or multiple inheritance, you must simulate inheritance in the&#xD;
    implementation. In which case, it is better to model the simulation in the design model and not use generalizations to&#xD;
    describe inheritance structures. Modeling inheritance structures with generalizations, and then simulating inheritance&#xD;
    in the implementation, can ruin the design.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you are using a language that does not support inheritance, or multiple inheritance, you must simulate inheritance&#xD;
    in the implementation. In this case, it is best to model the simulation in the design model and not use generalizations&#xD;
    to describe inheritance structures. Modeling inheritance structures with generalizations, and then only simulating&#xD;
    inheritance in the implementation can ruin the design.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You will probably have to change the interfaces and other object properties during simulation. It is recommended that&#xD;
    you simulate inheritance in one of the following ways:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        By letting the descendant forward messages to the ancestor.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        By duplicating the code of the ancestor in each descendant. In this case, no ancestor class is created.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In this example the descendants forward messages to the ancestor via links that are instances of associations.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_gene7.gif&quot; width=&quot;346&quot; height=&quot;206&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Behavior common to Can, Bottle, and Crate objects is assigned to a special class. Objects for which this behavior is&#xD;
    common send a message to a Deposit Item object to perform the behavior when necessary.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
