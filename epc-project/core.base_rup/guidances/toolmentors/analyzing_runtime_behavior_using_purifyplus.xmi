<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_2H9_ANnmEdmO6L4XMImrsA" name="analyzing_runtime_behavior_using_purifyplus,{63F53632-61E3-40E9-BA84-3DCE7903F99D}" guid="_2H9_ANnmEdmO6L4XMImrsA" changeDate="2005-10-06T10:47:23.811-0700" changeDescription="  Was attached to Implementation\Developer Test &amp; Debug\Guidance" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    This tool mentor is applicable for use both with Microsoft Windows systems and with UNIX systems.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The PurifyPlus tools include Rational Purify, Rational PureCoverage, and Rational Quantify.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;15&quot; alt=&quot;Book icon&quot; hspace=&quot;0&quot; src=&quot;../../resources/book.gif&quot; width=&quot;16&quot; border=&quot;0&quot; /> To learn more about&#xD;
    PurifyPlus tools, read the &lt;i>Getting Started&lt;/i> manual for PurifyPlus (Windows version or UNIX version).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;16&quot; alt=&quot;helpbook icon&quot; hspace=&quot;0&quot; src=&quot;../../resources/helpbook.gif&quot; width=&quot;16&quot; border=&quot;0&quot; /> For&#xD;
    step-by-step information about using PurifyPlus tools, see the online Help for the tool.&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    Analysis of runtime performance&amp;nbsp;&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    Analysis of runtime performance includes the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Detecting memory errors and leaks (C/C++ programs on Windows and UNIX).&lt;/b> &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Use Purify to pinpoint these problems, both in your own code and in the components your software uses, even&#xD;
                when you don't have the source.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Use PureCoverage to ensure all code has been covered. (You can also use PureCoverage independently of&#xD;
                Purify to collect coverage data for C/C++, Java, and .NET managed code.)&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Profiling memory usage (Java and .NET managed code on Windows).&lt;/b> Use Purify to show where you are using&#xD;
        memory inefficiently.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Profiling performance (Windows and UNIX).&lt;/b> Use Quantify to show where your program is spending the most time&#xD;
        so that you can eliminate major performance bottlenecks.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Runtime analysis with PurifyPlus tools results in error-free code that runs at maximum efficiency.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Tool Steps&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    To perform runtime analysis using the PurifyPlus tools:&#xD;
&lt;/p>&#xD;
&lt;div style=&quot;MARGIN-LEFT: 2em&quot;>&#xD;
    &lt;ol>&#xD;
        &lt;li>&#xD;
            &lt;a href=&quot;#Step1&quot;>Run your program under Purify to collect error, leak, and coverage data (C/C++ programs on&#xD;
            Windows and UNIX)&lt;/a>&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;a href=&quot;#Step2&quot;>Run your program under Purify to detect inefficient memory usage (Java and .NET managed code&#xD;
            on Windows)&lt;/a>&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;a href=&quot;#Step3&quot;>Run your program under Quantify to find performance bottlenecks (Windows and UNIX)&lt;/a>&#xD;
        &lt;/li>&#xD;
    &lt;/ol>&#xD;
&lt;/div>&#xD;
&lt;h3>&#xD;
    1. &lt;a id=&quot;Step1&quot; name=&quot;Step1&quot;>&lt;/a>&lt;b>Run your program under Purify to collect error, leak, and coverage data (C/C++&#xD;
    programs on Windows and UNIX)&amp;nbsp;&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Purify detects hard-to-find runtime errors, including memory leaks in your own code and in the components your software&#xD;
    uses. It reports memory errors such as array bounds errors, access through dangling pointers, uninitialized memory&#xD;
    reads, memory allocation errors, and memory leaks, so that you can resolve them before they do any damage. If you have&#xD;
    Rational PureCoverage on your system, you can also see the parts of your code that you have, and have not,&#xD;
    tested.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Begin by running your program under Purify:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        On a Windows system: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                If you are working in Microsoft Visual Studio 6, first select the Visual Studio menu item&#xD;
                &lt;b>Purify&amp;nbsp;&amp;gt; Engage Purify Integration&lt;/b> . If you have PureCoverage on your system, select&#xD;
                &lt;b>Purify&amp;nbsp;&amp;gt; Collect Coverage Data&lt;/b> as well, instructing Purify to monitor code coverage. Then&#xD;
                run your program in Visual Studio as usual.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                If you are using Purify as a standalone program, not integrated with Visual Studio, select &lt;b>File &amp;gt;&#xD;
                Run&lt;/b> . In the Run Program dialog, select &lt;b>Collect error, leak, and coverage data&lt;/b> (or &lt;b>Collect&#xD;
                error and leak data&lt;/b> if you do not have PureCoverage on your system) and run your program.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        On a UNIX system, add the word &lt;font face=&quot;Courier New&quot; size=&quot;2&quot;>purify&lt;/font>. Put this at the beginning of your&#xD;
        compile/link line. If you have PureCoverage on your system, add &lt;font face=&quot;Courier New&quot; size=&quot;2&quot;>purecov&lt;/font> as&#xD;
        well. For example:&lt;br />&#xD;
         &lt;font face=&quot;Courier New,Courier&quot; size=&quot;-1&quot;>% purify purecov cc -g hello_world.c&lt;/font>&lt;br />&#xD;
         Then run the program as usual.&#xD;
    &lt;/li>&#xD;
&lt;/ul>As you exercise the program, Purify lists runtime errors in the Purify Viewer. When you exit the program, Purify&#xD;
reports memory leaks. &#xD;
&lt;p>&#xD;
    Scan the message headers to identify critical errors. Expand messages to see more detailed diagnostic information,&#xD;
    including the code that generated the error. From the Viewer, you can open the source code in your editor, at the line&#xD;
    where the error occurred, and make your correction directly.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    After you correct errors and rebuild the program, verify your corrections by rerunning the updated program and&#xD;
    comparing the new results to the previous run. Repeat the cycle of instrumenting and running, analyzing, and correcting&#xD;
    until your program runs clean.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you collected coverage data for the program runs, you can also see the parts of your code that you have not checked&#xD;
    for errors. Use this information to adjust the scope of your runtime analysis so that you find all of the errors in&#xD;
    your program, wherever they occur.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>&lt;img height=&quot;16&quot; alt=&quot;helpbook icon&quot; hspace=&quot;0&quot; src=&quot;../../resources/helpbook.gif&quot; width=&quot;16&quot; border=&quot;0&quot; />&lt;/b> For&#xD;
    more information, look up the following topics in the Purify online Help index:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;i>running programs&lt;/i>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;i>Purify messages&lt;/i>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;i>source code&lt;/i>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;i>coverage data&lt;/i>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    2. &lt;a id=&quot;Step2&quot; name=&quot;Step2&quot;>&lt;/a>&lt;b>Run your program under Purify to detect inefficient memory usage (Java and .NET&#xD;
    managed code on Windows)&amp;nbsp;&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Purify helps you identify Java and .NET managed code memory problems. Using Purify, you can determine:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        how much memory your program is using&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        how much new memory your program consumes for a specific set of actions&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        what methods and objects in your program are consuming so much memory&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        which objects may be preventing unneeded objects from being garbage collected&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        where it would be advisable to force a garbage collection to improve performance&#xD;
    &lt;/li>&#xD;
&lt;/ul>Begin by running your program under Purify. &#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        If you are working in Microsoft Visual Studio .NET, IBM WSWB, or IBM WSS AD, first select the menu item&#xD;
        &lt;b>PurifyPlus&amp;nbsp;&amp;gt; Purify&amp;nbsp;&amp;gt; Engage Purify Integration&lt;/b> . Then run your program as usual.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If you are using Purify as a standalone program, not integrated with Visual Studio .NET or WSWB/WSS AD, select&#xD;
        &lt;b>File &amp;gt; Run&lt;/b> in the Purify user interface. In the Run Program dialog, select &lt;b>Collect memory profiling&#xD;
        data&lt;/b> and run your program.&#xD;
    &lt;/li>&#xD;
&lt;/ul>After your program has finished its initialization procedures, use the Purify snapshot command to &lt;b>benchmark&lt;/b>&#xD;
memory usage at that moment. The snapshot is your basis for investigating how your program uses memory as it runs.&#xD;
&amp;nbsp;&amp;nbsp; &#xD;
&lt;p>&#xD;
    Once you have the snapshot, you can capture a record of the memory your program uses as it runs. Execute the parts of&#xD;
    the program that you suspect are leaking memory. Purify displays a memory allocation graph that shows real-time&#xD;
    variations in current memory use. When you observe an increase in allocated memory, take another snapshot.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Compare the two snapshots to identify methods that may be leaking memory. Exit your program and compare (or &quot;diff&quot;) the&#xD;
    two snapshots. Purify displays a call graph showing the methods that are responsible for the largest amounts of memory&#xD;
    allocated while your program was running, between the time you took the first and second snapshots. You can focus on&#xD;
    specific methods within the call graph to investigate them more closely.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the amount of memory allocated to a method is unexpectedly large, examine your source code and revise it, if&#xD;
    necessary, to free memory when there is no longer a need for it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Once you've identified methods that appear to have memory problems, analyze these methods at the object level. Look for&#xD;
    objects that should be, but have not been, freed and garbage-collected, perhaps because other objects retain an&#xD;
    unneeded reference to them.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;16&quot; alt=&quot;helpbook icon&quot; src=&quot;../../resources/helpbook.gif&quot; width=&quot;16&quot; /> For more information, look up the&#xD;
    following in the Purify online Help index:&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;i>running programs&lt;/i>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;i>comparing runs&lt;/i>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;i>data browser&lt;/i>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    3. &lt;a id=&quot;Step3&quot; name=&quot;Step3&quot;>&lt;b>Run your program under Quantify to find performance bottlenecks (Windows and&#xD;
    UNIX).&lt;/b>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Quantify provides a complete, accurate, and easy-to-interpret set of performance data for your program and its&#xD;
    components, so that you can identify and eliminate performance bottlenecks in your code.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Begin by running the program under Quantify to collect performance data:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        On a Windows system: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                If you are working in Microsoft Visual Studio 6, first select the Visual Studio menu item&#xD;
                &lt;b>Quantify&amp;nbsp;&amp;gt; Engage Quantify Integration&lt;/b> . Then run your program in Visual Studio as usual.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                If you are working in Microsoft Visual Studio .NET, IBM WSWB, or IBM WSS AD, select the menu item&#xD;
                &lt;b>PurifyPlus&amp;nbsp;&amp;gt; Quantify&amp;nbsp;&amp;gt; Engage Quantify Integration&lt;/b> . Then run your program in as&#xD;
                usual.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                If you are using Quantify as a standalone program, not integrated with Visual Studio or WSWB/WSS AD, select&#xD;
                &lt;b>File&amp;nbsp;&amp;gt;&amp;nbsp;Run&lt;/b> to run your program in the Quantify user interface.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        On a UNIX system, add the word &lt;i>quantify&lt;/i> to the beginning of your compile/link line. For example:&lt;br />&#xD;
&lt;pre>&#xD;
     % quantify cc -g hello_world.c&#xD;
&lt;/pre>&#xD;
        Then run the program as usual.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    As you exercise your code, Quantify records data about your program's performance and displays the activity of its&#xD;
    threads and fibers. When you exit your program, Quantify has an accurate profile of its performance that you can use to&#xD;
    find and diagnose bottlenecks.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Quantify data display includes:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        a Call Graph window that graphically depicts the calling structure and performance of the functions in the program&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        a sortable Function List window that lists all functions with performance data&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        a Function Detail window that displays data for a specific function, its callers, and its descendants&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        an Annotated Source window that shows line-by-line performance data on a copy of the source code&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    With the data you collect, you will be able to identify performance bottlenecks such as needless computations and&#xD;
    recomputations, premature computations, or excessive and expensive library calls.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    After you modify your code to eliminate or minimize the bottlenecks, rerun the updated program under Quantify. Then&#xD;
    compare the new results to the previous run by creating a &quot;diff&quot; dataset, which gives clear indications of performance&#xD;
    improvements and regressions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For more information, look up the following topics in the Quantify online Help index:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;i>running programs&lt;/i>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;i>comparing runs&lt;/i>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;i>call graph window&lt;/i>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;i>annotated source window&lt;/i>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
