<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_2H9_BNnmEdmO6L4XMImrsA" name="implement_auto_component_test,{CE38BCE7-D8E1-460F-ADF0-1FC94CB1D7E2}" guid="_2H9_BNnmEdmO6L4XMImrsA" changeDate="2005-10-06T10:51:46.078-0700" changeDescription="  Was attached to Implementation\Developer Test &amp; Debug\Guidance" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    Overview&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This tool mentor provides an overview of the four primary unit testing tasks performed with Rational QualityArchitect:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Unit Testing&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Scenario Testing&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Stub Generation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        EJB Session Recording&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A development process that puts off testing until all components can be assembled into a completed system is a risky&#xD;
    proposition. Defects found so late in the lifecycle will be more difficult to fix and more likely to cause serious&#xD;
    schedule delays, particularly if they are architectural problems that may require an extensive redesign to correct.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Even if a team has reasonably high confidence in the quality of its system's components, the overall confidence of the&#xD;
    system can still be unacceptably low. For example, consider a simple system comprised of five components, each of which&#xD;
    is rated (either by test coverage metrics or by less quantitative methods) to be 95% reliable. Because system&#xD;
    reliability is cumulative, the overall rating is 95% x 95% x 95% x 95%x 95%, or just over 77%. Whereas the potential&#xD;
    for problems in any one component may be just 1 in 20, for the overall system it approaches 1 in 4-and that's for a&#xD;
    system with relatively few components.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In contrast, a development process that incorporates component testing throughout an iterative development process&#xD;
    offers several significant advantages:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Problems can be found and fixed in an isolated context, making them not only easier to repair, but also easier to&#xD;
        detect and diagnose.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Because testing and development are tightly coupled through the lifecycle, progress measurements are more&#xD;
        believable-progress can now be viewed in terms of how much of the project is coded and working, not just coded.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Disruptions to the schedule caused by unforeseen problems are minimized, which makes the overall schedule more&#xD;
        realistic and reduces project risk.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Although there are tremendous benefits to early testing, the practice is far from commonplace especially when it comes&#xD;
    to testing middle-tier, GUI-less components.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Why? Because it's time-consuming and tedious, and in the past the costs of overcoming these practical issues have&#xD;
    frequently outweighed the benefits. Also, since most tests are tailored for a particular component, there's little&#xD;
    opportunity for re-use. Many organizations recognize the wastefulness of building test harnesses and stubs from&#xD;
    scratch, using them, and then throwing them away project after project. They prefer to focus their limited resources in&#xD;
    other areas.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    With QualityArchitect, early testing truly becomes feasible because test harnesses and stubs are generated&#xD;
    automatically: not just once, but incrementally as the model evolves throughout development. The entire development&#xD;
    process becomes more structured, measured, and visible as results from component tests facilitate stronger entry&#xD;
    criteria to prevent premature system testing. QualityArchitect enables developers to focus on the creative aspects of&#xD;
    defining tests, so they can spend time thinking about the best way to exercise a component, instead of writing and&#xD;
    debugging test drivers and stubs. Developers and architects work closely together with the shared visual models, so&#xD;
    they naturally develop a more productive relationship with each other.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This tool mentor is applicable when running Windows 98/2000/NT 4.0.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Tool Steps&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    This tool mentor covers these main tasks associated with implementing an automated component test using&#xD;
    QualityArchitect:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Prerequisite%20steps%20for%20unit%20testing&quot;>Prerequisite steps for unit testing&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Implement%20a%20unit%20test&quot;>Implement a unit test&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Implement%20a%20scenario%20test&quot;>Implement a scenario test&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Create%20a%20stub%20component&quot;>Create a stub component&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Using%20the%20EJB%20session%20recorder&quot;>Use EJB Session Recorder&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h3>&#xD;
    1.&amp;nbsp;&amp;nbsp; &lt;a id=&quot;Prerequisite steps for unit testing&quot; name=&quot;Prerequisite steps for unit testing&quot;>Prerequisite&#xD;
    steps for unit testing&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    To generate any tests using QualityArchitect, whether they're for COM of EJB components, a Rational Project must be&#xD;
    created and configured using the Rational Administrator. This project must contain a Test Datastore to hold all of the&#xD;
    testing assets, such as test results and datapools. This is described in &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/toolmentors/configure_projects_82600862.html&quot;&#xD;
    guid=&quot;{63D2EE2A-A8D2-4A1D-BC41-8D62E9DA7CBF}&quot;>Tool Mentor: Configuring Projects Using Rational Administrator&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    2.&amp;nbsp;&amp;nbsp; &lt;a id=&quot;Implement a unit test&quot; name=&quot;Implement a unit test&quot;>Implement a unit test&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The objective of a unit test is to validate that a given operation on a given component provides the correct return&#xD;
    value for a given set of inputs. Unit tests are created off of the class specification in the logical view. The process&#xD;
    of creating and executing a unit test is comprised of three steps:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Generating unit test code&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Generating unit test data&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Executing the test and examining the results&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Generating unit test code&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The unit test code contains all instructions necessary to instantiate the component, call the operation under test, and&#xD;
    examine the returned result against a baseline.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    For COM components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the operation to test under the component interface in the Logical View.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the operation listed under the component's interface and select &lt;b>Rational Test &amp;gt; Generate Unit&#xD;
        Test&lt;/b>. If prompted, during this process you may have to log into a Rational Project.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        QualityArchitect generates Visual Basic 6 compatible code as output from this process.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    From Visual Basic, you need to first attempt to compile the code. Any compilation errors need to be examined. Under&#xD;
    certain circumstances, QualityArchitect will not be able to generate code to test operations that make extensive use of&#xD;
    complex datatypes. When this is the case, QualityArchitect will insert invalid code, which at compile time will&#xD;
    highlight the segments of code where manual coding is required. Once the code compiles, you can proceed to the next&#xD;
    step, &lt;a href=&quot;#GeneratingUnitTestData&quot;>Generating unit test data&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    For EJB components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the operation to test from the remote interface in the Logical View.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the operation and select &lt;b>Rational Test &amp;gt; Select Unit Test Template&lt;/b>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Navigate to the appropriate template for your EJB server. For WebSphere, select the websphere_remote.template in&#xD;
        the EJBWebSphereBusiness Methods folder. For Web Logic, select the weblogic_remote.template in the EJBWeb&#xD;
        LogicBusiness Methods folder.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Select &lt;b>Rational Test &amp;gt; Generate Unit Test&lt;/b>. If prompted during this process, you may have to log into a&#xD;
        Rational Project.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        QualityArchitect will generate Java code as the output from this process.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        You can use the IDE or editor of your choice to examine the Java code. Rational Rose ships with the R2 editor,&#xD;
        which can be used for this purpose.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Once in your editor, you can first attempt to compile the code. Any compilation errors need to be examined. Under&#xD;
    certain circumstances, QualityArchitect will not be able to generate code that makes extensive use of complex&#xD;
    datatypes. When this is the case, QualityArchitect will insert invalid code that will not compile to flag lines of code&#xD;
    where manual coding will be required. Once the code compiles, you can proceed to the next step, &lt;a&#xD;
    href=&quot;#GeneratingUnitTestData&quot;>Generating unit-test data&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;GeneratingUnitTestData&quot; name=&quot;GeneratingUnitTestData&quot;>Generating unit-test data&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The true measure of a successful unit test is the test data. The test code itself is completely disposable, as&#xD;
    QualityArchitect can regenerate the code at any point in time. While QualityArchitect can create the test code, it&#xD;
    cannot create meaningful test data. This is the responsibility of the analyst or the implementer. Care should be taken&#xD;
    to create test data that validates representative positive and negative tests. Test data that focuses on the boundary&#xD;
    conditions of the component's logic are excellent candidates for unit test data.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    For COM components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the operation to test under the component's interface in the Logical View.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the operation and select &lt;b>Rational Test &amp;gt; Create Datapool&lt;/b>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you've selected &lt;b>Create Datapool&lt;/b>, a Datapool Properties dialog displays. At this point, you can either&#xD;
        select &lt;b>Edit Datapool Data&lt;/b> to begin entering data or select &lt;b>Define Datapool Fields&lt;/b> to have&#xD;
        QualityArchitect generate test data for you.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h5>&#xD;
    For EJB components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the operation to test from the remote interface in the Logical View.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the operation listed under the remote interface and select Rational Test &amp;gt; Create Datapool.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Once you've selected &lt;b>Create Datapool&lt;/b>, a Datapool Properties dialog displays. At this point, you can either&#xD;
        select &lt;b>Edit Datapool Data&lt;/b> to begin entering data or select &lt;b>Define Datapool Fields&lt;/b> to have&#xD;
        QualityArchitect generate test data for you.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;Working with Datapools&quot; name=&quot;Working with Datapools&quot;>Working with Datapools&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    If you select &lt;b>Define Datapool Fields&lt;/b>, you'll have the ability to use QualityArchitect's test data generation&#xD;
    capabilities. QualityArchitect can generate various types of generic data, which are specified in the datatypes&#xD;
    drop-down list in the &lt;b>Type&lt;/b> field.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When you've selected the appropriate types, select the number of rows to generate and click &lt;b>Generate Data&lt;/b>. It's&#xD;
    quite likely that QualityArchitect will not be able to generate all of the data for you. As an example,&#xD;
    QualityArchitect will be able to generate a generic list of U.S. cities, but will not have the ability to generate a&#xD;
    list of valid, system-specific invoice numbers for an ordering system. This data must be manually entered as a datatype&#xD;
    or directly entered into a datapool. The value of creating a datatype with custom data is that QualityArchitect, from&#xD;
    that point on, will be able to generate this type of data from the Define Datapool Fields interface. If you enter the&#xD;
    data directly into the datapool, it will only be available to that specific datapool.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When you select &lt;b>Edit Datapool Data&lt;/b>, you'll directly enter in meaningful test data. There is one field for each&#xD;
    argument, as well as one field for an expected return and one field for an expected error. When you specify an error,&#xD;
    both error number and textual error messages are valid entries. If you operation requires a complex object as an&#xD;
    argument, or if it should return a complex object, you won't be able to insert that object reference in the datapool.&#xD;
    Instead, break the object down to the simple argument types required to construct an instance of the object. Use the&#xD;
    &lt;b>Insert Before&lt;/b> and &lt;b>Insert After&lt;/b> buttons to add fields to the datapool for this purpose. You'll have to&#xD;
    modify the test code to construct an instance of the object with the data provided.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Executing the test and examining the results&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Once you've created both the test code and the test data, you're ready to run your test. You can run your test from the&#xD;
    IDE or schedule the test in a TestManager Suite. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/toolmentors/executing_test_suite_AF13B74.html&quot;&#xD;
    guid=&quot;{4F5BE3FD-35F5-40E8-828B-EFE6013FCF00}&quot;>Tool Mentor: Executing a Test Suite Using Rational TestManager&lt;/a> for&#xD;
    more information on this topic.&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        As the test begins to run, you are prompted to provide a location for the test log results. Once you specify a&#xD;
        location, TestManager takes places the results of the test run in there.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        At the end of the run, TestManager displays the Test Log. To view the results of your test, select the &lt;b>Detailed&#xD;
        View&lt;/b> tab of the Log Viewer window. Expand the tree view of the results to see the details of the test run.&#xD;
        Further information can be accessed by right-clicking on any line and selecting &lt;b>Properties&lt;/b>.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h3>&#xD;
    3.&amp;nbsp;&amp;nbsp; &lt;a id=&quot;Implement a scenario test&quot; name=&quot;Implement a scenario test&quot;>Implement a scenario test&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The objective of a scenario test is to validate that a given series of operations across a given series of components&#xD;
    combine to correctly perform a collective task. Scenario tests are created from interaction diagrams, specifically&#xD;
    sequence and collaboration diagrams. The process of creating and executing a unit test is comprised of these three&#xD;
    steps:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Generating scenario test code&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Generating scenario test data&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Executing the test and examining the results&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Generating scenario test code&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The scenario test code will comprise all of the test driver code necessary to instantiate the components, call the&#xD;
    operations under test, and evaluate the results of these operations using verification points. Verification points are&#xD;
    a mechanism by which the test code can run SQL statements against a database to verify proper manipulation of the&#xD;
    underlying data.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    For EJB components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the collaboration diagram in the browser.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the diagram and select &lt;b>Rational Test &amp;gt; Select ScenarioTest Template&lt;/b>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Navigate to the appropriate template for your EJB server. For WebSphere, select the&#xD;
        websphere&lt;sub>_&lt;/sub>scenario.template in the EJBWebSphereScenario folder. For Web Logic, select the&#xD;
        weblogic_scenario.template in the EJBWeb LogicScenario folder.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Open the given sequence or collaboration diagram that models the scenario under test. It's important that the&#xD;
        messages to the components be specified for the components on the diagram that will be tested. Messages are&#xD;
        specified by double-clicking on the message line and specifying a name in the droop-down list box on the&#xD;
        &lt;b>General&lt;/b> tab. The name needs to correspond to the operation being tested. Further, these specifications can&#xD;
        be modified to include test case data.&lt;br />&#xD;
        &lt;br />&#xD;
         As an example, by default, Rose will expose the message specification as:&lt;br />&#xD;
         &lt;font face=&quot;Courier New&quot; size=&quot;2&quot;>getTransactions(customerID : String)&lt;/font>&lt;br />&#xD;
        &lt;br />&#xD;
         This specification can be modified to include a single data case as follows:&lt;br />&#xD;
         &lt;font face=&quot;Courier New&quot; size=&quot;2&quot;>getTransactions(customerID : String=&quot;BBryson&quot;)&lt;br />&#xD;
        &lt;br />&#xD;
        &lt;/font> For every scenario test, QualityArchitect automatically generates a datapool for test case data. The data&#xD;
        in the diagram will be populated in the first row. You can add additional rows from this point on.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To begin the test, right-click on the diagram in the browser and select &lt;b>Rational Test &amp;gt; Generate Scenario&#xD;
        Test&lt;/b>. If you're prompted to log into your project, do so.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A dialog displays to prompt you to select the scenario test targets. Select all of the components on the diagram&#xD;
        that will take part in the test. For each component selected, the corresponding operation specified in that&#xD;
        component's message will be invoked.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h5>&#xD;
    For COM components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Open the given sequence or collaboration diagram that models the scenario under test. It's important that the&#xD;
        messages to the components be specified for the components on the diagram that will be tested. Messages are&#xD;
        specified by double-clicking on the message line and specifying a name in the droop-down list box on the&#xD;
        &lt;b>General&lt;/b> tab. The name needs to correspond to the operation being tested. Further, these specifications can&#xD;
        be modified to include test case data.&lt;br />&#xD;
        &lt;br />&#xD;
         As an example, by default, Rose will expose the message specification as:&lt;br />&#xD;
         &lt;font face=&quot;Courier New&quot; size=&quot;2&quot;>getTransactions(customerID : String)&lt;/font>&lt;br />&#xD;
        &lt;br />&#xD;
         This specification can be modified to include a single data case as follows:&lt;br />&#xD;
         &lt;font face=&quot;Courier New&quot; size=&quot;2&quot;>getTransactions(customerID : String=&quot;BBryson&quot;)&lt;br />&#xD;
        &lt;br />&#xD;
        &lt;/font> For every scenario test, QualityArchitect automatically generates a datapool for test case data. The data&#xD;
        in the diagram will be populated in the first row. You can add additional rows from this point on.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To begin the test, right-click on the diagram in the browser and select &lt;b>Rational Test &amp;gt; Generate Scenario&#xD;
        Test&lt;/b>. If you're prompted to log into your project, do so.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A dialog displays to prompt you to select the scenario test targets. Select all of the components on the diagram&#xD;
        that will take part in the test. For each component selected, the corresponding operation specified in that&#xD;
        component's message will be invoked.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h5>&#xD;
    Verification points&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    For each operation that will be invoked and again at the end of the test, you'll be prompted to insert a verification&#xD;
    point. Verification points are used by QualityArchitect to validate that the operations took place correctly. Although&#xD;
    the verification point architecture is open and extensible, currently only the database verification point is&#xD;
    implemented. The database verification point allows you to enter some SQL to run a query. The query created will be&#xD;
    executed at test time to validate the correct manipulation of the database by the component.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;16&quot; alt=&quot;Help icon&quot; src=&quot;../../resources/helpbook.gif&quot; width=&quot;16&quot; />&amp;nbsp;You can implement your own&#xD;
    verification points, using the steps found in QualityArchitect online Help.&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select &lt;b>Yes&lt;/b> to insert a verification point.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Select the appropriate type of verification point to insert. Unless you've implemented your own verification&#xD;
        points, you must select the &lt;b>Database VP&lt;/b>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        You are presented with a Query Builder, which you'll use to establish the connection parameters to your database&#xD;
        and build the query that will be executed to validate the correct functioning of the operation being invoked. Basic&#xD;
        knowledge of the underlying database and SQL syntax is necessary to establish this connection and to create this&#xD;
        query.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    The code necessary to instantiate all components, call all operations, and run the inserted verification points is&#xD;
    output at this stage.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Generating scenario test data&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    For every scenario test generated, QualityArchitect automatically creates a datapool to contain the test data. If there&#xD;
    was data specified in the diagram, then the first row of this datapool will already be populated with that information,&#xD;
    as well as the information relating to any inserted verification points. If not, the datapool will contain only&#xD;
    information relating to verification points.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To view and edit this information, follow these steps:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        From Rose, select Tools &amp;gt; Rational Test &amp;gt; Toolbar.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        On the Toolbar, select the second toolbar item to edit your datapool. QualityArchitect will have created a datapool&#xD;
        that contains the name of the scenario diagram, which ends with a _D. The algorithm used to name the datapool is&#xD;
        sufficiently complex that it's too difficult to predict every datapool's name in this documentation.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    To edit this data, follow the same basic steps outlined in &lt;a href=&quot;#Working%20with%20Datapools&quot;>Working with&#xD;
    datapools&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Executing the test and examining the results&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Once you've created both the test code and the test data, you're ready to run your test. You can run your test from the&#xD;
    IDE or schedule the test in a TestManager Suite. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/toolmentors/executing_test_suite_AF13B74.html&quot;&#xD;
    guid=&quot;{4F5BE3FD-35F5-40E8-828B-EFE6013FCF00}&quot;>Tool Mentor: Executing a Test Suite Using Rational TestManager&lt;/a> for&#xD;
    more information on this topic.&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        As the test begins to run, you are prompted to provide a location for the test log results. Once you specify a&#xD;
        location, TestManager takes places the results of the test run in there.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        At the end of the run, TestManager displays the Test Log. To view the results of your test, select the &lt;b>Detailed&#xD;
        View&lt;/b> tab of the Log Viewer window. Expand the tree view of the results to see the details of the test run.&#xD;
        Further information can be accessed by right-clicking on any line and selecting &lt;b>Properties&lt;/b>.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    For verification points, no &lt;b>Pass&lt;/b> or &lt;b>Fail&lt;/b> indication is given on the first run, which is used to capture a&#xD;
    snapshot of the query results to be used as baseline data for future test runs.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Double-click on the verification points to display a comparator that presents the results of the query. These results&#xD;
    can be edited, so if the query didn't return the correct results, you can modify this data. All subsequent runs of this&#xD;
    test will compare their query results to those captured in this first run.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    4.&amp;nbsp;&amp;nbsp; &lt;a id=&quot;Create a stub component&quot; name=&quot;Create a stub component&quot;>Create a stub component&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Often the components being tested in a unit or scenario test rely on other components to complete their tasks. Problems&#xD;
    arise when these secondary components are not operational. Sometimes they're still in development; sometimes they're&#xD;
    buggy. Regardless, testing the primary component doesn't have to be halted until the secondary components become&#xD;
    available. Instead a stub or temporary component can replace any non-operational components for testing purposes. The&#xD;
    stub doesn't implement the functionality of the real component; it merely reacts to inputs. Stubs return a programmed&#xD;
    response for a given set of values without implementing any logic. It's a simple stimulus response relationship.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    QualityArchitect can easily create stubs for both COM and EJB components. These stubs rely on lookup tables to&#xD;
    replicate the business logic of the components they're replacing. The table, implemented as a datapool, determines what&#xD;
    the returned value should be for a given set of inputs.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The process of creating and deploying a stub is made up of these three steps:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Generating a stub component&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Generating a stub lookup table&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Deploying the stub&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Generating a stub component&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    When you generate a stub, you must generate a complete component. The, for the operations being stubbed, you need to&#xD;
    create a lookup table. A stubbed component, which contains stub code for all operations of that component, is the&#xD;
    output of the stub generation process. You cannot stub a single operation.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    For Com components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the component interface in the Logical View.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the interface and select &lt;b>Rational Test &amp;gt; Generate Stub&lt;/b>. You are prompted for the location&#xD;
        of where you want to place the generated stub code. Select this location and the code will be generated.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h5>&#xD;
    For EJB components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the bean implementation class in the Logical View.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the class and select &lt;b>Rational Test &amp;gt; Generate Stub&lt;/b>. You are prompted for the location of&#xD;
        where you want to place the generated stub code. Select this location and the code will be generated.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h4>&#xD;
    Generating a stub lookup table&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    To replicate the logic of the real component, the stub must know how the real component would react when given a set of&#xD;
    arguments. This logic is maintained in a lookup table, which specifies what value or error to return for a given set of&#xD;
    arguments. You create one lookup table for each operation on the component that is being stubbed.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    For Com components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the operation below the component interface in the Logical View.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the interface and select &lt;b>Rational Test &amp;gt; Create Lookup Table&lt;/b>. This displays the Datapool&#xD;
        Properties dialog.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To create this lookup table, follow the same basic steps outlined in &lt;a href=&quot;#Working%20with%20Datapools&quot;>Working&#xD;
        with datapools&lt;/a>. You'll use the table to specify the values or exceptions to return for a given set of&#xD;
        arguments.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h5>&#xD;
    For EJB components&#xD;
&lt;/h5>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Select the operation off of the bean implementation class in the Logical View.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Right-click on the class and select&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Rational Test &amp;gt; Create Lookup Table&lt;/b>. This displays the Datapool Properties dialog.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To create this lookup table, follow the same basic steps outlined in &lt;a href=&quot;#Working%20with%20Datapools&quot;>Working&#xD;
        with datapools&lt;/a>. You'll use the table to specify the values or exceptions to return for a given set of&#xD;
        arguments.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h4>&#xD;
    Deploying the stub&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    When the stub and lookup table have been generated, the stub must be deployed in place of the existing component. This&#xD;
    processes is environment-specific and guidance for this task is provided under the heading in QualityArchitect online&#xD;
    Help.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    5.&amp;nbsp;&amp;nbsp; &lt;a id=&quot;Using the EJB session recorder&quot; name=&quot;Using the EJB session recorder&quot;>Use the EJB session&#xD;
    recorder&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The EJB session recorder is a Java application that allows you to interact with live, deployed EJB components. This&#xD;
    functionality is only available for Enterprise JavaBeans, not for COM components.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The process for using the EJB session recorder involves these steps:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Starting an XML recording session&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Connecting to the EJB server&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Creating an instance of the bean under test&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Invoking operation on the bean&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Inserting verification points and java code&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Generating test code from the EJB session recording&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The EJB session recorder can be used in two modes: recording and non-recording. When recording, all action taken is&#xD;
    recorded to an XML log that the EJB session recorder will convert into executable java code. The code contains all&#xD;
    method calls, any inserted java code, and verification points. When operating in non-recording mode, the tool will be&#xD;
    limited to creating instances of EJBs and invoking their operations.&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        To connect to the EJB server, you need to provide the Provider URL and the InitialContextFactory to connect to the&#xD;
        EJB server. This information should be the same as that used by your client code to connect to the server. Default&#xD;
        connection information for WebSphere and Web Logic can be found in the online product documentation.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        When you've supplied your connection information, select &lt;b>Connect&lt;/b> and you're presented with a list of beans&#xD;
        deployed on that server. You can interact with one-to-many beans during a session, and you need to select the first&#xD;
        bean to interact with at this point.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Here you create an instance of the first bean under test. Select the appropriate creation method from the top half&#xD;
        of the Methods window. If the create method requires specific parameters, specify them in the &lt;b>Parameters&lt;/b>&#xD;
        section. Once complete, select &lt;b>Invoke&lt;/b> to create an instance of the bean.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        With the instance of the bean created, the EJB session recorder presents you with the various operations available&#xD;
        on that bean. You'll see the bean's own operations in the top half of the Methods window, inherited operations in&#xD;
        the bottom half. As a general rule, you won't be testing the inherited operations. Once you've selected the&#xD;
        operation to test, you can supply the required parameters for this operation in the Parameters window.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If the parameter is a complex object, there will be a button called New. This opens a subsequent window where&#xD;
        you're presented with a dialog that allows you to create an instance of the required object. The window shows all&#xD;
        constructors and the required arguments to construct an instance of the object. When you've supplied the&#xD;
        constructor information, you need to name the object so it can be referenced later during the recording, if&#xD;
        necessary.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        There is value in assigning names to parameters if these values will be used again during the session recording. If&#xD;
        you provide a name, QualityArchitect will be able to populate the value in any parameter field when you right-click&#xD;
        that field.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        When you click &lt;b>Invoke&lt;/b>, the operation is called with the provided parameters. The return value is shown in&#xD;
        the &lt;b>Last Return Value&lt;/b> field. If this value is required as the input to a subsequent call, it can be dragged&#xD;
        and dropped into the required field. You can also right-click it when the mouse is pointing at the parameter field&#xD;
        where the value will be inserted. To determine what values to present on the right-click menu, the EJB session&#xD;
        recorder matches the type of the parameter to the previous types that have been used during testing.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        At any point in the session, you can insert java code or verification points from the &lt;b>Insert&lt;/b> menu. The&#xD;
        verification points are the same as those used when generating scenario test code. Similarly, java code can be&#xD;
        inserted to perform any additional processing.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If you are in record mode, you can convert the XML-based recording to java code when all steps of your test are&#xD;
        complete. Click &lt;b>Stop&lt;/b> to perform this action. You are prompted to convert the XML code to java code, and&#xD;
        you'll need to provide a session name and a script name. Java code, which you can execute to replicate the steps&#xD;
        taken during your recording, is the output of this process.&amp;nbsp;&#xD;
    &lt;/li>&#xD;
&lt;/ol></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
