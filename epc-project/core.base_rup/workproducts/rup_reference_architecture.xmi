<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ArtifactDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1e1icNnmEdmO6L4XMImrsA" name="rup_reference_architecture,{855CE09A-D297-4373-BEEA-D38B8AB348DA}" guid="_1e1icNnmEdmO6L4XMImrsA" changeDate="2005-10-11T09:56:37.930-0700" version="7.1.0">
  <mainDescription>&lt;h4>&#xD;
    Organization of Assets&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The organization which owns the Reference Architecture assets will need to decide how the assets are to be classified&#xD;
    and organized for easy retrieval by the software architect, by matching selection criteria for the new system. Although&#xD;
    the creation and storage of Reference Architectures is currently outside the scope of the RUP, one suggestion is that&#xD;
    architectures be organized around the idea of &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_concepts/guidances/termdefinitions/domain_D8238B93.html&quot; guid=&quot;_yHEVYdnmEdmO6L4XMImrsA&quot;>Term&#xD;
    Definition: domain&lt;/a>, where a domain is a subject area that defines knowledge and concepts for some aspect of a&#xD;
    system, or for a family of systems. Here we are allowing use of the term 'domain' at levels below that of the&#xD;
    application. This usage differs slightly from some definitions - for example, that presented in [&lt;a&#xD;
    href=&quot;#HOF99&quot;>HOF99&lt;/a>] - but aligns well with that presented in [&lt;a href=&quot;#LMFS96&quot;>LMFS96&lt;/a>]:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;i>&quot;&lt;b>Product-Line Domain&lt;/b>: A bounded group of capabilities - present and/or future - defined to facilitate&#xD;
    communication, analysis and engineering in pursuit of identifying, engineering and managing commonality across a&#xD;
    product-line. Such domains might include closely related groups of end-user systems, commonly used functions across&#xD;
    multiple systems, or widely applicable groupings of underlying services.&quot;&lt;/i>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This definition includes the notion that things used to compose systems may themselves belong to a domain worthy of&#xD;
    study in its own right. The figure below, taken from [&lt;a href=&quot;#LMFS96&quot;>LMFS96&lt;/a>], illustrates this principle.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;191&quot; alt=&quot;Horizontal and vertical domains for the U.S. Army&quot; src=&quot;resources/domains.gif&quot; width=&quot;381&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;b>Horizontal and Vertical Domains for the US Army&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    This figure shows the major system families, Information Systems, Command &amp;amp; Control, and Weapon Systems, each with&#xD;
    some wholly contained vertical domains, and horizontal domains that cut across these and also across system families.&#xD;
    Thus, Real-Time Scheduling concepts are applicable to the Tactical Domain of Command &amp;amp; Control and all vertical&#xD;
    domains of Weapon Systems. It probably makes sense therefore, to solve real-time scheduling problems once for all these&#xD;
    domains, and treat the knowledge and assets so developed as a separate domain, which then has an association to, for&#xD;
    example, Electronic Warfare, but not to Personnel Information Systems.&#xD;
&lt;/p>&#xD;
&lt;h4 align=&quot;left&quot;>&#xD;
    Contents&#xD;
&lt;/h4>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    The Reference Architecture has the same form as the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
    guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Artifact: Software Architecture Document&lt;/a> and the associated models,&#xD;
    &lt;i>stripped of project specific references, or having project references and characteristics made generic,&lt;/i> so that&#xD;
    the Reference Architecture may be classified appropriately in the asset base. Typical models associated with the&#xD;
    Software Architecture Document (SAD) are a Use-Case Model, Design Model, Implementation Model and Deployment Model.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    Access to the SAD and associated models gives several points of entry for the software architect, who could choose to&#xD;
    use just the conceptual or logical parts of the architecture (if the organization's reuse policy allows this). At the&#xD;
    other extreme, the software architect may be able to take from the asset base complete working subsystems, and a&#xD;
    Deployment Model at the physical level (that is, a complete hardware and network blueprint).&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    Other supporting artifacts are needed to make the architectural assets usable.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        &lt;p align=&quot;left&quot;>&#xD;
            The Use-Case Model describes the behavior of the architecture but the software architect will also need to know&#xD;
            its non-functional qualities. These two - the Use-Case Model and non-functional requirements - may previously&#xD;
            have been captured in a Software Requirements Specification. From this the software architect will be able to&#xD;
            determine how well the Reference Architecture meets current requirements.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p align=&quot;left&quot;>&#xD;
            The use, and more particularly, the modification of the architecture will need the same guidance as the&#xD;
            original development. For example, the software architect will need to know what rules were applied in the&#xD;
            formation of the Reference Architecture, and how difficult it will be to modify interfaces. Access to the&#xD;
            design guidelines associated with the Reference Architecture can help answer these questions.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p align=&quot;left&quot;>&#xD;
            (Optional) Reviewing any relevant existing Test Plans may also prove useful. These Test Plans will inform the&#xD;
            architect of the test and evaluation strategies previously used to test similar architectures, and as such are&#xD;
            likely to provide insight into potential weaknesses in the architecture.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p align=&quot;left&quot;>&#xD;
            (Optional) Reviewing any relevant existing Test Automation Architectures and Test Interface Specifications may&#xD;
            prove useful. These artifacts inform the architect of likely requests that may be made of the architecture to&#xD;
            facilitate testing.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ol></mainDescription>
  <purpose>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;Purpose&quot; name=&quot;Purpose&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    Reference Architecture work products are part of an organization's reusable asset base. Their purpose is to form a&#xD;
    starting point for architectural development. They may range from ready-made &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/termdefinitions/architectural_pattern_E2E8EB79.html&quot;&#xD;
    guid=&quot;_x7JZRtnmEdmO6L4XMImrsA&quot;>architectural patterns&lt;/a>, &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/termdefinitions/architectural_mechanism_8730DF1F.html&quot;&#xD;
    guid=&quot;_x7JZQ9nmEdmO6L4XMImrsA&quot;>architectural mechanisms&lt;/a> and &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/termdefinitions/framework_96F80772.html&quot; guid=&quot;_yJmE89nmEdmO6L4XMImrsA&quot;>frameworks&lt;/a>, to&#xD;
    complete systems, with known characteristics, proven in use. They may be applicable generally, or for a broad class of&#xD;
    systems spanning domains, or have a narrower, domain-specific, focus.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The use of tested reference architectures is an effective way to address many non-functional requirements, particularly&#xD;
    quality requirements, by selecting existing reference architectures, which are known through usage to satisfy those&#xD;
    requirements. Reference Architectures may exist or be used at different levels of abstraction and from different&#xD;
    viewpoints. These correspond to the 4+1 Views (see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/concepts/software_architecture_4269A354.html#A%20Typical%20Set%20of%20Architectural%20Views&quot;&#xD;
     guid=&quot;3.066252221588648E-305&quot;>&quot;A Typical Set of Architectural Views&quot;&lt;/a>). In this way, the software architect can&#xD;
    select what fits best-just architectural design, or design and implementation, to varying degrees of completion.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Often, a Reference Architecture is defined not to include instances of the components that will be used to construct&#xD;
    the system-if it does it becomes a &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/termdefinitions/product-line_architecture_ED8F6B10.html&quot;&#xD;
    guid=&quot;_yRDX3NnmEdmO6L4XMImrsA&quot;>product-line architecture&lt;/a>-but this is not a hard and fast distinction. In the&#xD;
    Rational Unified Process (RUP), we allow the notion of Reference Architecture to include references to existing,&#xD;
    reusable components (that is, implementations).&#xD;
&lt;/p></purpose>
  <briefOutline>&lt;a id=&quot;BriefOutline&quot; name=&quot;BriefOutline&quot;>&lt;/a> &#xD;
&lt;h4>&#xD;
    Organization of Assets&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The organization which owns the Reference Architecture assets will need to decide how the assets are to be classified&#xD;
    and organized for easy retrieval by the software architect, by matching selection criteria for the new system. Although&#xD;
    the creation and storage of Reference Architectures is currently outside the scope of the RUP, one suggestion is that&#xD;
    architectures be organized around the idea of &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_concepts/guidances/termdefinitions/domain_D8238B93.html&quot; guid=&quot;_yHEVYdnmEdmO6L4XMImrsA&quot;>domains&lt;/a>,&#xD;
    where a domain is a subject area that defines knowledge and concepts for some aspect of a system, or for a family of&#xD;
    systems. Here we are allowing use of the term 'domain' at levels below that of the application. This usage differs&#xD;
    slightly from some definitions-for example, that presented in [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/customcategories/references_56F06DFD.html#HOF99&quot; guid=&quot;7.755968586980351E-308&quot;>HOF99&lt;/a>]-but aligns&#xD;
    well with that presented in [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/customcategories/references_56F06DFD.html#LMFS96&quot; guid=&quot;7.755968586980351E-308&quot;>LMFS96&lt;/a>]:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;i>&quot;&lt;b>Product-Line Domain&lt;/b>: A bounded group of capabilities - present and/or future - defined to facilitate&#xD;
    communication, analysis and engineering in pursuit of identifying, engineering and managing commonality across a&#xD;
    product-line. Such domains might include closely related groups of end-user systems, commonly used functions across&#xD;
    multiple systems, or widely applicable groupings of underlying services.&quot;&lt;/i>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This definition includes the notion that things used to compose systems may themselves belong to a domain worthy of&#xD;
    study in its own right. The figure below, taken from [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/customcategories/references_56F06DFD.html#LMFS96&quot; guid=&quot;7.755968586980351E-308&quot;>LMFS96&lt;/a>],&#xD;
    illustrates this principle.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/domains.gif&quot; alt=&quot;Horizontal and Vertical US Army Domains&quot; width=&quot;381&quot; height=&quot;191&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;b>Horizontal and Vertical Domains for the US Army&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    This figure shows the major system families, Information Systems, Command &amp;amp; Control, and Weapon Systems, each with&#xD;
    some wholly contained vertical domains, and horizontal domains that cut across these and also across system families.&#xD;
    Thus, Real-Time Scheduling concepts are applicable to the Tactical Domain of Command &amp;amp; Control and all vertical&#xD;
    domains of Weapon Systems. It probably makes sense therefore, to solve real-time scheduling problems once for all these&#xD;
    domains, and treat the knowledge and assets so developed as a separate domain, which then has an association to, for&#xD;
    example, Electronic Warfare, but not to Personnel Information Systems.&#xD;
&lt;/p>&#xD;
&lt;h4 align=&quot;left&quot;>&#xD;
    Contents&#xD;
&lt;/h4>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    The Reference Architecture has the same form as the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
    guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Artifact: Software Architecture Document&lt;/a> and the associated models,&#xD;
    &lt;i>stripped of project specific references, or having project references and characteristics made generic,&lt;/i> so that&#xD;
    the Reference Architecture may be classified appropriately in the asset base. Typical models associated with the&#xD;
    Software Architecture Document (SAD) are a Use-Case Model, Design Model, Implementation Model and Deployment Model.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    Access to the SAD and associated models gives several points of entry for the software architect, who could choose to&#xD;
    use just the conceptual or logical parts of the architecture (if the organization's reuse policy allows this). At the&#xD;
    other extreme, the software architect may be able to take from the asset base complete working subsystems, and a&#xD;
    Deployment Model at the physical level (that is, a complete hardware and network blueprint).&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    Other supporting work products are needed to make the architectural assets usable.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        &lt;p align=&quot;left&quot;>&#xD;
            The Use-Case Model describes the behavior of the architecture but the software architect will also need to know&#xD;
            its non-functional qualities. These two-the Use-Case Model and non-functional requirements-may previously have&#xD;
            been captured in a Software Requirements Specification. From this the software architect will be able to&#xD;
            determine how well the Reference Architecture meets current requirements.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p align=&quot;left&quot;>&#xD;
            The use, and more particularly, the modification of the architecture will need the same guidance as the&#xD;
            original development. For example, the software architect will need to know what rules were applied in the&#xD;
            formation of the Reference Architecture, and how difficult it will be to modify interfaces. Access to the&#xD;
            design guidelines associated with the Reference Architecture can help answer these questions.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p align=&quot;left&quot;>&#xD;
            (Optional) Reviewing any relevant existing Test Plans may also prove useful. These Test Plans will inform the&#xD;
            architect of the test and evaluation strategies previously used to test similar architectures, and as such are&#xD;
            likely to provide insight into potential weaknesses in the architecture.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p align=&quot;left&quot;>&#xD;
            (Optional) Reviewing any relevant existing Test Automation Architectures and Test Interface Specifications may&#xD;
            prove useful. These work products inform the architect of likely requests that may be made of the architecture&#xD;
            to facilitate testing.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ol></briefOutline>
  <representationOptions>UML Representation: A number of relevant architectural views: Use-Case, Logical, Process, Deployment, Implementation, Data.&#xD;
&#xD;
&lt;p>&#xD;
    &lt;a id=&quot;Tailoring&quot; name=&quot;Tailoring&quot;>&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Unless the system is completely unprecedented, Reference Architectures should be examined for applicability (to the&#xD;
    domain and type of development) if they exist and are accessible to the development organization. The &lt;i>creation&lt;/i>&#xD;
    of Reference Architectures is an issue to be addressed at the organization level. It's certainly possible to cut back&#xD;
    on the contents list above and still achieve some benefits from architectural reuse. For example, it is possible to&#xD;
    omit the test model, although tests would have to be rewritten if the architecture is modified. At a minimum one might&#xD;
    expect a design model and some associated behavioral description (perhaps the Use-Case Model). Any less and it's&#xD;
    difficult to call the asset a Reference Architecture. It could still be a valid pattern.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></representationOptions>
</org.eclipse.epf.uma:ArtifactDescription>
