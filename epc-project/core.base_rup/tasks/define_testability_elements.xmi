<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:TaskDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_2qrqgNnmEdmO6L4XMImrsA" name="define_testability_elements,{CDA7EC1B-2D50-46BE-A3BA-C621EAF22D84}" guid="_2qrqgNnmEdmO6L4XMImrsA" changeDate="2005-11-04T07:59:16.731-0800" version="7.1.0">
  <sections xmi:id="_Ws9UMNnnEdmO6L4XMImrsA" name=" For Each Required Target Test Item, Identify Relationships with Test Mechanisms " guid="_Ws9UMNnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;IdentifyTargetMechanismItems&quot; name=&quot;IdentifyTargetMechanismItems&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose:&lt;/b>&amp;nbsp;&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To gain an understanding of the test mechanism support needed by the target test items.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    For each target test item, review the list of test mechanisms and identify the ones that could provide support. Analyze&#xD;
    how close the selected test mechanisms are to provide a complete test solution and how can they be adapted to become a&#xD;
    better fit. If no candidates are found or the adaptation effort is significant, define new test mechanisms and try to&#xD;
    find a balance between specificity and reusability.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_Ws9UMdnnEdmO6L4XMImrsA" name=" Identify Dynamic Elements and Events of the System " guid="_Ws9UMdnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;IdentifyDynamicElementsEvents&quot; name=&quot;IdentifyDynamicElementsEvents&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose:&lt;/b>&amp;nbsp;&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To gain an understanding of the dynamic and runtime aspects of the system.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
     Using the available software requirements and design information, identify the dynamic elements and events of the&#xD;
    system. Using the use-case, design, implementation and deployment models, you can identify relevant items such as&#xD;
    control classes, processes, threads and events. Places to begin your research include classes stereotyped as&#xD;
    &amp;lt;&amp;lt;control&amp;gt;&amp;gt;, use-case realizations, and elements described in the process architectural view or the&#xD;
    implementation model stereotyped as &amp;lt;&amp;lt;process&amp;gt;&amp;gt; or &amp;lt;&amp;lt;thread&amp;gt;&amp;gt;.&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    In relation to the constraints imposed by the test environment, define the physical requirements&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_Ws9UMtnnEdmO6L4XMImrsA" name=" Identify System Boundaries and Interfaces " guid="_Ws9UMtnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;IdentifyBoundariesAndInterfaces&quot; name=&quot;IdentifyBoundariesAndInterfaces&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose:&lt;/b>&amp;nbsp;&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To gain an understanding of the responsibilities of the system as a service provider, and the dependencies&#xD;
                of the system as a client.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Another useful group of elements to examine are the Interfaces of the system, most importantly those that relate to&#xD;
    actors external to the boundaries of the system. Using the Design and Implementation Models, look for elements defined&#xD;
    with the stereotype &amp;lt;&amp;lt;interface&amp;gt;&amp;gt;. Also examine the models for the existence of classes stereotyped as&#xD;
    &amp;lt;&amp;lt;boundary&amp;gt;&amp;gt;.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As a tester, it is useful to explore past these system boundaries to gain an understanding of the expectations of the&#xD;
    related systems, both client and service providers. This will give you a more thorough understanding of what is needed&#xD;
    both in terms of validation of the interfaces and in terms of the test infrastructure required to test and possibly&#xD;
    simulate these interfaces.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_Ws9UM9nnEdmO6L4XMImrsA" name=" Identify Test Infrastructure Elements " guid="_Ws9UM9nnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;IdentifyTestInfrastructure&quot; name=&quot;IdentifyTestInfrastructure&quot;>&lt;/a> &#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;100%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;5%&quot;>&#xD;
                    &lt;b>Purpose:&lt;/b>&amp;nbsp;&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;95%&quot;>&#xD;
                    To identify the essential elements of the test effort that will enable the required testing to be&#xD;
                    performed.&amp;nbsp;&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    For an iterative test effort to be successful, it is important to identify and maintain an appropriate infrastructure.&#xD;
    Without an infrastructure to help maintain it, the test effort can quickly become unmaintainable and unusable. While&#xD;
    more obviously relevant to the automated test effort, test infrastructure is also an important concern for the manual&#xD;
    test effort.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Consider the dynamic elements and events in the system; what dependencies will these place on the implementation of&#xD;
    individual tests? Look for opportunities to uncouple the dependencies between individual tests and manage them through&#xD;
    common points of control that provide a layer of indirection. Common areas to explore for dependencies include test&#xD;
    navigation, test data use and system state changes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Using the information you have gathered, consider what requirements will govern the test infrastructure, and what&#xD;
    facilities it will need to provide to enable a successful test approach.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Sub-topics:&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#FacilitateCommonScenarios&quot;>Facilitate common test scenarios&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#FacilitateTestDataDependencies&quot;>Facilitate test data dependencies&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#FacilitateTestStateDependencies&quot;>Facilitate test state dependencies&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#FacilitateDerivedTestDataValues&quot;>Facilitate derived test data values&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#FacilitateCommonNavigationPaths&quot;>Facilitate common test navigation paths&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;FacilitateCommonScenarios&quot; name=&quot;FacilitateCommonScenarios&quot;>Facilitate common test scenarios&lt;/a> &lt;a&#xD;
    href=&quot;#IdentifyTestInfrastructure&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;./../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Some tests have a common structure to the scenario or procedure followed when they are executed, but the same procedure&#xD;
    needs to be conducted many times against different test target items. In the case of test automation, it can be useful&#xD;
    to create common test scripts or utility functions that can be reused in many different contexts to undertake these&#xD;
    common test scenarios in an efficient way. This provides a central point of modification if the test scenario needs to&#xD;
    be altered. Examples include conducting standard boundary tests on appropriate classes of interface elements, and&#xD;
    validating UI elements for adherence to UI design standards.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;FacilitateTestDataDependencies&quot; name=&quot;FacilitateTestDataDependencies&quot;>Facilitate test data dependencies&lt;/a> &lt;a&#xD;
    href=&quot;#IdentifyTestInfrastructure&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;./../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot;&#xD;
    border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    When tests are to be conducted in a given test environment configuration, there is the potential for conflicts in the&#xD;
    test data values that are used. This problem is compounded when the environment is shared by multiple test team&#xD;
    members. Consider using a data-driven approach that uncouples test data values from the test scripts that use them, and&#xD;
    provide a central point of collection and modification of the test data. This provides two key benefits; it gives&#xD;
    visibility of the test data to all test team members, allowing them to avoid potential conflicts in test data use, and&#xD;
    it provides a central point of modification for the test data when it needs to be updated.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;FacilitateTestStateDependencies&quot; name=&quot;FacilitateTestStateDependencies&quot;>Facilitate test state dependencies&lt;/a>&#xD;
    &lt;a href=&quot;#IdentifyTestInfrastructure&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;./../../core.base_rup/resources/top.gif&quot;&#xD;
    width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Most tests require the system to be in a specific given state before they are executed, and should return the system to&#xD;
    a specific known state when they complete. Common dependencies involve security rights (function or data), dynamic or&#xD;
    context sensitive data (e.g. system dates, order numbers, user id preferences etc.), data expire cycles (e.g. security&#xD;
    passwords, product expire etc.). Some tests are highly dependent on each other; for example, one test may create a&#xD;
    unique order number and a subsequent test may need to dispatch the same order number.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A common solution is to use test suites to sequence dependent tests in the correct system state order. The test suites&#xD;
    can then be coupled with appropriate system recovery and set up utilities. For automated test efforts, some solutions&#xD;
    may involve using centralized storage of dynamic system data and the use of variables within the test scripts that&#xD;
    reference the centralized information.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;FacilitateDerivedTestDataValues&quot; name=&quot;FacilitateDerivedTestDataValues&quot;>Facilitate derived test data values&lt;/a>&#xD;
    &lt;a href=&quot;#IdentifyTestInfrastructure&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot; src=&quot;./../../core.base_rup/resources/top.gif&quot;&#xD;
    width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Tests sometimes need to calculate or derive appropriate data values from one or more aspects of the runtime system&#xD;
    state. This applies to test data values for both input and expected results. Consider developing utilities that&#xD;
    calculate the derived data values, simplifying test execution and eliminating potential inaccuracies introduced through&#xD;
    human error. Where possible, develop these utilities so that they can be utilized by both manual or automated test&#xD;
    efforts.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;FacilitateCommonNavigationPaths&quot; name=&quot;FacilitateCommonNavigationPaths&quot;>Facilitate common test navigation&#xD;
    paths&lt;/a> &lt;a href=&quot;#IdentifyTestInfrastructure&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;./../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    For test automation, you should consider isolating common navigation sequences and implementing them using centralized&#xD;
    utility functions or test scripts. These common navigation sequences can then be reused in many places, providing a&#xD;
    central point of modification if the navigation subsequently changes. These common navigation aids simply navigate the&#xD;
    application from one point to another; they typically don't perform any tests themselves other than to verify their&#xD;
    start and end states.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_WtHFMNnnEdmO6L4XMImrsA" name=" Identify Test-Specific Design Needs " guid="_WtHFMNnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;IdentifyTestDesignNeeds&quot; name=&quot;IdentifyTestDesignNeeds&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose:&lt;/b>&amp;nbsp;&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To identify the needs of the test discipline that will place potential constraints on the software&#xD;
                engineering process, the software architecture and the corresponding design and implementation.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Especially where test automation is concerned, it's likely that the test implementation and assessment needs that will&#xD;
    place some constraints on both the way the development team enacts the software engineering process, and on the&#xD;
    architecture and design of the software. It's important that the software development team are not unduly hampered in&#xD;
    their core development work and that the test team have the ability to perform the necessary testing. See &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/tasks/obtain_testability_commitment_90A71C20.html&quot;&#xD;
    guid=&quot;{4052BFA5-036E-4BBE-B344-4BF5D81A4DD6}&quot;>Task: Obtain Testability Commitment&lt;/a> for information about presenting&#xD;
    the needs of the test team to the development team and finding workable solutions that satisfy the needs of all&#xD;
    disciplines.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Using the information you have gathered, consider what requirements the test effort will place on the development&#xD;
    effort.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Sub-topics:&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#IdentifyDesignTestInterfaces&quot;>Identify test interfaces&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#IdentifyDesignInbuiltTests&quot;>Identify inbuilt test functions&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#IdentifyDesignTestConstraints&quot;>Identify test design constraints&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;IdentifyDesignTestInterfaces&quot; name=&quot;IdentifyDesignTestInterfaces&quot;>Identify test interfaces&lt;/a> &lt;a&#xD;
    href=&quot;#IdentifyTestDesignNeeds&quot;>&lt;img src=&quot;./../../core.base_rup/resources/top.gif&quot; alt=&quot;To top of page&quot; border=&quot;0&quot; width=&quot;26&quot;&#xD;
    height=&quot;20&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Consider the interfaces identified; are there additional requirements the test effort will need included in the&#xD;
    software design and subsequently exposed in the implementation? In some cases, additional interfaces will be required&#xD;
    specifically to support the test effort, or existing interfaces will require additional operating modes or modified&#xD;
    message signatures (changes to input and return parameters).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In relation to the target deployment environments (as captured in the test environment configurations) and the&#xD;
    development schedule itself, identify the constraints and dependencies placed on the test effort. These dependencies&#xD;
    may necessitate the provision of stubs to simulate elements of the environment that will not be available or are too&#xD;
    resource prohibitive to establish for testing purposes, or to provide the opportunity for the early testing of&#xD;
    components of the partially completed system.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;IdentifyDesignInbuiltTests&quot; name=&quot;IdentifyDesignInbuiltTests&quot;>Identify inbuilt test functions&lt;/a> &lt;a&#xD;
    href=&quot;#IdentifyTestDesignNeeds&quot;>&lt;img src=&quot;./../../core.base_rup/resources/top.gif&quot; alt=&quot;To top of page&quot; border=&quot;0&quot; width=&quot;26&quot;&#xD;
    height=&quot;20&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Some tests are potentially valuable but prohibitively expensive to implement as true black-box tests. Furthermore, in&#xD;
    high-reliability environments it is important to be able to test for and isolate faults as quickly as possible to&#xD;
    enable fast resolution. In these cases, it can be useful to build tests directly into the executable software itself.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are different approaches that can be taken to achieve this; two of the most common include built-in self tests&#xD;
    where the software uses redundant processing cycles to perform self-integrity tests, and diagnostic routines that can&#xD;
    be performed when the software is sent a diagnostic event message, or when the system is configured to run with&#xD;
    diagnostic routines enabled.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;IdentifyDesignTestConstraints&quot; name=&quot;IdentifyDesignTestConstraints&quot;>Identify test design constraints&lt;/a> &lt;a&#xD;
    href=&quot;#IdentifyTestDesignNeeds&quot;>&lt;img src=&quot;./../../core.base_rup/resources/top.gif&quot; alt=&quot;To top of page&quot; border=&quot;0&quot; width=&quot;26&quot;&#xD;
    height=&quot;20&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Some of the design and implementation choices of the development team will either enable or inhibit the test effort.&#xD;
    While some of these choices are unavoidably necessary, there are many smaller decisions-especially in the area of&#xD;
    implementation-that have minimal impact on the development team but significant impact on the test team.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Areas to consider include: Use of standard, recognized communication protocols; Use of UI implementation components&#xD;
    that can be recognized by test automation tools; Adhering to UI design rules including the naming of UI elements;&#xD;
    Consistent use of UI navigation conventions.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_Wt2sENnnEdmO6L4XMImrsA" name=" Define Software Testability Requirements " guid="_Wt2sENnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;DefineSoftwareTestability&quot; name=&quot;DefineSoftwareTestability&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose:&lt;/b>&amp;nbsp;&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To specify the requirements for the software functions needed to support the implementation and execution&#xD;
                of tests.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Using the previous work performed on the task, define the test-specific requirements and constraints that should be&#xD;
    considered in the software design and implementation.&lt;br />&#xD;
    &lt;br />&#xD;
     It is important to clearly explain to the development team the reasons why test-specific features are required to be&#xD;
    to built into the software. Key reasons will typically fall into one of the following areas:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        To enable tests to be implemented-both manual and automated-by providing an interface between the target test item&#xD;
        and either the manual or automated test. This is typically most relevant as a test automation concern to help&#xD;
        overcome the limitations of test automation tools in being able to access the software application for both&#xD;
        information input and output.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To enable built-in self-tests to be conducted by the developed software itself.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To enable target test items to be isolated from the rest of the developed system and tested.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Test-specific features built into the software need to strike a balance between the value of a built-in test feature&#xD;
    and the effort necessary to implement and test it. Examples of built-in test features include producing audit logs,&#xD;
    self-diagnostic functions and interfaces to interrogate the value of internal variables.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another common use of test specific functionality is during integration work where there is the need to provide stubs&#xD;
    for components or subsystems that are not yet implemented or incorporated. There are two main implementation styles&#xD;
    used for stubs:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Stubs and drivers that are simply &quot;dummies&quot; with no functionality other than being able to provide a specific&#xD;
        predefined value (or values) as either input or as a return value.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Stubs and drivers that are more intelligent and can &quot;simulate&quot; or approximate more complex behavior.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    This second style of stub also provides a powerful means of isolating components or groups of components from the rest&#xD;
    of the system, thus providing flexibility in the implementation and execution of tests. As with the earlier comment&#xD;
    about test-specific features, a balance between the value of a complex stub and the effort necessary to implement and&#xD;
    test the stub needs to be considered. Use this second style prudently for two reasons; first, it takes more resources&#xD;
    to implement, and second; it is easier to overlook the existence of the stub and forget to subsequently remove it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Record your findings in terms of test-specific requirements on the design and implementation models directly, or using&#xD;
    one or more test interface specifications.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_Wt2sEdnnEdmO6L4XMImrsA" name=" Define Test Infrastructure " guid="_Wt2sEdnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;DefineSoftwareTestability&quot; name=&quot;DefineSoftwareTestability&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose:&lt;/b>&amp;nbsp;&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To specify the requirements for the test infrastructure needed to support the implementation and execution&#xD;
                of tests.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Using the previous work performed on the task, define the test infrastructure that is required to support test&#xD;
    implementation and execution.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Remember that you are defining the implementation features of the infrastructure; The main objective is to define the&#xD;
    various parts of the solution that will implement that infrastructure.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Sub-topics:&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#AutomationInfrastructureElements&quot;>Test automation elements&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#ManualInfrastructureElements&quot;>Manual test elements&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;AutomationInfrastructureElements&quot; name=&quot;AutomationInfrastructureElements&quot;>Test automation elements&lt;/a> &lt;a&#xD;
    href=&quot;#DefineSoftwareTestability&quot;>&lt;img src=&quot;./../../core.base_rup/resources/top.gif&quot; alt=&quot;To top of page&quot; border=&quot;0&quot; width=&quot;26&quot;&#xD;
    height=&quot;20&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Key requirements or features of the test automation infrastructure include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Navigation model: common approaches are round-trip, segmented or hybrid approaches. Other alternatives include&#xD;
        using an Action-Word framework or screen navigation tables&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        External Data Access: a method to access data externally from the test instructions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Error Reporting and Recovery: common error handling routines and Test Suite recovery execution wrappers&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Security and Access Profiles: Automated Test Execution User Ids&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The ability for the software to conduct self-tests&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Record your decisions as definitions in the implementation sections of the Test Automation Architecture, process&#xD;
    guidance in one or more Test Guidelines or as Test Scripts, Test Suites, or test library utility routines. See &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/workproducts/rup_test_automation_architecture_650DD06A.html&quot;&#xD;
    guid=&quot;{B5B77528-E14B-43CA-BC73-D64A90A17E2D}&quot;>Artifact: Test Automation Architecture&lt;/a> for further suggestions.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;ManualInfrastructureElements&quot; name=&quot;ManualInfrastructureElements&quot;>Manual test elements&lt;/a> &lt;a&#xD;
    href=&quot;#DefineSoftwareTestability&quot;>&lt;img src=&quot;./../../core.base_rup/resources/top.gif&quot; alt=&quot;To top of page&quot; border=&quot;0&quot; width=&quot;26&quot;&#xD;
    height=&quot;20&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Key requirements or features of the manual test infrastructure include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Test Data Repository: a common repository for the definition of test data.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Restoration and Recovery: a method to restore or recover the test environment configuration to a known state.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To enable target test items to be isolated from the rest of the developed system and tested.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Record your decisions as process guidance in one or more &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot;&#xD;
    guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>Artifact: Project-Specific Guidelines&lt;/a>.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_WuAdENnnEdmO6L4XMImrsA" name=" Evaluate and Verify Your Results " guid="_WuAdENnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;EvaluateResults&quot; name=&quot;EvaluateResults&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose:&lt;/b>&amp;nbsp;&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To verify that the task has been completed appropriately and that the resulting work products are&#xD;
                acceptable.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Now that you have completed the work, it is beneficial to verify that the work was of sufficient value, and that you&#xD;
    did not simply consume vast quantities of paper. You should evaluate whether your work is of appropriate quality, and&#xD;
    that it is complete enough to be useful to those team members who will make subsequent use of it as input to their&#xD;
    work. Where possible, use the checklists provided in RUP to verify that quality and completeness are &quot;good enough&quot;.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Have the people performing the downstream tasks that rely on your work as input take part in reviewing your interim&#xD;
    work. Do this while you still have time available to take action to address their concerns. You should also evaluate&#xD;
    your work against the key input work products to make sure you have represented them accurately and sufficiently. It&#xD;
    may be useful to have the author of the input work product review your work on this basis.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Try to remember that that RUP is an iterative delivery process and that in many cases work products evolve over time.&#xD;
    As such, it is not usually necessary-and is often counterproductive-to fully-form a work product that will only be&#xD;
    partially used or will not be used at all in immediately subsequent work. This is because there is a high probability&#xD;
    that the situation surrounding the work product will change-and the assumptions made when the work product was created&#xD;
    proven incorrect-before the work product is used, resulting in wasted effort and costly rework. Also avoid the trap of&#xD;
    spending too many cycles on presentation to the detriment of content value. In project environments where presentation&#xD;
    has importance and economic value as a project deliverable, you might want to consider using an administrative resource&#xD;
    to perform presentation tasks.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></sectionDescription>
  </sections>
  <purpose>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_test_automation_architecture__elements_of&quot;&#xD;
name=&quot;XE_test_automation_architecture__elements_of&quot;>&lt;/a>&lt;a id=&quot;XE_test__testability__elements_of&quot;&#xD;
name=&quot;XE_test__testability__elements_of&quot;>&lt;/a>&lt;a id=&quot;XE_test__infrastructure__elements_of&quot;&#xD;
name=&quot;XE_test__infrastructure__elements_of&quot;>&lt;/a>&lt;a id=&quot;XE_test_interface_specification__definition_of&quot;&#xD;
name=&quot;XE_test_interface_specification__definition_of&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    The purpose of this task is to:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Identify the elements needed to support the target test items&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Identify the physical elements of the test implementation infrastructure required to enable testing under each Test&#xD;
        Environment Configuration&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Define the software design requirements that will need to be met to enable the software to be physically testable&#xD;
    &lt;/li>&#xD;
&lt;/ul></purpose>
</org.eclipse.epf.uma:TaskDescription>
