<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:TaskDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1s2JQtnmEdmO6L4XMImrsA" name="database_design,{2E74A414-49F5-4F27-BFCB-AA2DAC675F58}" guid="_1s2JQtnmEdmO6L4XMImrsA" changeDate="2005-07-25T18:36:15.522-0700" version="7.1.0">
  <copyrightStatement href="uma://{1F4FEA6F-AF12-40BF-94BE-D316CE25314B}#_egIacP1mEdm9-ZPZADkvIg"/>
  <mainDescription>&lt;p>&#xD;
    The steps presented in this task assume that the persistent data design of the application will be implemented using a&#xD;
    relational database management system (RDBMS). It is assumed that you have familiarity with database concepts,&#xD;
    including normalization and de-normalization, as well as with database terminology as covered in references such as [&lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../core.base_rup/customcategories/references_56F06DFD.html#DAT99&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>DAT99&lt;/a>].&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The steps in this task also refer to the Unified Modeling Language (UML) profile for database modeling, which is&#xD;
    discussed in&amp;nbsp;[&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/customcategories/references_56F06DFD.html#NBG01&quot; guid=&quot;7.755968586980351E-308&quot;>&lt;font&#xD;
    color=&quot;#ff0000&quot;>NBG01&lt;/font>&lt;/a>]. In addition, [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/customcategories/references_56F06DFD.html#NBG01&quot; guid=&quot;7.755968586980351E-308&quot;>&lt;font&#xD;
    color=&quot;#ff0000&quot;>NBG01&lt;/font>&lt;/a>] contains a general description of the process for modeling and designing relational&#xD;
    databases using UML.&amp;nbsp; For background information on the relationship between relational data models and object&#xD;
    models, consult &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/concepts/relational_databases_and_object_orientation_1C67069E.html&quot;&#xD;
    guid=&quot;3.2166604011257303E-305&quot;>Concept: Relational Databases and Object Orientation&lt;/a>.&#xD;
&lt;/p></mainDescription>
  <sections xmi:id="_Rz4scNnnEdmO6L4XMImrsA" name=" Develop Logical Data Model (Optional) " guid="_Rz4scNnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Develop Logical Data Model&quot; name=&quot;Develop Logical Data Model&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                Define a model of the logical design of the database.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    The purpose of the Logical Data Model is to provide an idealized view of the key logical data entities and their&#xD;
    relationships that is independent of any specific software or database implementation. It is generally in third normal&#xD;
    form (see &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/guidances/concepts/normalization_47199FE9.html&quot;&#xD;
    guid=&quot;3.183357382287462E-306&quot;>Concept: Normalization&lt;/a>), which is a data-modeling form that minimizes redundancy and&#xD;
    ensures no transitive dependencies. Such a model is concerned with what the database will look like when capturing&#xD;
    data, rather than with the applications that use the data and their performance. Note that a Logical Data Model is&#xD;
    considered to be part of the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_data_model_65B46980.html&quot; guid=&quot;{9DCF1723-1A21-4F48-BEDE-DBC543489682}&quot;>Artifact:&#xD;
    Data Model&lt;/a> and is not a separate RUP work product. However, it is often important to define individual Logical Data&#xD;
    Models for:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        projects in which the database and application designs are being developed by separate teams.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        projects in which there are multiple applications that will share a common database.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    If you are creating a Logical Data Model, you can start from scratch using the model elements discussed in &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/guidances/guidelines/data_model_80FB2539.html&quot;&#xD;
    guid=&quot;3.4196799396281445E-306&quot;>Guideline: Data Model&lt;/a>, or you can begin by starting with entities for each&#xD;
    persistent class in the &lt;a class=&quot;elementLink&quot; href=&quot;./../../core.base_rup/workproducts/rup_analysis_model_76C3B70C.html&quot;&#xD;
    guid=&quot;{98EA224C-36F6-46E6-AB36-2999382B58B3}&quot;>Analysis Model&lt;/a> or &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_design_model_2830034D.html&quot; guid=&quot;{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}&quot;>Design&#xD;
    Model&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You might decide not to create a separate Logical Data Model, especially if you are designing a database that serves a&#xD;
    single application. In this case, the &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/roles/rup_database_designer_524DC34F.html&quot; guid=&quot;{87EE3BF5-17CA-4211-BD3D-32F361E58550}&quot;>Database&#xD;
    Designer&lt;/a> develops the Physical Data Model based on the set of persistent classes and their associations in the&#xD;
    Design Model.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In either approach, it is important for the &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/roles/rup_database_designer_524DC34F.html&quot; guid=&quot;{87EE3BF5-17CA-4211-BD3D-32F361E58550}&quot;>Database&#xD;
    Designer&lt;/a> and the &lt;a class=&quot;elementLink&quot; href=&quot;./../../core.base_rup/roles/rup_designer_BA8DE74E.html&quot;&#xD;
    guid=&quot;{DB21F5EF-810B-4994-B120-79FA8774FA9D}&quot;>Designer&lt;/a> to collaborate throughout the analysis and design process to&#xD;
    identify which classes in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_design_model_2830034D.html&quot; guid=&quot;{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}&quot;>Artifact:&#xD;
    Design Model&lt;/a> need to store information in a database. As described in the step titled, &quot;Identify persistent classes&#xD;
    of the &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/tasks/class_design_98F20FF9.html&quot;&#xD;
    guid=&quot;{27AE0601-2E95-4A6A-8EB3-0A4BA8E5626B}&quot;>Task: Class Design&lt;/a>,&quot; the database designer works with the designer to&#xD;
    identify which &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../core.base_rup/workproducts/rup_design_class_B33BD5E5.html&quot;&#xD;
    guid=&quot;{952A9CE9-D5A3-43AC-980D-0B9298F3872E}&quot;>design classes&lt;/a> in the Design Model are considered to be persistent&#xD;
    and are potential candidates for becoming tables in the database.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_Rz4scdnnEdmO6L4XMImrsA" name=" Develop Physical Database Design " guid="_Rz4scdnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Develop Physical Data Model&quot; name=&quot;Develop Physical Data Model&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                Define the detailed physical design of the database.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    The physical database design includes model elements (such as tables, views, and stored procedures) that represent the&#xD;
    detailed physical structure of the database and model elements (such as schemas and tablespaces) that represent the&#xD;
    underlying data storage design of the database.&amp;nbsp; Collectively, these model elements comprise the Physical Data&#xD;
    Model of the database.&amp;nbsp; This Physical Data Model is contained in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_data_model_65B46980.html&quot; guid=&quot;{9DCF1723-1A21-4F48-BEDE-DBC543489682}&quot;>Artifact:&#xD;
    Data Model&lt;/a> and is not a separate model work product.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The detailed steps for developing the physical database design are as follows:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Define%20Domains&quot;>Define domains&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Transform%20Persistent%20Design%20Elements%20to%20the%20Physical%20Data%20Model&quot;>Create initial physical&#xD;
        database design elements&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Define%20Reference%20Tables%20and%20Default%20Values&quot;>Define reference tables&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Create%20Primary%20Key%20and%20Unique%20Key%20Constraints&quot;>Create primary key and unique constraints&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Define%20Data%20and%20Referential%20Integrity%20Enforcement%20Rules&quot;>Define data and referential&#xD;
        integrity enforcement rules&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Optimize%20the%20Data%20Model%20for%20Performance&quot;>De-normalize database design to optimize for&#xD;
        performance&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Optimize%20Data%20Access&quot;>Optimize data access&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Define%20Storage%20Characteristics&quot;>Define storage characteristics&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Distribute%20Class%20behavior%20to%20the%20Database&quot;>Design stored procedures to distribute class&#xD;
        behavior to the database&lt;/a>.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Define Domains&quot; name=&quot;Define Domains&quot;>Define Domains&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
    &lt;tr>&#xD;
        &lt;td width=&quot;5%&quot;>&#xD;
            &lt;b>Purpose&lt;/b>&#xD;
        &lt;/td>&#xD;
        &lt;td width=&quot;95%&quot;>&#xD;
            To define reusable user-defined types.&amp;nbsp;&#xD;
        &lt;/td>&#xD;
    &lt;/tr>&#xD;
&lt;/table>&#xD;
&lt;p>&#xD;
    Domains might be used by the database designer to enforce type standards throughout the database design. Domains are&#xD;
    user-defined data types that can be applied to a column in a table.&amp;nbsp; Domains have the properties of a column&#xD;
    without the name.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Transform Persistent Design Elements to the Physical Data Model&quot;&#xD;
    name=&quot;Transform Persistent Design Elements to the Physical Data Model&quot;>Create Initial Physical Database Design&#xD;
    Elements&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                Create the initial database tables and relationships.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    The database designer models the Physical Data Model elements using tables and columns in tables, as described in &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/guidances/guidelines/data_model_80FB2539.html&quot;&#xD;
    guid=&quot;3.4196799396281445E-306&quot;>Guideline: Data Model&lt;/a>.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If a Logical Data Model has been created, then its logical entities can be used as the basis for an initial set of&#xD;
    tables.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Alternatively, the database designer might jump-start the Physical Data Model by using the persistent classes in the&#xD;
    Design Model as a starting point for tables in the Physical Data Model.&amp;nbsp; The database designer models the&#xD;
    persistent classes and their attributes as&amp;nbsp;tables and columns respectively.&amp;nbsp; The database designer also needs&#xD;
    to define the relationships between the tables based on the associations between the persistent classes in the Design&#xD;
    Model.&amp;nbsp; A description of how the Design Model elements and relationships map to Data Model elements and&#xD;
    relationships is provided in &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/guidelines/forward-engineering_relational_databases_53C0441E.html&quot;&#xD;
    guid=&quot;5.250868507423771E-305&quot;>Work Product Guideline: Forward Engineering Relational Databases&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you are starting the model from persistent classes rather than from a normalized Logical Data Model, then you will&#xD;
    generally need to apply some normalization in order to eliminate data redundancies and non-key field dependencies. See&#xD;
    &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/guidances/concepts/normalization_47199FE9.html&quot;&#xD;
    guid=&quot;3.183357382287462E-306&quot;>Concept: Normalization&lt;/a> for more information on database normalization.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Define Reference Tables and Default Values&quot; name=&quot;Define Reference Tables and Default Values&quot;>Define Reference&#xD;
    Tables&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To define standard reference tables used across the project.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Often there are standard look-up tables, validation tables, or reference tables used throughout the project. Since the&#xD;
    data in these tables tends be frequently accessed but seldom-changing, that data is worth special consideration. In the&#xD;
    Design Model, these tables might contain standard product codes, state or province codes, postal or zip codes, tax&#xD;
    tables, area code validation tables, or other frequently accessed information. In financial systems, these tables might&#xD;
    contain lists of policy codes, insurance policy rating categories, or conversion rates. Look in the Design Model for&#xD;
    classes that are primarily read-only, providing validation information for a large number of clients.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the reference table is small, do not bother to index it, since indexing might actually add additional overhead for&#xD;
    small tables. A small, frequently accessed table also tends to remain in memory, because caching algorithms often keep&#xD;
    frequently accessed tables in the data cache.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If possible, make sure that the database cache is large enough to keep all reference tables in memory, along with&#xD;
    normal &quot;working set space&quot; for queries and transactions. Often the secret to increasing database performance is&#xD;
    reducing disk I/O.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Once the reference table structures are defined, determine a strategy for populating the reference tables. Since these&#xD;
    tables are accessed near the beginning of the project, determining the reference values and loading the tables often&#xD;
    need to occur relatively early during application runtime. While the database designer is not responsible for obtaining&#xD;
    the data, he or she is responsible for determining how and when the reference tables will be refreshed.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Create Primary Key and Unique Key Constraints&quot; name=&quot;Create Primary Key and Unique Key Constraints&quot;>Create&#xD;
    Primary Key and Unique Constraints&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To define the one or more columns that uniquely identify a row in the table.&lt;br />&#xD;
                 To define constraints on columns that guarantee the uniqueness of the data or collection of data.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    A primary key is one or more columns that uniquely identify rows in a table. A table has a single primary key. There is&#xD;
    often a &quot;natural&quot; key that can be used to uniquely identify a row of data (for example, the postal code in a reference&#xD;
    table). The primary key should not contain data that might change with the business environment. If the &quot;natural&quot; key&#xD;
    is a value that can change (for example a person's name), then it is recommended that the database designer create a&#xD;
    single non-meaningful, non-user-entered column when creating a primary key.&amp;nbsp;This creates a data structure that has&#xD;
    greater adaptability to changes in the business structure, rules, or environment.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The use of a non-meaningful, non-user-entered column as the primary key is an essential concept in designing a data&#xD;
    warehouse. Transactional systems often choose a &quot;natural&quot; primary key that might be subject to minimal change over a&#xD;
    non-meaningful, non-user-entered column.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A unique constraint designates that the data in the column or collection of columns is unique per row. If the unique&#xD;
    constraint is on a column, the data in a specific row in the specified column must be unique from the data in a&#xD;
    different row in the same column.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When a unique constraint is defined for a group of columns, the uniqueness is based on the collective whole of the data&#xD;
    in the columns that make up that unique constraint. The data in a specific row in a specific column does not have to be&#xD;
    unique from the data in a different row in the same column. The database designer uses the unique constraint to ensure&#xD;
    uniqueness of business data.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Define Data and Referential Integrity Enforcement Rules&quot;&#xD;
    name=&quot;Define Data and Referential Integrity Enforcement Rules&quot;>Define Data and Referential Integrity Enforcement&#xD;
    Rules&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
    &lt;tr>&#xD;
        &lt;td width=&quot;5%&quot;>&#xD;
            &lt;b>Purpose&lt;/b>&#xD;
        &lt;/td>&#xD;
        &lt;td width=&quot;95%&quot;>&#xD;
            To ensure the integrity of the database.&#xD;
        &lt;/td>&#xD;
    &lt;/tr>&#xD;
&lt;/table>&#xD;
&lt;p>&#xD;
    Data integrity rules, also known as constraints, ensure that data values lie within defined ranges. Where these ranges&#xD;
    can be identified, the database can enforce them. (This is not to say that data validation should not be done in the&#xD;
    application, but only that the database can serve as a &quot;validator of last resort&quot; in the event that the application&#xD;
    does not work correctly.) Where data validation rules exist, the database constraints must be designed to enforce them.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A foreign key is one or more columns in a table that map to the primary key in another table. One table might have many&#xD;
    foreign keys, and each foreign key is a map to a different table. This mapping, or relationship, between the tables is&#xD;
    often referred to as a parent-child relationship.&amp;nbsp;The child table contains the foreign key, which maps to the&#xD;
    primary key in the parent table.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The definition of foreign key constraints is also often used by the query optimizer to accelerate query&#xD;
    performance.&amp;nbsp; In many cases, the foreign key enforcement rules use reference tables.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Optimize the Data Model for Performance&quot; name=&quot;Optimize the Data Model for Performance&quot;>De-Normalize Database&#xD;
    Design to Optimize for Performance&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To optimize the database data structures for performance.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    In the case of a relational Data Model, the initial mapping generally yields a simple class-to-table mapping. If&#xD;
    objects from different classes need to be retrieved at the same time, the RDBMS uses an operation called a &quot;table join&quot;&#xD;
    to retrieve the rows related to the objects of interest. For frequently accessed data, join operations can be&#xD;
    computationally expensive. To eliminate the cost of the join, a standard relational technique called &quot;de-normalization&quot;&#xD;
    is often employed.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    De-normalization combines columns from two or more different tables into the same table, effectively pre-joining the&#xD;
    information. De-normalization reflects a tradeoff between more-expensive update operations in favor of less-expensive&#xD;
    retrieval operations. This technique also reduces the performance of the system in queries that are interested only in&#xD;
    the attributes of one of the objects that are effectively joined in the de-normalized table, since all attributes are&#xD;
    normally retrieved on every query. For cases in which the application normally wants all attributes, there can be a&#xD;
    significant performance improvement.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    De-normalizing more than two tables is rare and increases the cost of inserts and updates as well as the cost of&#xD;
    non-join queries. Limiting de-normalization to two tables is a good policy unless strong and convincing evidence can be&#xD;
    produced regarding the benefits.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    De-normalization can be inferred from the &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_design_class_B33BD5E5.html&quot; guid=&quot;{952A9CE9-D5A3-43AC-980D-0B9298F3872E}&quot;>design&#xD;
    classes&lt;/a> in cases in which classes are nested. Nested classes can be mapped to a de-normalized table.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Some object databases allow a concept similar to de-normalization, in which related objects are clustered together on&#xD;
    disk and retrieved in single operations. The concept in use is similar: Reduce object retrieval time by reducing the&#xD;
    work the system must do in order to retrieve related objects from the database.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In some cases, optimizing the Data Model can unmask problems in the &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_design_model_2830034D.html&quot; guid=&quot;{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}&quot;>Design&#xD;
    Model&lt;/a>, including performance bottlenecks, poor modeling, or incomplete designs. In this event, discuss the problems&#xD;
    with the &lt;a class=&quot;elementLink&quot; href=&quot;./../../core.base_rup/roles/rup_designer_BA8DE74E.html&quot;&#xD;
    guid=&quot;{DB21F5EF-810B-4994-B120-79FA8774FA9D}&quot;>Designer&lt;/a> of the class, triggering change requests where appropriate.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Optimize Data Access&quot; name=&quot;Optimize Data Access&quot;>Optimize Data Access&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To provide for efficient data access using indexing.&lt;br />&#xD;
                 To provide for efficient data access using database views.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Once the table structure has been designed, you must determine the types of queries that will be performed against the&#xD;
    data. Indexing is used by the database to speed access. Indexing is most effective when the data values in the column&#xD;
    being indexed are relatively distinct.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Consider the following indexing principles:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The primary key column of the table must always be indexed. Primary key columns are used frequently as search keys&#xD;
        and for join operations.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Tables smaller than 100 rows in size with only a few columns benefit little from indexing. Small tables generally&#xD;
        fit easily in the database cache.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Indexes should also be defined for frequently executed queries or for queries that must retrieve data quickly&#xD;
        (generally, any searches done while a person might be waiting). An index should be defined for each set of&#xD;
        attributes that are used together as search criteria. For example, if the system needs the ability to find all&#xD;
        Orders on which a particular product is ordered, an index on the Line Item table on the product number column would&#xD;
        be necessary.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Indexes should generally be defined only on columns used as identifiers, not on numeric values, such as account&#xD;
        balances or textual information such as order comments. Identifier column values tend to be assigned when the&#xD;
        object is created and then remain unchanged for the life of the object.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Indexes on simple numbers (integer and number data types) are much simpler and faster than indexes on strings.&#xD;
        Given the large data volumes processed on a query or a large join, small savings add up quickly.&amp;nbsp; Indexes on&#xD;
        numeric columns tend to take significantly less space than indexes on characters.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    On the down side, the use of indexes is not free; the more indexes on a table, the longer inserts and updates take to&#xD;
    process. When contemplating the use of indexes, bear in mind the following precautions:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Do not index just to speed up an infrequently executed query, unless that query occurs at a critical point, making&#xD;
        maximum speed essential.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        In some systems, update and insertion performance is more important than query performance. A common example is in&#xD;
        factory data acquisition applications in which quality data is captured in real time. In these systems, only&#xD;
        occasional online queries are executed, and most of the data is analyzed periodically by batch reporting&#xD;
        applications that perform statistical analysis on it. For data-acquisition systems, remove all indexes to achieve&#xD;
        maximum throughput. If indexes are needed, they can be rebuilt just before the batch reporting and analysis&#xD;
        applications run, then dropped when the reporting and analysis is complete.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Always remember that indexes have hidden costs. For example, they take time to update (a tax paid on every insert,&#xD;
        update, or delete) and occupy disk space. Be sure you get value from using them.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Many databases offer a choice of index types. The most common include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>B-tree indexes-&lt;/b>The most frequently used kind are based on balanced b-tree index data structures. They are&#xD;
        useful when the index key values are randomly distributed and tend to have wide variability. They tend to perform&#xD;
        poorly, however, when data being indexed is already in sequential order.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Hashed indexes-&lt;/b>Less frequently, index key values are hashed. Hashing offers better performance when the&#xD;
        range of index key values is known, relatively unchanging, and unique. This technique relies upon the use of the&#xD;
        key value to calculate the address of the data of interest. Because of the need for predictability, hash indexes&#xD;
        tend to be useful only for medium-sized lookup tables that change very infrequently.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Your choice of indexing strategy and timing of index creation can have a large impact on performance. Bulk data loads&#xD;
    should be performed without indexes (this can be achieved by dropping the index, loading the data, and then re-creating&#xD;
    the index). The reason for this is that the index structure is re-balanced as each row is added. Since subsequent rows&#xD;
    will change the optimal index structure, the work done re-balancing the index as each row is inserted is largely&#xD;
    wasted. It is faster and more efficient to load data without indexes, then re-create the index when the data load is&#xD;
    done. Some databases provide bulk data-loaders to do this automatically.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another strategy for optimizing database access performance is the use of views. Database views are virtual tables that&#xD;
    have no independent storage of their own. To the calling program (or user), however, a view behaves like a table. A&#xD;
    view supports retrieval of data, and it can be used to update data as well-depending on the database structure and&#xD;
    database vendor. The view contains data from one or more tables that can be accessed through a single select statement.&#xD;
    The performance gain occurs during the selection of data, especially in frequently queried tables. The data is&#xD;
    retrieved from a single location-the view-instead of by searching the multiple or large tables that exist in the&#xD;
    database.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Views also play a significant role in database security. A view containing parts of a table can restrict access to&#xD;
    sensitive data contained in the base table.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Define Storage Characteristics&quot; name=&quot;Define Storage Characteristics&quot;>Define Storage Characteristics&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To design the space allocation and disk page organization of the database.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    A database designer uses tablespaces to represent the amount of storage space that is allocated to tables, indexes,&#xD;
    stored procedures, and so forth. One or more tablespaces are mapped to a database. The database designer must analyze&#xD;
    the tables in the Data Model to determine how to distribute them, along with other support database elements, across&#xD;
    the storage space in the database.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In determining the tablespace structures for the database, bear in mind that databases do not perform I/O on rows,&#xD;
    records, or even whole tables. Instead they perform I/O on disk blocks. The reason for this is simple: Block I/O&#xD;
    operations are usually optimized in the software and hardware on the system. As a result, the physical organization of&#xD;
    the tables and indexes in the database can have a dramatic impact on the performance of the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When planning the space allocation and disk page organization of the database, consider the following factors:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        the density of information in the disk pages&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        the location of disk pages on disk or across multiple disks&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        the amount of disk space to allocate to the table&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    These factors are discussed in the sections that follow.&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;h5>&#xD;
        &lt;b>Disk Page Density&lt;/b>&#xD;
    &lt;/h5>&#xD;
    &lt;p>&#xD;
        The density of disk pages depends on the extent to which data is expected to change over time. Basically, a&#xD;
        less-dense page is more capable of accepting changes in values or the addition of data over time, while a fuller&#xD;
        data page provides better read performance, since more data is retrieved per block read.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        To simplify disk management, the database designer can group tables by the extent to which they tend to change. The&#xD;
        following three groups constitute a good beginning for this type of organization:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            highly dynamic tables&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            somewhat dynamic tables&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            mostly static tables&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        The highly dynamic tables should be mapped onto disk pages that have a great deal of empty space in them (perhaps&#xD;
        30%); the somewhat dynamic tables should be mapped onto disk pages that have less empty space (perhaps 15%); and&#xD;
        the mostly static should be mapped onto disk pages that have very little empty space (perhaps 5%). The indexes for&#xD;
        the tables must be similarly mapped.&#xD;
    &lt;/p>&#xD;
    &lt;h5>&#xD;
        &lt;b>Disk Page Location&lt;/b>&#xD;
    &lt;/h5>&#xD;
    &lt;p>&#xD;
        After the groups of tables are mapped, the database designer must determine where to put the disk pages. The goal&#xD;
        here is to try to balance the workload across a number of different drives and heads to reduce or eliminate&#xD;
        bottlenecks. Consider the following guidelines:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Never put data on the same disk as the operating system, its temporary files, or the swap devices. These drives&#xD;
            are busy enough without the addition of further workload to them.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Put data that is accessed simultaneously on different drives in order to balance the workload. Some systems&#xD;
            support parallel I/O channels. If this is the case, put the data on different channels.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Put the indexes on a different drive from the data that it indexes in order to spread out the workload.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Refer to the database vendor's documentation for guidelines.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            The type of storage used (for example, RAID-5, RAID-10, SAN, NAS, and channel attached) affects database&#xD;
            performance. Make use of the performance guidelines provided by the storage provider.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        Database I/O is generally the limiting factor in database performance. I/O balancing is an iterative, experimental&#xD;
        process. By prototyping database access performance during the elaboration phase, coupled with appropriate&#xD;
        instrumentation to monitor physical and logical I/O, you can uncover performance problems early while there is&#xD;
        still time to adjust the database design.&#xD;
    &lt;/p>&#xD;
    &lt;h5>&#xD;
        &lt;b>Disk Space Allocation&lt;/b>&#xD;
    &lt;/h5>&#xD;
    &lt;p>&#xD;
        Using the characteristics of the persistence design mechanism, estimate the number of objects that must be stored.&#xD;
        The amount of disk space required to store the objects varies from RDBMS to RDBMS.&amp;nbsp;When calculating disk&#xD;
        space, make sure to account for growth due to additions of data.&amp;nbsp; To estimate the disk space for a database,&#xD;
        first estimate the disk space required for each table, and then calculate the space requirements for all&#xD;
        tables.&amp;nbsp; Consult the database administrator manual for the specific RDBMS product to determine the precise&#xD;
        size estimation formula.&amp;nbsp; Here are some general steps for estimating the space requirements for a table:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Calculate average row size.&amp;nbsp; This calculation should include any control information at the record level,&#xD;
            as well as any control information required for variable-length columns.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Calculate the number of rows that will fit into a page or block of I/O.&amp;nbsp;Because most databases store only&#xD;
            complete records on a page or I/O block, this should be the integer number of rows that will fit into a page or&#xD;
            block of I/O.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Calculate the number of pages or I/O blocks required to store the estimated number of records in the&#xD;
            database.&amp;nbsp; The estimated number of records must include any load factors.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Multiply the number of pages or I/O blocks required by the size of the page or I/O block.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Add any overhead for additional indexes.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Add any fixed overhead for the table.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        Once the table space requirements have been defined:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Compute the sum of the space required by the tables.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Add in any required fixed amount of space for database management.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Add in disk space required for the transaction log and audit trail.&amp;nbsp;&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        In a frequently updated environment, the retention requirements for the audit trail require significant amounts of&#xD;
        storage. The documentation for major commercial database management systems usually provides detailed sizing&#xD;
        instructions. Be sure to refer to these instructions when calculating your estimates of the database disk space&#xD;
        requirements.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Distribute Class behavior to the Database&quot; name=&quot;Distribute Class behavior to the Database&quot;>Design Stored&#xD;
    Procedures to Distribute Class Behavior to the Database&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To determine if the stored procedures or triggers should be used to implement data access class operations.&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Most databases support a stored procedure capability. A stored procedure is executable code that runs within the&#xD;
    process space of the database management system. It provides the ability to perform database-related actions on the&#xD;
    server without having to transfer data across a network. The judicious use of stored procedures can the improve&#xD;
    performance of the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Stored procedures are usually one of these two types: actual procedures or triggers. Procedures are executed explicitly&#xD;
    by an application, generally have parameters, and provide an explicit return value. Triggers, on the other hand, are&#xD;
    invoked implicitly when some database event occurs (for example, insert a row, update a row, or delete a row), have no&#xD;
    parameters other than the row being modified (since they are invoked implicitly), and do not provide an explicit return&#xD;
    value.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In database systems that lack constraints, triggers are often used to enforce referential and data integrity.&#xD;
    Otherwise, they tend to be used when an event needs to trigger (or cause) another event. Triggers are also frequently&#xD;
    used for security purposes by auditing the trigger event.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The design classes in the Design Model must be examined to see if they have operations that should be implemented using&#xD;
    the stored procedure or trigger facility. Candidates include:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        any operations that primarily deal with persistent data (creating, updating, retrieving, or deleting it).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        any operations in which a query is involved in a computation (such as calculating the average quantity and value of&#xD;
        a product in inventory).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        operations that must access the database in order to validate data.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Remember that improving database performance usually means reducing I/O. Therefore, if performing a computation on the&#xD;
    DBMS server will reduce the amount of data passed over the network, the computation should probably be performed on the&#xD;
    server.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Work with the designer of the design class to discuss how the database can be used to improve performance. The designer&#xD;
    will update the operation method to indicate whether one or more stored procedures can be used to implement the&#xD;
    operation.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_R0B2YNnnEdmO6L4XMImrsA" name=" Review the Results " guid="_R0B2YNnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Review the Results&quot; name=&quot;Review the Results&quot;>&lt;/a> &#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;100%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;5%&quot;>&#xD;
                    &lt;b>Purpose&lt;/b>&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;95%&quot;>&#xD;
                    To ensure the quality and integrity of the &lt;a class=&quot;elementLink&quot;&#xD;
                    href=&quot;./../../core.base_rup/workproducts/rup_data_model_65B46980.html&quot;&#xD;
                    guid=&quot;{9DCF1723-1A21-4F48-BEDE-DBC543489682}&quot;>Data Model&lt;/a>.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Continuously throughout this task, you must consider the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/checklists/data_model_D22985A5.html&quot; guid=&quot;2.800761632096845E-305&quot;>Checklist: Data&#xD;
    Model&lt;/a> to assess the completeness and quality of the effort.&amp;nbsp; Furthermore, the database designer must regularly&#xD;
    review the implemented structure of the database to ensure that the Data Model is consistent with any changes that have&#xD;
    been made directly in the database.&amp;nbsp; If the project is using data-modeling tools that support synchronization of&#xD;
    the Data Model with the physical structure of database, the database designer must periodically check the state of the&#xD;
    Data Model with the database and makes adjustments as needed.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Identified defects that will not be corrected at this time must be documented in &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_change_request_F2E6419.html&quot; guid=&quot;{694A7BC8-3D20-4172-BC56-6C7BD4590BA5}&quot;>Change&#xD;
    Requests&lt;/a> and eventually assigned to someone to own and drive to resolution.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <purpose>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        To ensure that persistent data is stored consistently and efficiently.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To define behavior that must be implemented in the database.&#xD;
    &lt;/li>&#xD;
&lt;/ul></purpose>
</org.eclipse.epf.uma:TaskDescription>
