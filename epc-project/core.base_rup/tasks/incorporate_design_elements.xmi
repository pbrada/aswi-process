<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:TaskDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_13kyktnmEdmO6L4XMImrsA" name="incorporate_design_elements,{5C647173-4E32-4594-96A9-2548B47722FA}" guid="_13kyktnmEdmO6L4XMImrsA" changeDate="2005-07-25T20:15:12.617-0700" version="7.1.0">
  <sections xmi:id="_T1OSENnnEdmO6L4XMImrsA" name=" Identify Reuse Opportunities " guid="_T1OSENnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;XE_reuse__identify_reuse_opportunities&quot; name=&quot;XE_reuse__identify_reuse_opportunities&quot;>&lt;/a>&lt;a&#xD;
id=&quot;Identify Reuse Opportunities&quot; name=&quot;Identify Reuse Opportunities&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To identify where existing subsystems and/or components may be reused based on their interfaces.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    &lt;b>Look for existing subsystems or components which offer similar interfaces.&lt;/b> Compare each interface identified to&#xD;
    the interfaces provided by existing subsystems or components. There usually will not be an exact match, but approximate&#xD;
    matches can be found. Look first for similar behavior and returned values, then consider parameters.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Modify the newly identified interfaces to improve the fit&lt;/b>. There may be opportunities to make minor changes to a&#xD;
    candidate interface which will improve its conformance to the existing interface. Simple changes include rearranging or&#xD;
    adding parameters to the candidate interface, and then factoring the interface by splitting it into several interfaces,&#xD;
    one or more of which match those of the existing component, with the &quot;new&quot; behaviors located in a separate interface.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Replace candidate interfaces with existing interfaces where exact matches occur.&lt;/b> After simplification and&#xD;
    factoring, if there is an exact match to an existing interface, eliminate the candidate interface and simply use the&#xD;
    existing interface.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Map the candidate subsystem to existing components.&lt;/b> Look at existing components and the set of candidate&#xD;
    subsystems. Factor the subsystems so that existing components are used wherever possible to satisfy the required&#xD;
    behavior of the system. Where a candidate subsystem can be realized by an existing component, create traceability&#xD;
    between the design subsystem and the component in the implementation model.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In mapping subsystems onto reusable components, consider the design mechanisms associated with the subsystem;&#xD;
    performance or security requirements may disqualify a component from reuse despite an otherwise perfect match between&#xD;
    operation signatures.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_T1YDENnnEdmO6L4XMImrsA" name=" Reverse-Engineer Components and Databases " guid="_T1YDENnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;XE_database__reverse_engineering&quot; name=&quot;XE_database__reverse_engineering&quot;>&lt;/a>&lt;a id=&quot;XE_component__reverse_engineer&quot;&#xD;
name=&quot;XE_component__reverse_engineer&quot;>&lt;/a>&lt;a id=&quot;XE_code__reverse_engineering&quot; name=&quot;XE_code__reverse_engineering&quot;>&lt;/a>&lt;a&#xD;
id=&quot;Reverse Engineer Components and Databases&quot; name=&quot;Reverse Engineer Components and Databases&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To incorporate potentially reusable model elements from other projects, external sources or prior&#xD;
                iterations.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Existing code and database definitions can be 'scavenged' to make work done on previous projects or iterations&#xD;
    available to the current project/iteration. By using potential reuse opportunities as a filter, the work that is&#xD;
    reverse engineered can be focused on just the components which are reusable for the current iteration.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Reverse Engineer Components&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In organizations which build similar systems, there is often a set of common components which provide many of the&#xD;
    architectural mechanisms needed for a new system. There may also be components available in the marketplace which also&#xD;
    provide the architectural mechanisms. Existing components should be examined to determine their suitability and&#xD;
    compatibility within the software architecture.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Existing components, either developed during prior iterations but not yet included in the Design Model, or purchased&#xD;
    components, must be reverse-engineered and incorporated into the Design Model. In the Design Model, such components are&#xD;
    commonly represented as a Subsystem with one or more Interfaces.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Reverse Engineer Databases&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Databases, and the data residing in them, represent one of the most important sources for reusable assets. To reuse the&#xD;
    implicit class definitions embodied in existing databases, determine which information used by the application already&#xD;
    resides in existing databases. Reverse-engineer a set of classes to represent the database structures that hold this&#xD;
    information. At the same time, construct a mapping between the application's class representation and the structures&#xD;
    used in the database. For more information on reverse engineering databases, see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/guidelines/reverse-engineering_relational_databases_902803B8.html&quot;&#xD;
    guid=&quot;1.338740134620651E-305&quot;>Guideline: Reverse-engineering Relational Databases&lt;/a>. For more on mapping between&#xD;
    classes and tables in a relational database, see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/guidelines/data_model_80FB2539.html&quot; guid=&quot;3.4196799396281445E-306&quot;>Guideline: Data&#xD;
    Model&lt;/a>.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_T10vANnnEdmO6L4XMImrsA" name=" Update the Organization of the Design Model " guid="_T10vANnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;XE_design_subsystem__defining_low-level_organization_of&quot;&#xD;
name=&quot;XE_design_subsystem__defining_low-level_organization_of&quot;>&lt;/a>&lt;a id=&quot;Update the Organization of the Design Model&quot;&#xD;
name=&quot;Update the Organization of the Design Model&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To account for the new model elements in the organization of the Design Model.&lt;br />&#xD;
                 To re-balance the structure of the Design Model where necessary.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    As new elements have been added to the Design Model, re-packaging the elements of the Design Model is often necessary.&#xD;
    Repackaging achieves several objectives: it reduces coupling between packages and improves cohesion within packages in&#xD;
    the design model. The ultimate goal is to allow different packages (and subsystems) to be designed and developed&#xD;
    independently of one another by separate individuals or teams. While complete independence is probably impossible to&#xD;
    achieve, loose coupling between packages tends to improve the ease of development of large or complex systems.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A 'flat' model structure (where all packages and subsystems reside at the same conceptual level in the system) is&#xD;
    suitable for a small system; larger systems need an additional structuring tool called 'layering' (see &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/guidances/guidelines/layering_FCCD1BDA.html&quot;&#xD;
    guid=&quot;4.458864982057142E-306&quot;>Guideline: Layering&lt;/a>). Layering rules define restrictions on allowed relationships&#xD;
    between certain types of packages. These rules recognize that certain dependencies should not exist: application&#xD;
    functionality should not be directly dependent on specific operating system or windowing system services - there should&#xD;
    be an intermediate layer containing logical operating system and windowing services that insulate the application&#xD;
    functionality from changes in low-level implementation services. Layering provides a way to reduce the impact of&#xD;
    change: by enforcing rules which restrict the dependencies between packages and subsystems, reducing the degree of&#xD;
    coupling between packages and subsystems, the system becomes more robust. It tolerates change.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As new model elements are added to the system, existing packages may grow too large to be managed by a single team: the&#xD;
    package must be split into several packages which are highly cohesive within the package but loosely coupled between&#xD;
    the packages. Doing this may be difficult - some elements may be difficult to place in one specific package because&#xD;
    they are used by elements of both packages. There are two possible solutions: split the element into several objects,&#xD;
    one in each package (this works where the element has several 'personalities', or sets of somewhat disjoint&#xD;
    responsibilities), or move the element into a package in a lower layer, where all higher layer elements may depend upon&#xD;
    it equally.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As the system grows in complexity, a larger number of layers will be needed in order to have a maintainable and&#xD;
    understandable structure. More than 7-10 layers, however, are unusual in even the largest systems, since complexity&#xD;
    increases and understandability decreases with the number of layers.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An example of layering, including middle-ware and System-software layers, is shown below:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/layers.gif&quot; alt=&quot;Layout Diagram for a Java/Web application&quot; border=&quot;0&quot; width=&quot;496&quot; height=&quot;554&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Sample package layering for a Java/Web-based application. Note: the dependencies on the TCP/IP package would not&#xD;
    normally be explicitly modeled as the use of TCP/IP services is encapsulated within the Java VM, java.rmi and the Web&#xD;
    Browser. They are depicted here only for illustration.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Assign responsibilities for the subsystems and layers to individuals or teams. Each package or subsystem should be the&#xD;
    responsibility of a single person (if its scope is small) or a team (if its scope is large).&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_T2uG4NnnEdmO6L4XMImrsA" name=" Update the Logical View " guid="_T2uG4NnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;XE_logical_view__including_classes_in&quot; name=&quot;XE_logical_view__including_classes_in&quot;>&lt;/a>&lt;a&#xD;
id=&quot;Update the Logical View&quot; name=&quot;Update the Logical View&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To ensure that the &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
                href=&quot;./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
                guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Work Product: Software Architecture Document (Logical&#xD;
                View)&lt;/a> remains up to date.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    When design classes, packages and subsystems (model elements) are important from an architectural perspective, they&#xD;
    should be included in the Logical View section of the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
    guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Artifact: Software Architecture Document&lt;/a>. This will ensure that new&#xD;
    architecturally significant model elements are communicated to other project team members.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In addition, the software architect role collaborates with the process engineer role to provide detailed guidance to&#xD;
    designers and implementers on how to use the newly incorporated design elements.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></sectionDescription>
  </sections>
  <purpose>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a id=&quot;XE_class__refining_analysis_classes&quot; name=&quot;XE_class__refining_analysis_classes&quot;>&lt;/a>To analyze interactions&#xD;
        of analysis classes to find interfaces, design classes and design subsystems&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To refine the architecture, incorporating reuse where possible.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To identify common solutions to commonly encountered design problems&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To include architecturally significant design model elements in the Logical View section of the Software&#xD;
        Architecture Document.&#xD;
    &lt;/li>&#xD;
&lt;/ul></purpose>
</org.eclipse.epf.uma:TaskDescription>
