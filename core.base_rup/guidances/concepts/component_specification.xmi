<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_w4gagOM8EdmaZcY4PeqVxA" name="component_specification,_wfrDwOM8EdmaZcY4PeqVxA" guid="_w4gagOM8EdmaZcY4PeqVxA" changeDate="2005-06-27T09:03:48.277-0700" version="7.1.0">
  <mainDescription>&lt;h3>&#xD;
    Introduction&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Moving from the Analysis to the Design level of the architecture entails determination of the hardware and software&#xD;
    component design. This Design-level specification consists of the components to be deployed: hardware, software, and&#xD;
    workers.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Hardware components are determined by analyzing the localities, their derived characteristics, and hosted subsystem&#xD;
    operations. With this information, Descriptor-level realizations of the localities can be selected. Descriptor node&#xD;
    diagrams specify the components, servers, workstations, workers, and so forth, without specific choices of technologies&#xD;
    that implement those components. The figure is an example Descriptor node diagram that realizes the Locality diagram&#xD;
    shown in &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/concepts/locality_E2133437.html&quot;&#xD;
    guid=&quot;_qmDvkOM9EdmaZcY4PeqVxA&quot;>Concept: Locality&lt;/a>. The fulfillment Locality is realized as four components: a&#xD;
    warehouse gateway and mailing/postage system, and two workers.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Descriptor nodes inherit characteristics from their localities through an allocation or budgeting process.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;448&quot; src=&quot;resources/descnode.gif&quot; alt=&quot;Diagram described in accompanying text.&quot; width=&quot;679&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;!--Add a caption for this figure? -->&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Hardware&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The implementation hardware components, the actual deployed set of hardware, are determined by making&#xD;
    cost/performance/capacity trades from the Descriptor view. In fact, a system might have more than one hardware&#xD;
    configuration, each meeting different price/performance points.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Software&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Components are determined by specifying a set of classes, and then compiling and assembling the code associated with&#xD;
    those classes into executable files. A fully considered software component design must reflect a variety of&#xD;
    concerns:&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Locality—where the components need to run&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Hosting—processor instruction set and memory restrictions for the executing code&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Concurrency—separation of processing into different hosts or memory spaces to address reliability and related&#xD;
        concerns&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    It follows that the information needed to specify components includes the surveys of hosted subsystem operations for&#xD;
    localities and their realized hardware components, surveys of executed operations for processes, along with&#xD;
    collaborations, realizing the subsystem operations, which yield the set of classes to be formed into a component&#xD;
    structure.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As a first approximation, assume all classes reside in a single component, giving a one-to-one mapping of component and&#xD;
    subsystem—this is the default advice given in &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html&quot; guid=&quot;1.2314266786534317E-305&quot;>Guideline:&#xD;
    Design Subsystem&lt;/a>. Next, look for reasons to partition the component further. If the set of classes contains more&#xD;
    than one active class, representing a process, then examine a partitioning of one active class (process) per component,&#xD;
    clustering those classes with the strongest relationships. Some classes can then be used by multiple components. If any&#xD;
    of these classes represent shared state in a common set of instances that are to be accessed by several components,&#xD;
    then there is a case to split them off into another component of their own. If the shared classes are stateless, you&#xD;
    might choose to separate them out into a service component (a stateless functional component), if they are functionally&#xD;
    cohesive. Even in a passive subsystem (no active classes), you can still choose to partition further, for example,&#xD;
    looking for finer-grained components that are reusable. Complete the process by repartitioning/dividing the components&#xD;
    further to account for specific technology choices (such as the J2EE&amp;trade; platform, or Microsoft&amp;reg; .NET), memory constraints&#xD;
    (such as .exe and .dll trade-offs), shipping media limitations, and so forth.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    These tasks result in a set of specific hardware and software components that make up the system.&#xD;
&lt;/p>&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
