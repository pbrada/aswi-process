<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1fIdYdnmEdmO6L4XMImrsA" name="component,3.524150980437479E-305" guid="_1fIdYdnmEdmO6L4XMImrsA" changeDate="2005-10-27T20:02:07.915-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_component__concepts&quot; name=&quot;XE_component__concepts&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;b>&lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Definition&lt;/a>&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The software industry and literature use the term &quot;component&quot; to refer to many different things. It is often used in&#xD;
    the broad sense to mean &quot;a constituent part&quot;. It is also frequently used in a narrow sense to denote specific&#xD;
    characteristics that enable replacement and assembly in larger systems.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In the RUP, we use the term &quot;component&quot; to mean an encapsulated part of a system, ideally a non-trivial, nearly&#xD;
    independent, and replaceable part of a system that fulfills a clear function in the context of a well-defined&#xD;
    architecture. This includes:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        design component - a significant encapsulated part of the design, and so includes Design Subsystems and sometimes&#xD;
        significant Design Classes and Design Packages.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        implementation component - a significant encapsulated part of the implementation, generally code that implements a&#xD;
        design component.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Ideally the design reflects the implementation, and so one can refer to just components, each component having a design&#xD;
    and an implementation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The UML ([&lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>UML04&lt;/a>]) defines &quot;component&quot; as the following:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        A modular part of a system that encapsulates its contents and whose manifestation is replaceable within its&#xD;
        environment. A component defines its behavior in terms of provided and required interfaces. As such, a component&#xD;
        serves as a type, whose conformance is defined by these provided and required interfaces (encompassing both their&#xD;
        static as well as dynamic semantics).&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    A component is defined as a subtype of structured class, which provides for a component having attributes and&#xD;
    operations, being able to participate in associations and generalizations, and having internal structure and ports.&#xD;
    Refer to &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html&quot;&#xD;
    guid=&quot;1.1994826813129747E-304&quot;>Concept: Structured Class&lt;/a> for more details.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A number of UML standard stereotypes exist that apply to component, e.g. &amp;lt;&amp;lt;subsystem&amp;gt;&amp;gt; to model large-scale&#xD;
    components, and &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; and &amp;lt;&amp;lt;realization&amp;gt;&amp;gt; to model components with distinct&#xD;
    specification and realization definitions, where one specification may have multiple realizations.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The RUP usage of the term component is broader than the UML definition. Rather than define components as having&#xD;
    characteristics such as modularity, deployability, and replaceability, we instead recommend these as desirable&#xD;
    characteristics of components. See the section below on Component Replaceability.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;b>&lt;a id=&quot;Component_Replaceability&quot; name=&quot;Component_Replaceability&quot;>Component Replaceability&lt;/a>&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In RUP and UML terminology, components should be replaceable. However, this may only mean that the component exposes a&#xD;
    set of interfaces that hide an underlying implementation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are other, stronger, kinds of replaceability. These are listed below.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Source-File Replaceability&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    If two classes are implemented in a single source code file, then each of the classes cannot usually be separately&#xD;
    versioned and controlled.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    However, if a set of files fully implements a single component, and no other component, then the component is&#xD;
    source-file replaceable. This characteristic makes it easier for component source code to be version-controlled,&#xD;
    baselined, and re-used.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Deployment Replaceability&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    If two classes are deployed in a single executable, then each class is not independently replaceable in a deployed&#xD;
    system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A desirable characteristic of larger granularity components is to be &quot;deployment replaceable&quot;, allowing new versions of&#xD;
    the component to be deployed without having to re-build the other components. This usually means there is one file or&#xD;
    one set of files that deploy the component and no other component.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Run-Time Replaceability&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    If a component can be redeployed into a running system, then it is referred to as &quot;run-time replaceable&quot;. This enables&#xD;
    software to be upgraded without loss of availability.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Location Transparency&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Components with network addressable interfaces are referred to as having &quot;location transparency&quot;. This allows&#xD;
    components to be relocated to other servers, or to be replicated on multiple servers, to support fault tolerance, load&#xD;
    balancing, and so on. These kinds of components are often referred to as &quot;distributed&quot; or &quot;distributable&quot; components.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;b>&lt;a id=&quot;Component_Modeling&quot; name=&quot;Component_Modeling&quot;>Modeling of Components&lt;/a>&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The UML component is a modeling construct that provides the following capabilities:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        can group classes to define a larger granularity part of a system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can separate the visible interfaces from internal implementation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        can have instances that execute at run-time&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A component has a number of provided and required Interfaces, which form the basis for wiring components together. A&#xD;
    provided Interface is one that is either implemented directly by the component or one of its realizing classes or&#xD;
    subcomponents, or it is the type of a provided Port of the Component. A required interface is designated by a Usage&#xD;
    Dependency from the Component or one of its realizing classes or subcomponents, or it is the type of a required Port.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A component has an external view (or &quot;black-box&quot; view) by means of its publicly visible properties and operations.&#xD;
    Optionally, a behavior such as a protocol state machine may be attached to an interface, port and to the component&#xD;
    itself, to define the external view more precisely by making dynamic constraints in the sequence of operation calls&#xD;
    explicit. The wiring between components in a system or other context can be structurally defined by using dependencies&#xD;
    between component interfaces (typically on component diagrams).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Optionally, a more detailed specification of the structural collaboration can be made using parts and connectors in&#xD;
    composite structures, to specify the role or instance level collaboration between components. That is the component's&#xD;
    internal view (or &quot;white-box&quot; view) by means of its private properties and realizing classes or subcomponents. This&#xD;
    view shows how the external behavior is realized internally. The mapping between external and internal view is by means&#xD;
    of dependencies (on components diagrams), or delegation connectors to internal parts (on composite structure diagrams).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    RUP recommends using components as the representation for Design Subsystems. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html&quot;&#xD;
    guid=&quot;{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}&quot;>Artifact: Design Subsystem&lt;/a>, &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/subsystem_design_5D1BCC0C.html&quot; guid=&quot;{CAA385CA-2BA2-40F2-8FE3-E21089D02119}&quot;>Task:&#xD;
    Subsystem Design&lt;/a>, and &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html&quot; guid=&quot;1.2314266786534317E-305&quot;>Guideline:&#xD;
    Design Subsystem&lt;/a> for details. Also, see definitions in &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html&quot; guid=&quot;1.1994826813129747E-304&quot;>Concept:&#xD;
    Structured Class&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;b>&lt;a id=&quot;Component_Instantiation&quot; name=&quot;Component_Instantiation&quot;>Component Instantiation&lt;/a>&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A component may or may not be directly instantiated at run time.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An indirectly instantiated component is implemented, or realized, by a set of classes, subcomponents or parts. The&#xD;
    component itself does not appear in the implementation; it serves as a design that an implementation must follow. The&#xD;
    set of realizing classes, subcomponents or parts must cover the entire set of operations specified in the provided&#xD;
    interface of the component. The manner of implementing the component is the responsibility of the implementer.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A directly-instantiated component specifies its own encapsulated implementation; it is instantiated as an addressable&#xD;
    object. It means that a design component has a corresponding construct in the implementation language, so it can be&#xD;
    explicitly referenced.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;b>&lt;a id=&quot;UML_1x_Representation&quot; name=&quot;UML_1x_Representation&quot;>UML 1.x Representation&lt;/a>&lt;/b>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    UML 1.5 defined &quot;component&quot; as the following:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        A modular, deployable, and replaceable part of a system that encapsulates implementation and exposes a set of&#xD;
        interfaces. A component is typically specified by one or more classes or subcomponents that reside on it, and may&#xD;
        be implemented by one or more artifacts (e.g., binary, executable, or script files).&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Note that in UML 1.3 and earlier versions of the UML, the &quot;component&quot; notation was used to represent files in the&#xD;
    implementation. Files are no longer considered &quot;components&quot; by the latest UML definitions. However, many tools and UML&#xD;
    profiles still use the component notation to represent files. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/implementation_element_ECCAA21E.html&quot;&#xD;
    guid=&quot;1.0315418523886092E-305&quot;>Guideline: Implementation Element&lt;/a> for more discussion on representing files in the&#xD;
    UML.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    From the modeling perspective, components were compared to UML Subsystems in UML 1.5, as they provided modularity,&#xD;
    encapsulation, and instances able to execute at run-time. RUP considers the UML 1.5 component modeling construct an&#xD;
    alternative notation for representing Design Subsystems. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html&quot;&#xD;
    guid=&quot;{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}&quot;>Artifact: Design Subsystem&lt;/a> and &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html&quot; guid=&quot;1.2314266786534317E-305&quot;>Guideline:&#xD;
    Design Subsystem&lt;/a> for details.&lt;br />&#xD;
    &lt;br />&#xD;
     Refer to &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html&quot;&#xD;
    guid=&quot;4.792914878943572E-306&quot;>Differences Between UML 1.x and UML 2.0&lt;/a> for more information.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
