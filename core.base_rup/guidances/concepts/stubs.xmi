<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_2KpfkNnmEdmO6L4XMImrsA" name="stubs,6.347489919609074E-305" guid="_2KpfkNnmEdmO6L4XMImrsA" changeDate="2006-03-25T09:37:36.377-0800" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_stubs__concept_of&quot; name=&quot;XE_stubs__concept_of&quot;>&lt;/a>&lt;a id=&quot;XE_test__stubs__concept_of&quot;&#xD;
name=&quot;XE_test__stubs__concept_of&quot;>&lt;/a>&lt;a id=&quot;XE_test__developer_testing__stubs__concept_of&quot;&#xD;
name=&quot;XE_test__developer_testing__stubs__concept_of&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A component is tested by sending inputs to its interface, waiting for the component to process them, then checking the&#xD;
    results. In the course of its processing, a component very likely uses other components by sending inputs to them and&#xD;
    using their results:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;283&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/co_stubs-img1.gif&quot; width=&quot;356&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Fig1: Testing a Component you've implemented&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Those other components may cause problems for your testing:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        They may not be implemented yet.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        They may have defects that prevent your tests from working or make you spend a lot of time discovering that a test&#xD;
        failure was not caused by your component.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        They may make it hard to run tests when you need to. If a component is a commercial database, your company might&#xD;
        not have enough floating licenses for everyone. Or one of the components may be hardware that's available only at&#xD;
        scheduled times in a separate lab.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        They may make testing so slow that tests aren't run often enough. For example, initializing the database might take&#xD;
        five minutes per test.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        It may be difficult to provoke the components to produce certain results. For example, you may want each of your&#xD;
        methods that writes to disk to handle &quot;disk full&quot; errors. How do you make sure the disk fills at just the moment&#xD;
        that method is called?&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    To avoid these problems, you may choose to use &lt;b>stub&lt;/b> components (also called &lt;b>mock objects&lt;/b>). Stub&#xD;
    components behave like the real components, at least for the values that your component sends them while responding to&#xD;
    its tests. They may go beyond that: they may be general-purpose &lt;b>emulators&lt;/b> that seek to faithfully mimic most or&#xD;
    all the component's behaviors. For example, it's often a good strategy to build software emulators for hardware. They&#xD;
    behave just like the hardware, only slower. They're useful because they support better debugging, more copies of them&#xD;
    are available, and they can be used before the hardware is finished.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;283&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/co_stubs-img2.gif&quot; width=&quot;356&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Fig2: Testing a Component you've implemented by stubbing out a component it depends on&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Stubs have two disadvantages.&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        They can be expensive to build. (That's especially the case for emulators.) Being software themselves, they also&#xD;
        need to be maintained.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        They may mask errors. For example, suppose your component uses trigonometric functions, but no library is available&#xD;
        yet. Your three test cases ask for the sine of three angles: 10 degrees, 45 degrees, and 90 degrees. You use your&#xD;
        calculator to find the correct values, then construct a stub for sine that returns, respectively, 0.173648178,&#xD;
        0.707106781, and 1.0. All is fine until you integrate your component with the real trigonometric library, whose&#xD;
        sine function takes arguments in &lt;i>radians&lt;/i> and so returns -0.544021111, 0.850903525, and 0.893996664. That's a&#xD;
        defect in your code that's discovered later, and with more effort, than you'd like.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;SoftwareDesignwithStubs&quot; name=&quot;SoftwareDesignwithStubs&quot;>Stubs and software design practices&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Unless the stubs were constructed because the real component wasn't available yet, you should expect to retain them&#xD;
    past deployment. The tests they support will likely be important during product maintenance. Stubs, therefore, need to&#xD;
    be written to higher standards than throwaway code. While they don't need to meet the standards of product code - for&#xD;
    example, most do not need a test suite of their own - later developers will have to maintain them as components of the&#xD;
    product change. If that maintenance is too hard, the stubs will be discarded, and the investment in them will be lost.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Especially when they're to be retained, stubs alter component design. For example, suppose your component will use a&#xD;
    database to store key/value pairs persistently. Consider two design scenarios:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Scenario 1: The database is used for testing as well as for normal use&lt;/b>. The existence of the database needn't be&#xD;
    hidden from the component. You might initialize it with the name of the database:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;/p>&#xD;
&lt;pre>&#xD;
 public Component(&lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
String databaseURL&lt;/font>&lt;/b>) &#xD;
 {&#xD;
    try &#xD;
    {  &#xD;
       databaseConnection = DriverManager.getConnection(databaseURL);&#xD;
       ... &#xD;
    } catch (SQLException e) {...}     &#xD;
 }&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
And, while you wouldn't want each location that read or wrote a value to construct a SQL statement, you'd certainly have&#xD;
some methods that contain SQL. For example, component code that needs a value might call this component method: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
 public String get(String key) &#xD;
 { &#xD;
    try &#xD;
    {     &#xD;
       Statement stmt = databaseConnection.createStatement();&#xD;
       ResultSet rs = stmt.executeQuery(&lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
&quot;SELECT value FROM Table1 WHERE key=&quot; + key&lt;/font>&lt;/b>);           &#xD;
       ... &#xD;
    } catch (SQLException e) {...} &#xD;
 }&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
&lt;b>Scenario 2: For testing, the database is replaced by a stub.&lt;/b> The component code should look the same whether it's&#xD;
running against the real database or the stub. So it needs to be coded to use methods of an abstract interface: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
 &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
interface KeyValuePairs&lt;/font>&lt;/b> &#xD;
  { &#xD;
     String &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
get&lt;/font>&lt;/b>(String key);&#xD;
     void &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
put&lt;/font>&lt;/b>(String key, String value);&#xD;
  }&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
Tests would implement &lt;b>KeyValuePairs&lt;/b> with something simple like a hash table: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
 &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
class FakeDatabase implements KeyValuePairs&lt;/font>&lt;/b>  &#xD;
     { &#xD;
        Hashtable table = new Hashtable(); &#xD;
        public String &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
get&lt;/font>&lt;/b>(String key) {return (String) table.get(key); } &#xD;
        public void &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
put&lt;/font>&lt;/b>(String key, String value) {table.put(key, value); }&#xD;
     }&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->When it is not being used in a test, the component would use an adapter object that&#xD;
converted calls to the &lt;font size=&quot;+0&quot;>KeyValuePairs&lt;/font> interface into SQL statements: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
 &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
class DatabaseAdapter implements KeyValuePairs&lt;/font>&lt;/b> &#xD;
    { &#xD;
      private Connection databaseConnection; &#xD;
      public DatabaseAdapter(String databaseURL) &#xD;
      {     &#xD;
        try &#xD;
        {         &#xD;
          databaseConnection = DriverManager.getConnection(databaseURL);&#xD;
          ...     &#xD;
        } catch (SQLException e) {...} &#xD;
      } &#xD;
      public String &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
get&lt;/font>&lt;/b>(String key) &#xD;
      {     &#xD;
        try &#xD;
        {         &#xD;
          Statement stmt = databaseConnection.createStatement();         &#xD;
          ResultSet rs = stmt.executeQuery(&quot;SELECT value FROM Table1 WHERE key=&quot; + key);         &#xD;
          ...     &#xD;
        } catch (SQLException e) {...} &#xD;
      } &#xD;
      public void &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
put&lt;/font>&lt;/b>(String key, String value) {... }     &#xD;
    }&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
Your component might have a single constructor for both tests and other clients. That constructor would take an object that&#xD;
implements &lt;font size=&quot;+0&quot;>KeyValuePairs&lt;/font>. Or it might provide that interface only for tests, requiring that ordinary&#xD;
clients of the component pass in the name of a database: &lt;br />&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; startspan -->&#xD;
&lt;pre>&#xD;
 class Component &#xD;
 { &#xD;
    &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
public&lt;/font>&lt;/b> Component(String databaseURL) &#xD;
    {     &#xD;
       this.valueStash = new DatabaseAdapter(databaseURL); &#xD;
    } // For testing. &lt;b>&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
protected&lt;/font>&lt;/b> &#xD;
    Component(KeyValuePairs valueStash) &#xD;
    {     &#xD;
       this.valueStash = valueStash; &#xD;
    }     &#xD;
 }&#xD;
&lt;/pre>&#xD;
&lt;!--webbot bot=&quot;HTMLMarkup&quot; endspan -->&lt;br />&#xD;
So, from the point of view of client programmers, the two design scenarios yield the same API, but one is more readily&#xD;
testable. (Note that some tests might use the real database and some might use the stub database.) &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;FurtherInformation&quot; name=&quot;FurtherInformation&quot;>Further information&lt;/a>&#xD;
&lt;/h3>&lt;br />&#xD;
For further information related to Stubs, see the following: &#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;http://www.connextra.com/aboutUs/mockobjects.pdf&quot; target=&quot;_blank&quot;>&lt;i>Endo-Testing: Unit testing with Mock&#xD;
        Objects&lt;/i>&lt;/a>, &quot;eXtreme Programming and Flexible Processes in Software Engineering - XP2000&quot;. &amp;copy; 2000 Tim&#xD;
        Mackinnon, Steve Freeman, Philip Craig.&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        &lt;br />&#xD;
         (&lt;a href=&quot;http://www.adobe.com/products/acrobat/alternate.html&quot; target=&quot;_blank&quot;>Get Adobe Reader&lt;/a>)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/tools/rup_quality_architect_3444CDC5.html&quot;&#xD;
        guid=&quot;{11A91795-5221-4C65-A9DE-EE431CEA6993}&quot;>Tool: Rational QualityArchitect&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/tools/rup_test_realtime_861C5353.html&quot;&#xD;
        guid=&quot;{18E6764A-2366-4F59-A5F2-FDF4891EBCE9}&quot;>Tool: Rational Test RealTime&lt;/a>&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul>&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
