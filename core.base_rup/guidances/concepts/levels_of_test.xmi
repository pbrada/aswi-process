<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_2ovw0NnmEdmO6L4XMImrsA" guid="_2ovw0NnmEdmO6L4XMImrsA" changeDate="2005-11-15T22:02:03.494-0800" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_test__levels_of&quot; name=&quot;XE_test__levels_of&quot;>&lt;/a>&lt;a id=&quot;XE_test__stages_of&quot;&#xD;
name=&quot;XE_test__stages_of&quot;>&lt;/a>&lt;a id=&quot;XE_stages_of_test__introduction_to&quot; name=&quot;XE_stages_of_test__introduction_to&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    Testing is applied to different types of targets, in different stages or levels of work effort. These levels are&#xD;
    distinguished typically by those roles that are best skilled to design and conduct the tests, and where techniques are&#xD;
    most appropriate for testing at each level. It's important to ensure a balance of focus is retained across these&#xD;
    different work efforts.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Developer Testing&lt;a id=&quot;XE_developer_testing__explanation_of&quot; name=&quot;XE_developer_testing__explanation_of&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_unit_test__developer_testing&quot; name=&quot;XE_unit_test__developer_testing&quot;>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Developer testing denotes the aspects of test design and implementation most appropriate for the team of developers to&#xD;
    undertake. This is in contrast to Independent Testing. In most cases, test execution initially occurs with the&#xD;
    developer testing group who designed and implemented the test, but it is a good practice for the developers to create&#xD;
    their tests in such a way so as to make them available to independent testing groups for execution.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Traditionally, developer testing has been considered mainly with respect to unit testing. While some developers also&#xD;
    perform varying levels integration testing, this is largely dependent on culture and other context issues. We recommend&#xD;
    that developer testing should cover more than just testing independent units in isolation.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Independent Testing&lt;a id=&quot;XE_independent_testing__explanation_of&quot; name=&quot;XE_independent_testing__explanation_of&quot;>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Independent testing denotes the test design and implementation most appropriately performed by someone who is&#xD;
    independent from the team of developers. You can consider this distinction a superset, which includes Independent&#xD;
    Verification &amp;amp; Validation. In most cases, test execution initially occurs with the independent testing group that&#xD;
    designed and implemented the test, but the independent testers should create their tests to make them available to the&#xD;
    developer testing groups for execution. Boris Beizer gives the following explanation of the different objective that&#xD;
    independent testing has over developer testing:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        &quot;The purpose of independent testing is to provide a different perspective and, therefore, different tests;&#xD;
        furthermore to conduct those tests in a richer [...] environment than is possible for the developer.&quot; [&lt;a&#xD;
        class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html&quot;&#xD;
        guid=&quot;7.755968586980351E-308&quot;>BEI95&lt;/a>]&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;h4>&#xD;
    Independent Stakeholder Testing&lt;a id=&quot;XE_stakeholder_testing__explanation_of&quot;&#xD;
    name=&quot;XE_stakeholder_testing__explanation_of&quot;>&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An alternate view of independent testing is that it represents testing that is based on the needs and concerns of&#xD;
    various stakeholders. Therefore it's referred to as Stakeholder Testing. This is an important distinction-it helps to&#xD;
    include a broader set of stakeholder concerns than might traditionally be considered, extending the somewhat generic&#xD;
    &quot;customer&quot; with stakeholders such as technical support staff, technical trainers, sales staff in additional to&#xD;
    customers, and users.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As a final comment, &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/guidances/termdefinitions/xp_44C77EC5.html&quot;&#xD;
    target=&quot;_blank&quot; guid=&quot;_ycX3A9nmEdmO6L4XMImrsA&quot;>&lt;i>XP&lt;/i>&lt;/a>'s notion of &lt;i>customer tests&lt;/i> relates to this&#xD;
    categorization of independent testing in the RUP.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Unit Testing&lt;a id=&quot;XE_unit_test__explanation_of&quot; name=&quot;XE_unit_test__explanation_of&quot;>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Unit testing focuses on verifying the smallest testable elements of the software. Typically unit testing is applied to&#xD;
    components represented in the implementation model to verify that control flows and data flows are covered, and that&#xD;
    they function as expected. The Implementer performs unit testing as the unit is developed. The details of unit testing&#xD;
    are described in the Implementation discipline.&#xD;
&lt;/p>&#xD;
&lt;!-- &lt;p>These expectations are based on how the component participates in executing    a use case, which you find in sequence diagrams for that use case.&lt;/p> -->&#xD;
&lt;h3>&#xD;
    Integration Testing&lt;a id=&quot;XE_integration_test__explanation_of&quot; name=&quot;XE_integration_test__explanation_of&quot;>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Integration testing is performed to ensure that the components in the implementation model operate properly when&#xD;
    combined to execute a use case. The target-of-test is a package or a set of packages in the implementation model. Often&#xD;
    the packages being combined come from different development organizations. Integration testing exposes incompleteness&#xD;
    or mistakes in the package's interface specifications.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In some cases, the assumption by developers is that other groups such as independent testers will perform integration&#xD;
    tests. This situation presents risks to the software project and ultimately the software quality because:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        integration areas are a common point of software failure.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        integration tests performed by independent testers typically use black-box techniques and are typically dealing&#xD;
        with larger software components.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A better approach is to consider integration testing the responsibility of both developer and independent testers, but&#xD;
    make the strategy of each teams testing effort does not overlap significantly. The exact nature of that overlap is&#xD;
    based on the needs of the individual project. We recommend you foster an environment where developers and independent&#xD;
    system testers share a single vision of quality. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/developer_testing_D800236F.html&quot; guid=&quot;7.256588791264849E-307&quot;>Concept:&#xD;
    Developer Testing&lt;/a> for additional information.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    System Testing&lt;a id=&quot;XE_system_test__explanation_of&quot; name=&quot;XE_system_test__explanation_of&quot;>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Traditionally system testing is done when the software is functioning as a whole. An iterative lifecycle allows system&#xD;
    testing to occur much earlier-as soon as well-formed subsets of the use-case behavior are implemented. Usually the&#xD;
    target is the system's end-to-end functioning elements.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    Acceptance Testing&lt;a id=&quot;XE_acceptance_test__explanation_of&quot; name=&quot;XE_acceptance_test__explanation_of&quot;>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    &lt;i>User&lt;/i> acceptance testing is the final test action taken before deploying the software. The goal of acceptance&#xD;
    testing is to verify that the software is ready, and that it can be used by users to perform those functions and tasks&#xD;
    for which the software was built. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/acceptance_testing_12A0F152.html&quot; guid=&quot;9.104950596799755E-305&quot;>Concept:&#xD;
    Acceptance Testing&lt;/a> for additional information.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are other notions of acceptance testing, which are generally characterized by a hand-off from one group or one&#xD;
    team to another. For example, a &lt;i>build acceptance test&lt;/i> is the testing done to accept the hand-over of a new&#xD;
    software build from development into independent testing.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    A comment about sequence and timing of test levels&lt;a id=&quot;XE_unit_test__explanation_of&quot;&#xD;
    name=&quot;XE_unit_test__explanation_of&quot;>&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Traditionally, unit testing is thought of as being implemented early in the iteration as the first stage of testing:&#xD;
    all units required to be passed before subsequent stages are conducted. However, in an iterative development process,&#xD;
    this approach is as a general rule, inappropriate. A better approach is to identify the unit, integration and system&#xD;
    tests that offer most potential for finding errors, then implement and execute them based on a combination of greatest&#xD;
    risk and supporting environment.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
