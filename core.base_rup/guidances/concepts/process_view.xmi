<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1c5owNnmEdmO6L4XMImrsA" name="process_view,6.45284088262517E-306" guid="_1c5owNnmEdmO6L4XMImrsA" changeDate="2006-02-15T12:46:51.602-0800" version="7.1.0">
  <mainDescription>&lt;p>&#xD;
    To provide a basis for understanding the process organization of the system, an architectural view called the&#xD;
    &lt;b>process view&lt;/b> is used in the Analysis &amp;amp; Design discipline. There is only one process view of the system,&#xD;
    which illustrates the process decomposition of the system, including the mapping of classes and subsystems on to &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_concepts/guidances/termdefinitions/process_68E308B4.html&quot;&#xD;
    guid=&quot;_yQ5m2NnmEdmO6L4XMImrsA&quot;>processes&lt;/a> and &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/thread_CD09F29.html&quot; guid=&quot;_yYpNkNnmEdmO6L4XMImrsA&quot;>threads&lt;/a>. The&#xD;
    process view is refined during each iteration. As [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#BOO98&quot; guid=&quot;7.755968586980351E-308&quot;>BOO98&lt;/a>] states:&#xD;
    &quot;With UML, the static and dynamic aspects of this view are captured in the same kinds of diagrams as for the design&#xD;
    view - i.e. class diagrams, interaction diagrams, activity diagrams and statechart diagrams, but with a focus on the&#xD;
    active classes that represent these threads and processes.&quot; Of concern when constructing and using the process view&#xD;
    are, for example, issues of concurrency, response time, deadlock, throughput, fault tolerance, and scalability.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It is possible to design for concurrency without the use of direct underlying operating system support - for example&#xD;
    using a specially written scheduler or other run-time support. In such cases, concurrency is simulated at the&#xD;
    application infrastructure level, rather than in the operating system. If necessary, other stereotypes (in addition to&#xD;
    the standard threads and processes) may be used to make this distinction (to guide implementation). For example, the&#xD;
    Ada programming language contains its own model of concurrency, based on Ada tasks; the Ada run-time has to provide&#xD;
    this, whether or not the operating system on which it runs has an appropriate equivalent - threads, say - which could&#xD;
    be used to support Ada tasking.&#xD;
&lt;/p>In real-time systems, the Rational Unified Process recommends the use of &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
href=&quot;./../../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html&quot; guid=&quot;{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}&quot;>Capsules&lt;/a> to&#xD;
represent active classes in the process view. Capsules have strong semantics to simplify the modeling of concurrency: &#xD;
&lt;ul class=&quot;reactive&quot;>&#xD;
    &lt;li>&#xD;
        They use asynchronous message-based communication through &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
        href=&quot;./../../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html#Ports&quot;&#xD;
        guid=&quot;{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}&quot;>Ports&lt;/a> using well-defined &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
        href=&quot;./../../../core.base_rup/workproducts/rup_protocol_BEB5FBE1.html&quot;&#xD;
        guid=&quot;{6E4F4D6F-2934-432C-9335-5537B795F67F}&quot;>Protocols&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        They use run-to-completion semantics for message processing.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        They encapsulate passive objects (ensuring that thread interference cannot occur).&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;403&quot; alt=&quot;Diagram described in accompanying content.&quot; src=&quot;./../../../core.base_rup/tasks/resources/proc3.gif&quot;&#xD;
    width=&quot;574&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The process view shows the process organization of the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are four additional views, the &lt;b>Use-Case View&lt;/b> (handled in the Requirements discipline), and the &lt;b>Logical&#xD;
    View&lt;/b>, &lt;b>Deployment View&lt;/b>, and &lt;b>Implementation View&lt;/b>; these views are handled in the Analysis &amp;amp; Design&#xD;
    and Implementation disciplines.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The architectural views are documented in a &lt;b>Software Architecture Document&lt;/b>. You may add different views, such as&#xD;
    a security view, to convey other specific aspects of the software architecture.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    So in essence, architectural views can be seen as abstractions or simplifications of the models built, in which you&#xD;
    make important characteristics more visible by leaving the details aside. The architecture is an important means for&#xD;
    increasing the quality of any model built during system development.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
