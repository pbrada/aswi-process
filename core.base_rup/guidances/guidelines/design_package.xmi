<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_15znMdnmEdmO6L4XMImrsA" name="design_package,3.3691722315666536E-305" guid="_15znMdnmEdmO6L4XMImrsA" changeDate="2005-06-21T10:26:09.091-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_design_package__guidelines_for&quot; name=&quot;XE_design_package__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    &lt;a id=&quot;XE_design_subsystem__packages_vs._subsystems&quot; name=&quot;XE_design_subsystem__packages_vs._subsystems&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_design_package__subsystems_vs._packages&quot; name=&quot;XE_design_package__subsystems_vs._packages&quot;>&lt;/a>The Design Model&#xD;
    can be structured into smaller units to make it easier to understand. By grouping Design Model elements into packages&#xD;
    and subsystems, then showing how those groupings relate to one another, it is easier to understand the overall&#xD;
    structure of the model. Note that a &lt;b>&lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/design_subsystem_AB08ECC8.html&quot; guid=&quot;_yGBMgNnmEdmO6L4XMImrsA&quot;>design&#xD;
    subsystem&lt;/a>&lt;/b> is modeled as a component that realizes one or more interfaces; for more information, see &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html&quot;&#xD;
    guid=&quot;{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}&quot;>Artifact: Design Subsystem&lt;/a> and &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html&quot; guid=&quot;1.2314266786534317E-305&quot;>Guideline:&#xD;
    Design Subsystem&lt;/a>. Design packages, on the other hand, are just for grouping.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_visibility__of_content_in_package&quot; name=&quot;XE_visibility__of_content_in_package&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_design_package__describing_how_packages_depend_on_each_other&quot;&#xD;
    name=&quot;XE_design_package__describing_how_packages_depend_on_each_other&quot;>&lt;/a>&lt;a id=&quot;Package Content Visibility&quot;&#xD;
    name=&quot;Package Content Visibility&quot;>Package Content Visibility&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A class contained in a package can be public or private. A &lt;a id=&quot;XE_public_class__in_package&quot;&#xD;
    name=&quot;XE_public_class__in_package&quot;>&lt;/a>&lt;b>public class&lt;/b> can be associated by any other class. A &lt;a&#xD;
    id=&quot;XE_private_class__in_package&quot; name=&quot;XE_private_class__in_package&quot;>&lt;/a>&lt;b>private class&lt;/b> can be associated only&#xD;
    by classes contained in the package.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A package interface consists of a package's public classes. The package interface (public classes) isolates and&#xD;
    implements the dependencies on other packages. In this way, parallel development is simplified because you can&#xD;
    establish interfaces early on, and the developers need to know only about changes in the interfaces of other packages.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_design_package__package_partitioning_criteria&quot; name=&quot;XE_design_package__package_partitioning_criteria&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Package-Partitioning Criteria&quot; name=&quot;Package-Partitioning Criteria&quot;>Package-Partitioning Criteria&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    You can partition the Design Model for a number of reasons:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        You can use packages and subsystems as order, configuration, or delivery units when a system is finished.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Allocation of resources and the competence of different development teams may require that the project be divided&#xD;
        among different groups at different sites. Subsystems, with well-defined interfaces, provide a way to divide work&#xD;
        between teams in a controlled, coordinated way, allowing design and implementation to proceed in parallel.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Subsystems can be used to structure the design model in a way that reflects the user types. Many change&#xD;
        requirements originate from users; subsystems ensure that changes from a particular user type will affect only the&#xD;
        parts of the system that correspond to that user type.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        In some applications, certain information should be accessible to only a few people. Subsystems let you preserve&#xD;
        secrecy in areas where it is needed.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If you are building a support system, you can, using subsystems and packages to give it a structure similar to the&#xD;
        structure of the system to be supported. In this way, you can synchronize the maintenance of the two systems.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a id=&quot;XE_existing_product__representing_with_packages&quot;&#xD;
        name=&quot;XE_existing_product__representing_with_packages&quot;>&lt;/a>Subsystems are used to represent the existing products&#xD;
        and services that the system uses (for example, COTS products, and libraries), as explained in the next several&#xD;
        sections.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_boundary_class__packaging&quot; name=&quot;XE_boundary_class__packaging&quot;>&lt;/a>&lt;a id=&quot;Packaging Boundary Classes&quot;&#xD;
    name=&quot;Packaging Boundary Classes&quot;>Packaging Boundary Classes&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    When the boundary classes are distributed to packages there are two different strategies that can be applied; which one&#xD;
    to choose depends on whether or not the system interfaces are likely to change greatly in the future.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        If it is likely that the system interface will be replaced, or undergo considerable changes, the interface should&#xD;
        be separated from the rest of the design model. When the user interface is changed, only these packages are&#xD;
        affected. An example of such a major change is the switch from a line-oriented interface to a window-oriented&#xD;
        interface.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_desp2.gif&quot; width=&quot;234&quot; height=&quot;148&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    If the primary aim is to simplify major interface changes, the boundary classes should be placed in one (or several)&#xD;
    separate packages.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        If no major interface changes are planned, changes to the system services should be the guiding principle, rather&#xD;
        than changes to the interface. The boundary classes should then be placed together with the entity and control&#xD;
        classes with which they are functionally related. This way, it will be easy to see what boundary classes are&#xD;
        affected if a certain entity or control class is changed.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_desp3.gif&quot; width=&quot;257&quot; height=&quot;71&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    To simplify changes to the services of the system, the boundary classes are packaged with the classes to which they are&#xD;
    functionally related.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Mandatory boundary classes that are not functionally related to any entity- or control classes, should be placed in&#xD;
    separate packages, together with boundary classes that belong to the same interface.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If a boundary class is related to an optional service, group it with the classes that collaborate to provide the&#xD;
    service, in a separate subsystem. The subsystem will map onto an optional component which will be provided when the&#xD;
    optional functionality is ordered.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_design_package__functionally_related_classes?_finding_packages_for&quot;&#xD;
    name=&quot;XE_design_package__functionally_related_classes?_finding_packages_for&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Packaging Functionally Related Classes&quot; name=&quot;Packaging Functionally Related Classes&quot;>Packaging Functionally&#xD;
    Related Classes&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A package should be identified for each group of classes that are functionally related. There are several practical&#xD;
    criteria that can be applied when judging if two classes are functionally related. These are, in order of diminishing&#xD;
    importance:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        If changes in one class' behavior and/or structure necessitate changes in another class, the two classes are&#xD;
        functionally related.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;blockquote>&#xD;
    &lt;p class=&quot;exampleheading&quot;>&#xD;
        Example&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;example&quot;>&#xD;
        If a new attribute is added to the entity class &lt;b>Order&lt;/b>, this will most likely necessitate updating the&#xD;
        control class &lt;b>Order Administrator&lt;/b>. Therefore, they belong to the same package, &lt;b>Order Handling&lt;/b>.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        It is possible to find out if one class is functionally related to another by beginning with a class - for example,&#xD;
        an entity class - and examining the impact of it being removed from the system. Any classes that become superfluous&#xD;
        as a result of a class removal are somehow connected to the removed class. By superfluous, we mean that the class&#xD;
        is only used by the removed class, or is itself dependent upon the removed class.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;blockquote>&#xD;
    &lt;p class=&quot;exampleheading&quot;>&#xD;
        Example&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;example&quot;>&#xD;
        There is a package &lt;b>Order Handling&lt;/b> containing the two control classes &lt;b>Order Administrator&lt;/b> and &lt;b>Order&#xD;
        Registrar,&lt;/b> in the &lt;b>Depot Handling System.&lt;/b> Both of these control classes model services regarding order&#xD;
        handling in the depot. All order attributes and relationships are stored by the entity class &lt;b>Order&lt;/b>, which&#xD;
        only exists for order handling. If the entity class is removed, there will be no need for the &lt;b>Order&#xD;
        Administrator&lt;/b> or the &lt;b>Order Registrar&lt;/b>, because they are only useful if the &lt;b>Order&lt;/b> is there.&#xD;
        Therefore, the entity class &lt;b>Order&lt;/b> should be included in the same package as the two control classes.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_desp4.gif&quot; width=&quot;393&quot; height=&quot;163&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
        &lt;b>Order Administrator&lt;/b> and &lt;b>Order Registrar&lt;/b> belong to the same package as &lt;b>Order&lt;/b>, because they&#xD;
        become superfluous if &lt;b>Order&lt;/b> is removed from the system.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Two objects can be functionally related if they interact with a large number of messages, or have an otherwise&#xD;
        complicated intercommunication.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;blockquote>&#xD;
    &lt;p class=&quot;example&quot;>&#xD;
        &lt;b>Example&lt;/b>&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;example&quot;>&#xD;
        The control class &lt;b>Task Performer&lt;/b> sends and receives many messages to and from the &lt;b>Transporter&#xD;
        Interface.&lt;/b> This is another indication that they should be included in the same package, &lt;b>Task Handling.&lt;/b>&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A boundary class can be functionally related to a particular entity class if the function of the boundary class is&#xD;
        to present the entity class.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;blockquote>&#xD;
    &lt;p class=&quot;example&quot;>&#xD;
        &lt;b>Example&lt;/b>&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;example&quot;>&#xD;
        The boundary class, &lt;b>Pallet Form&lt;/b>, in the &lt;b>Depot Handling System&lt;/b>, presents an instance of the entity&#xD;
        class &lt;b>Pallet&lt;/b> to the user. Each &lt;b>Pallet&lt;/b> is represented by an identification number on the screen. If&#xD;
        the information about a &lt;b>Pallet&lt;/b> is changed, for example, if the &lt;b>Pallet&lt;/b> is also given a name, the&#xD;
        boundary class might have to be changed as well. &lt;b>Pallet Form&lt;/b> should therefore be included in the same&#xD;
        package as &lt;b>Pallet&lt;/b>.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Two classes can be functionally related if they interact with, or are affected by changes in, the same actor. If&#xD;
        two classes do not involve the same actor, they should not lie in the same package. The last rule can, of course,&#xD;
        be ignored for more important reasons.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;blockquote>&#xD;
    &lt;p class=&quot;example&quot;>&#xD;
        &lt;b>Example&lt;/b>&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;example&quot;>&#xD;
        There is a package &lt;b>Task Handling&lt;/b> in the &lt;b>Depot Handling System&lt;/b>, which includes, among other things,&#xD;
        the control class &lt;b>Task Performer&lt;/b>. This is the only package involved with the actor &lt;b>Transporter&lt;/b>, the&#xD;
        physical transporter that can transport a pallet in the depot. The actor interacts with the control class &lt;b>Task&#xD;
        Performer&lt;/b> via the boundary class &lt;b>Transporter Interface.&lt;/b> This boundary class should therefore be included&#xD;
        in the package &lt;b>Task Handling&lt;/b>.&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;example&quot; align=&quot;center&quot;>&#xD;
        &lt;img src=&quot;resources/md_desp5.gif&quot; width=&quot;470&quot; height=&quot;163&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;picturetext&quot;>&#xD;
        &lt;b>Transporter Interface&lt;/b> and &lt;b>Task Performer&lt;/b> belong to the same package since both of them are affected&#xD;
        by changes in the &lt;b>Transporter&lt;/b> actor.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Two classes can be functionally related if they have relationships between each other (associations, aggregations,&#xD;
        and so on). Of course, this criterion cannot be followed mindlessly, but can be used when no other criterion is&#xD;
        applicable.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A class can be functionally related to the class that creates instances of it.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    These two criteria determine when two classes should &lt;b>not&lt;/b> be placed in the same package:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Two classes that are related to different actors should not be placed in the same package.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        An optional and a mandatory class should not be placed in the same package.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Evaluating Package Cohesion&quot; name=&quot;Evaluating Package Cohesion&quot;>Evaluating Package Cohesion&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    First, all elements in a package must have the same optionality: there can be no optional model elements in a mandatory&#xD;
    package.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The mandatory entity class &lt;b>Article Type&lt;/b> has, among other things, an attribute called &lt;b>Restock Threshold&lt;/b>.&#xD;
    The restock function, however, is optional in the system. Therefore, &lt;b>Article&lt;/b> should be split up into two entity&#xD;
    classes, where the optional class relates the mandatory one.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A package that is considered mandatory might not depend on any package that is considered optional.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As a rule, a single package can not be used by two different actors. The reason for this is that a change in one&#xD;
    actor's behavior should not affect other actors as well. There are exceptions to this rule, such as for packages that&#xD;
    constitute optional services. Packages of this type should not be divided, no matter how many actors use it. Therefore,&#xD;
    split any package, or class, that is used by several actors unless the package is optional.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    All classes in the same package must be functionally related. If you have followed the criteria in the section &quot;Find&#xD;
    packages from Functionally Related Classes,&quot; the classes in one package will be functionally related among themselves.&#xD;
    However, a particular class might in itself contain &quot;too much&quot; behavior, or relationships that do not belong to the&#xD;
    class. Part of the class should then be removed to become a completely new class, or to some other class, which&#xD;
    probably will belong to another package.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The behavior of a control class, &lt;b>A&lt;/b>, in one package should not depend too much on a class, &lt;b>B&lt;/b>, in another&#xD;
    package. To isolate the &lt;b>B&lt;/b>-specific behavior, the control class &lt;b>A&lt;/b> must be split into two control classes,&#xD;
    &lt;b>A'&lt;/b> and &lt;b>A&quot;&lt;/b>. The &lt;b>B&lt;/b>-specific behavior is placed in the new control class, &lt;b>A&quot;&lt;/b>, which is placed&#xD;
    in the same package as &lt;b>B&lt;/b>. The new class &lt;b>A&quot;&lt;/b> also gets a relationship, such as generalization, to the&#xD;
    original object &lt;b>A'&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_desp6.gif&quot; width=&quot;316&quot; height=&quot;206&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    To isolate the &lt;b>B&lt;/b>-specific behavior, the control class &lt;b>A&lt;/b>, which lacks homogeneity, is split into two&#xD;
    control classes, &lt;b>A'&lt;/b> and &lt;b>A''&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Describing Packages Dependendencies&quot; name=&quot;Describing Packages Dependendencies&quot;>Describing Package&lt;/a>&#xD;
    Dependencies&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    If a class in one package has an association to a class in a different package, then these packages depend on each&#xD;
    other. Package dependencies are modeled using a dependency relationship between the packages. Dependency relationships&#xD;
    help us to assess the consequence of changes: a package upon which many packages depend is more difficult to change&#xD;
    than one upon which no packages depend.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Because several dependencies like this will be discovered during the specification of the packages, these relationships&#xD;
    are bound to change during the work. The description of a dependency relationship might include information about what&#xD;
    class relationships have caused the dependency. Since this introduces information that is difficult to maintain, it&#xD;
    should be done only if the information is pertinent and of value.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In the &lt;b>Depot Handling System&lt;/b> there is a dependency relationship from the package &lt;b>Order Handling&lt;/b> to the&#xD;
    package &lt;b>Item Handling.&lt;/b> This association arises because the entity class &lt;b>Order&lt;/b> in &lt;b>Order Handling&lt;/b>&#xD;
    has an association to the entity class &lt;b>Item Type&lt;/b> in the other package.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot; align=&quot;center&quot;>&#xD;
    &lt;img src=&quot;resources/md_desp7.gif&quot; width=&quot;264&quot; height=&quot;256&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The package &lt;b>Order Handling&lt;/b> is dependent on &lt;b>Item Handling&lt;/b>, because there is an association between two&#xD;
    classes in the packages.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Evaluating Package Coupling&quot; name=&quot;Evaluating Package Coupling&quot;>Evaluating Package Coupling&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Package coupling is good and bad: good, because coupling represent re-use, and bad, because coupling represents&#xD;
    dependencies that make the system harder to change and evolve. Some general principles can be followed:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Packages should not be cross-coupled (i.e. co-dependent); e.g. two packages should not be dependent on one another.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;blockquote>&#xD;
    &lt;p align=&quot;center&quot;>&#xD;
        &lt;img src=&quot;resources/md_dpkg1.gif&quot; width=&quot;300&quot; height=&quot;109&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;picturetext&quot;>&#xD;
        In these cases, the packages need to be reorganized to remove the cross-dependencies.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Packages in lower layers should not be dependent upon packages in upper layers. Packages should only be dependent&#xD;
        upon packages in the same layer and in the next lower layer.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;blockquote>&#xD;
    &lt;p align=&quot;center&quot;>&#xD;
        &lt;img src=&quot;resources/md_dpkg2.gif&quot; width=&quot;200&quot; height=&quot;239&quot; alt=&quot;Diagram described in accompanying text.&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p class=&quot;picturetext&quot;>&#xD;
        In these cases, the functionality needs to be repartitioned. One solution is to state the dependencies in terms of&#xD;
        interfaces, and organize the interfaces in the lower layer.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        In general, dependencies should not skip layers, unless the dependent behavior is common across all layers, and the&#xD;
        alternative is to simply pass-through operation invocations across layers.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Packages should not depend on subsystems, only on other packages or on interfaces.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
