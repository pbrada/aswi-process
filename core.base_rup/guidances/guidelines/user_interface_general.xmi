<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1l_TVNnmEdmO6L4XMImrsA" name="user_interface_general,6.780901688276357E-305" guid="_1l_TVNnmEdmO6L4XMImrsA" changeDate="2005-11-15T19:56:57.679-0800" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_window-based_user_interfaces__fundamentals&quot; name=&quot;XE_window-based_user_interfaces__fundamentals&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Window Fundamentals: Setting the Context&quot; name=&quot;Window Fundamentals: Setting the Context&quot;>&lt;/a>Window Fundamentals:&#xD;
    Setting the Context&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This section gives an overview of the anatomy of a window-based user interface. This overview is necessary to&#xD;
    understand the rest of these guidelines.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A window-based user interface is divided into windows. Windows can be moved around the screen, stacked on top of each&#xD;
    other, and iconified. A system usually has one primary window, and a number of secondary windows. The primary window&#xD;
    handles the major interaction with the user, and often contains an arbitrary number of objects. Secondary windows are&#xD;
    used to support the interactions with primary windows by providing details about their objects and operations on those&#xD;
    objects.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Primary Windows&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The primary window often contains an arbitrary number of objects with which the user interacts. The user typically&#xD;
    interacts with the system by first selecting one or several objects, for example by clicking on them, and then choosing&#xD;
    an operation (for example, using a menu) that is executed on all the selected objects. Common operations are&#xD;
    &lt;b>Cut&lt;/b>, &lt;b>Copy&lt;/b>, &lt;b>Paste&lt;/b>, &lt;b>Delete&lt;/b>, and &lt;b>View Properties&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The primary window normally contains a menu bar, from which users can choose operations. Users can also choose&#xD;
    operations through pop-up menus (by right-clicking on the object itself) and by direct manipulation (by clicking and&#xD;
    dragging the object). Since the total number of objects may not fit within the primary window, users can often scroll&#xD;
    through the objects using a scroll bar, or resize the window. In addition, the primary window can often be divided into&#xD;
    panes (defining sub-areas of the window), that the user can also resize.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Composites&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A composite object in a user interface is an object that is visually composed of other objects. For example, a&#xD;
    &lt;b>paragraph&lt;/b> is a composite of &lt;b>characters&lt;/b>, or a &lt;b>complex drawing object&lt;/b> is a composite of more&#xD;
    &lt;b>primitive drawing objects&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Secondary Windows&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Secondary windows support the primary windows by providing details (such as properties) about their objects, and&#xD;
    operations on those objects. Only a few of the objects' properties are normally shown in the primary window. Properties&#xD;
    of an object can be viewed by opening a property window (which is a secondary window) that shows all the attributes of&#xD;
    an object. The user can often change the attributes by controls such as toggle and radio buttons, scales, combo boxes,&#xD;
    and text fields.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that there is a fine, and sometimes quite artificial, line between primary windows and secondary windows-they may&#xD;
    display the same levels of complexity. However, two main differences between primary and secondary windows are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Primary windows are often considered to be more important to the application since they need to provide extensive&#xD;
        usability. Therefore, development efforts tend to be more focused on the primary windows.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Secondary windows are often displayed by navigating through primary windows, and not vice versa.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In addition to property windows, there are other types of secondary windows, such as dialog boxes, message boxes,&#xD;
    palettes, and pop-up windows.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Many applications are file based. Users can start these applications with the &lt;b>Open&lt;/b> operation on a file object&#xD;
    (for example, by double-clicking a file icon in a folder). Their primary window shows the objects stored in that file.&#xD;
    Common operations on files are &lt;b>Save&lt;/b>, &lt;b>Save As&lt;/b>, &lt;b>Open&lt;/b>, and &lt;b>New&lt;/b>, which can usually be selected&#xD;
    through a file menu in the primary window. The primary window can also usually display multiple files (also called&#xD;
    Multiple Document Interface, or MDI), thereby allowing the user to switch between different files.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_visual_dimensions__introduction_to&quot; name=&quot;XE_visual_dimensions__introduction_to&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Visual Dimensions&quot; name=&quot;Visual Dimensions&quot;>&lt;/a>Visual Dimensions&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The key to usable primary windows is to use the visual dimensions when visualizing the contained objects and their&#xD;
    attributes. The advantages of presenting more attributes than are necessary for identification are that:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The user avoids window navigation overhead since you decrease the number of windows that must be shown (when the&#xD;
        user needs to see an attribute that is presented in the primary window).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The user can see the different aspects (of different objects) at the same time, which are often useful for&#xD;
        comparisons and for starting to recognize patterns. A good use of the visual dimensions can encourage users to&#xD;
        develop an entirely new fingertip feeling for their work.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The visual dimensions are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Position&quot;>Position&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Size&quot;>Size&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Shape&quot;>Shape&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Color&quot;>Color&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    These dimensions are presented below. However, beware of the available screen area when designing the visualization of&#xD;
    the objects. Try to make the overhead when exploiting the screen area as small as possible, and consider if using&#xD;
    several visual dimensions is worth the extra expenditure of screen area. Maybe the user is better served by just a list&#xD;
    of names, because what the user really needs is to see as many objects as possible.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that it is important to use these visual dimensions, or extend them, to be able to uniquely identify objects. We&#xD;
    also include a discussion on this subject below (see the section &quot;&lt;a href=&quot;#Identification&quot;>Identification&lt;/a>&quot; below).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Also note that the visual dimensions can be used in correlation with the time dimension, for example by moving objects&#xD;
    (their position is changed through time), or by changing the shape or color of objects (their state is changed through&#xD;
    time); the latter case is discussed in the section &quot;&lt;a href=&quot;#Shape&quot;>Shape&lt;/a>&quot; below.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_visual_dimensions__position&quot; name=&quot;XE_visual_dimensions__position&quot;>&lt;/a>&lt;a id=&quot;Position&quot;&#xD;
    name=&quot;Position&quot;>&lt;/a>Position&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The most intuitive aspects that position can present is real-world positions. Examples are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Geographical Information Systems (GIS) that display a map on which you present the objects on the same longitude&#xD;
        and latitude as they have in the real world.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Computer Aided Design (CAD) programs that present the objects and their environment exactly according to their&#xD;
        real-world coordinates.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        What You See Is What You Get (WYSIWYG) editors that display the objects (characters) in the same location on the&#xD;
        window as they will appear on a paper printout.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Sometimes it is relevant to show real-world size (the CAD-program and WYSIWYG editor examples), and sometimes it is&#xD;
    not; for example, when the size of the objects is much smaller than the distance between the objects.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For example, imagine we have a flight booking system where the user must enter destinations. A possible presentation&#xD;
    for this would be to display a map containing the different airports (where an airport is an object). Naturally, since&#xD;
    the real-world sizes of the airports are irrelevant (as well as too small to be seen), all airports are shown as icons&#xD;
    that are the same size.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This example also illustrates that real-world positions can be used even if they are not relevant, as long as they help&#xD;
    the user to identify the objects. In the example, the user doesn't need to know the location of an airport. But, if the&#xD;
    user is familiar with geography, it can be easier to find destinations on a map than in a list.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You can also use position to represent &quot;virtual&quot; real-world positions. For example, imagine a home shopping system&#xD;
    where the users can buy things from different stores. A possible presentation for this would be to display a schematic&#xD;
    picture of a (virtual) mall on which the different stores are positioned (where a store is an object). This schematic&#xD;
    picture has nothing to do with the real locations of these stores-it only exploits the user's spatial memory: it is&#xD;
    easier to remember an x-y position than it is to remember an item in a list or hierarchy.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another alternative use for position is to show associations between objects: all objects that have the same vertical&#xD;
    position are associated in one way, and all objects that have the same horizontal position are associated in another&#xD;
    way. Spreadsheets are an example of this.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A similar alternative is to let one axis represent the value range of some attribute. For example, in a travel booking&#xD;
    system, booked flights (where a flight is an object) could be presented along a horizontal time axis showing their&#xD;
    relation in time, how long they will last, and the length of time the user will stay at each destination. These are all&#xD;
    things that the user doesn't have to know, but they are nice to see if they can be presented unobtrusively.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you don't want to use so much screen area by presenting the whole value range, you can collapse the distances&#xD;
    between the objects. In the travel booking example, this would mean that all booked flights are laid out horizontally&#xD;
    with no spaces in between, but the first flight is to the left, the second flight is immediately to the right of the&#xD;
    first flight, and so on. Users wouldn't see the length of time they could stay at each destination, but they could see&#xD;
    how long the flights would last.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_visual_dimensions__size&quot; name=&quot;XE_visual_dimensions__size&quot;>&lt;/a>&lt;a id=&quot;Size&quot; name=&quot;Size&quot;>&lt;/a>Size&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In many cases &quot;size&quot; must represent the same thing as position. In a CAD-system, for example, size must naturally&#xD;
    represent real-world extent. Sometimes, however, we are free to choose what size should represent, for example the&#xD;
    airports on the map that supported the destination selection.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In these cases, size should represent what is most intuitively perceived as the real-world size of the object. For a&#xD;
    file, object size should represent amount of disk space occupied. For a bank account, object size should represent&#xD;
    balance. For most sizes, a logarithmic scale is better than a proportional scale, since a proportional scale normally&#xD;
    consumes too much screen area.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Size is actually so intuitive that you can consider showing it even if it is not relevant. After all, in the real&#xD;
    world, different things (objects) occupy different proportions of our visual field because of their different size. And&#xD;
    that is not obtrusive; it only helps us discriminate between the things. Similarly, using different sizes in the user&#xD;
    interface will often help users discriminate between different objects.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Size should normally be used to present only one attribute, even though it would be possible to let horizontal extent&#xD;
    present one attribute and vertical extent present another (which is rather non-intuitive, and might confuse the user).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Either horizontal extent or vertical extent should be (logarithmically) proportional to the attribute that size is to&#xD;
    illustrate-the other extent should be fixed (or dependent on the length of the name, for example). If both horizontal&#xD;
    and vertical extent is proportional to the same attribute, it seldom adds any value: it seems obtrusive and just&#xD;
    consumes more screen area.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_visual_dimensions__shape&quot; name=&quot;XE_visual_dimensions__shape&quot;>&lt;/a>&lt;a id=&quot;Shape&quot; name=&quot;Shape&quot;>&lt;/a>Shape&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Shapes are normally represented by icons in a graphical user interface; shape is best used to represent type because it&#xD;
    is more intuitive to map out a difference in looks than it is to map out a difference in type. In the real world,&#xD;
    different objects of the same type of thing normally look similar, while objects of different types look different. For&#xD;
    example, different objects of chair look similar (they all have four legs, a seat and a backrest), while a car looks&#xD;
    very different from a chair.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    So, what are the criteria for when different objects are of different types? Well, different classes should certainly&#xD;
    be considered as different types. Also, some attributes are &quot;type-like.&quot; These attributes must have a limited set of&#xD;
    possible values and their value normally determines what can be done with the object (in terms of operations and&#xD;
    possible values of other attributes). This is the same as in the real world-the most important difference between chair&#xD;
    and car is how they are used: a chair is used for rest and a car is used for transportation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    However, when you analyze what should be considered different types, remember that the most important thing is: which&#xD;
    attribute will the user most likely perceive as a type.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you don't have multiple classes or any &quot;type&quot;-like attribute, you can use icons to represent the different values&#xD;
    for some other limited-value attribute, but only if this attribute is of central interest to the user.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Icons are also often used to show different states of the object (in addition to showing the type). When you select an&#xD;
    object, it is usually displayed in either of two ways: the color changes to black, or it displays a rectangle around&#xD;
    it. Another possible state is that you have opened a property window for the object. Normally, you also have other&#xD;
    application specific states that could be displayed, such as whether or not an e-mail has been read. Just make sure&#xD;
    that the presentation of state doesn't make it harder for the user to perceive the type and vice versa.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_visual_dimensions__color&quot; name=&quot;XE_visual_dimensions__color&quot;>&lt;/a>&lt;a id=&quot;Color&quot; name=&quot;Color&quot;>&lt;/a>Color&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Color can be divided into three components, based on visual perception. These are: hue (that is, red, blue, brown, and&#xD;
    so forth), saturation, and darkness. However, you should not use different components to represent different&#xD;
    attributes, since this will be too difficult for the user to perceive.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Hue could be used to represent type or attributes with a limited set of possible values. However, it is better to use&#xD;
    an icon for this, because the icon can be designed so that the user understands what value it represents, while there&#xD;
    is no such intuitive mapping out between color content and (most types of) values. Hue can thus be used instead of&#xD;
    icons, if no intuitive icons can be found. An alternative if you have many type icons is to use hue for categorizing&#xD;
    the type icons (so that some icons with a similar meaning are red, some with another meaning are blue, and so on).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Saturation could be used to represent an attribute with a value range, but this will lead to a rather ugly and&#xD;
    obtrusive user interface-using different saturation is unsettling to the eye and using high saturation is rather&#xD;
    obtrusive.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Darkness is the most usable component of color. It can be used to represent an attribute with a value range, and it is&#xD;
    so unobtrusive that it can be used also for attributes of secondary importance. For darkness to be unobtrusive, you&#xD;
    should not go from no darkness (white) to full darkness (black) but only from low darkness (light gray) to high&#xD;
    darkness (dark gray). For many systems where the users create most of the objects, it is very useful to present objects&#xD;
    according to age; for example, the amount of time since the last change. This helps users identify the object they want&#xD;
    to work with (which is often the object with the shortest &quot;time since last change&quot;). So, if you don't have a&#xD;
    value-range attribute that you really need to present to the user, consider presenting age.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Often color is used to make the icons more esthetically appealing and that also helps the user quickly discriminate&#xD;
    between the icons. If you provide multicolored icons, you should probably not use color for other purposes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Since some people are color blind, and since not all screens support color, you should not use color as the only means&#xD;
    of showing some vital information. On the other hand, a well-planned and non-obtrusive use of color makes the user&#xD;
    interface more esthetically appealing.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_visual_dimensions__further_aspects,_identification&quot;&#xD;
    name=&quot;XE_visual_dimensions__further_aspects,_identification&quot;>&lt;/a>&lt;a id=&quot;Identification&quot;&#xD;
    name=&quot;Identification&quot;>&lt;/a>Identification&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The user must be able to uniquely identify each object. Sometimes the other visual dimensions are enough for&#xD;
    identification, but most often they are not. Displaying a name within or close to the icon is the most popular&#xD;
    technique for supporting identification. The advantage of names is that a very small screen area can display a large&#xD;
    number of distinctly different names.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It is best if a name can be generated from an attribute value (that is normally textual). The alternative is to let&#xD;
    users specify the names when they create the objects, but this takes some time, and thus reduces usability.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Sometimes you can shape the icon so that the name can be contained within the icon. This saves screen area and provides&#xD;
    a stronger indication of the relation between the icon and the name. However, this can create the following problems:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The icon has to be empty in the middle (where the name appears).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Names have variable lengths, which means that either the icon's horizontal extent must depend on the length of the&#xD;
        name, or that some names must be truncated.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The icon must be much wider than it is high, since all text of reasonable length is longer than it is wide.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    As a result, you often have to display the name below or to the right of the icon, which has the advantage that it&#xD;
    consumes less screen area but the disadvantage that the object (icon + name) becomes even wider than it is high. If you&#xD;
    don't have enough space to display the name at all (which is possible, because you can usually identify an icon without&#xD;
    naming it), you can display the name through pop-up windows that display when the cursor is above the icon.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The font of the name can be used to display a limited-choice attribute, if you can find an intuitive mapping between&#xD;
    font and attribute values; for example, you could use bold or italics to distinguish the object, or emphasize&#xD;
    importance. In most cases, however, it is not appropriate to use the font, since it's rather obtrusive and seldom&#xD;
    intuitive.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you show the name (or, for that matter, any other text that the user is allowed to change), you should support&#xD;
    editing the name directly in the primary window. The alternative would be for the user to request a rename-operation&#xD;
    and then enter the new name, or to open the property window and edit the name there. Not only is it faster to edit the&#xD;
    name directly in the primary window, but it also supports the principle &quot;where you see it is where you change it.&quot;&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__select&quot; name=&quot;XE_user-interface_guidelines__select&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_user-interface_guidelines__find&quot; name=&quot;XE_user-interface_guidelines__find&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_power_find_and_select__user-interface_guidelines&quot;&#xD;
    name=&quot;XE_power_find_and_select__user-interface_guidelines&quot;>&lt;/a>&lt;a id=&quot;Power Find and Select&quot;&#xD;
    name=&quot;Power Find and Select&quot;>&lt;/a>Power Find and Select&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    If the group of objects that should be changed or operated on is composed so that the user can express selection&#xD;
    criteria identifying them, the search tool of the primary window can solve the problem by always selecting all criteria&#xD;
    matches.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are two possible ways of managing the search:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        All objects to which the search criteria apply are selected in the primary window. If you cannot guarantee that all&#xD;
        found objects are shown simultaneously in the primary window (because they may be too far apart), you can also&#xD;
        display a hit list in the search window. After a search, the user either specifies additional search criteria or&#xD;
        performs an operation on the selected objects. The advantage of this approach is that it enables the user to order&#xD;
        some operation on all objects conforming to the search criteria.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        You provide a &lt;b>Search&lt;/b> button in the search window that selects the next object conforming to the search&#xD;
        criteria and scrolls the contents of the primary window so that this object is visible. After a search, the user&#xD;
        can perform an operation on the selected object and then continue to search sequentially through the objects&#xD;
        conforming to the search criteria. The advantage of this approach is that the user can see each found object in its&#xD;
        surroundings (in the primary window rather than in a separate hit list).&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In many cases, you will want to combine the two cases, for example by including a &lt;b>Select All&lt;/b> button in the&#xD;
    sequential search window or a &lt;b>View Next&lt;/b> button in the parallel search window.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__sorting&quot; name=&quot;XE_user-interface_guidelines__sorting&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_sorting__user-interface_guidelines&quot; name=&quot;XE_sorting__user-interface_guidelines&quot;>&lt;/a>&lt;a id=&quot;Sorting&quot;&#xD;
    name=&quot;Sorting&quot;>&lt;/a>Sorting&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    An example of sorting may be that the system arranges all objects vertically, in alphabetical order by name or&#xD;
    according to the value of an attribute. The user then browses the objects by scrolling. This is the simplest possible&#xD;
    browsing support both with respect to implementation and to user operation. Sorting works best when the user always&#xD;
    knows the name (or the attribute that we sorted according to) of the object that is wanted. An example of a system that&#xD;
    should be implemented this way is a telephone book. The primary window should often have an operation for changing the&#xD;
    sorting order and/or criteria.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__user-controlled_inheritance&quot;&#xD;
    name=&quot;XE_user-interface_guidelines__user-controlled_inheritance&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_user-controlled_inheritance__user-interface_guidelines&quot;&#xD;
    name=&quot;XE_user-controlled_inheritance__user-interface_guidelines&quot;>&lt;/a>&lt;a id=&quot;User-Controlled Inheritance&quot;&#xD;
    name=&quot;User-Controlled Inheritance&quot;>&lt;/a>User-Controlled Inheritance&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    An example of user-controlled inheritance is WYSIWYG-editors where you define what &quot;style&quot; each paragraph belongs to&#xD;
    and then define how this style (that is, every character belonging to this style) should be laid out.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A disadvantage compared to a search tool is that user-controlled inheritance supports only change of attributes (and&#xD;
    possibly associations) for multiple objects, but not the performing of operations. Also user-controlled inheritance&#xD;
    adds overhead in that the user must explicitly define and maintain the groups (that is, the available styles). It is&#xD;
    also a more complicated concept.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    However, if search criteria cannot be specified for the objects, or if the user needs to make relative changes to the&#xD;
    attribute values (like increase by two), then providing user-controlled inheritance may be a solution.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For user-controlled inheritance to be useful, the nature of the class must be such that the objects can be categorized&#xD;
    into groups (that have some logical meaning to the user) in which most of the attribute values are the same.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An advantage compared to a search tool is that user-controlled inheritance supports override; for example, change the&#xD;
    attribute value but only if it has not been explicitly defined in the object. Also user-controlled inheritance can&#xD;
    enable the user to make more generic (and thus powerful) attribute value definitions; for example, inherit the font&#xD;
    from this style, but make it two pixels bigger. User-controlled inheritance is particularly useful when the groups have&#xD;
    no easy-to-specify search criteria.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The class for which you will support user-controlled inheritance can either inherit itself or you can create a new&#xD;
    class from which purpose is to be inherited. Making the class inherit itself is a little bit more powerful, since the&#xD;
    same object can be used both to inherit from and to do the things originally intended for the object, like being an&#xD;
    invoice, being an account, and so forth. This leads to fewer classes for the user (and the system) to manage. On the&#xD;
    other hand, creating a new class to inherit from has the advantage of being easier to comprehend since inheritance is&#xD;
    clearly separated from the normal operation of the class. Creating a new class is the best solution in most cases,&#xD;
    especially if the users have not great experience with computers and object-oriented models. The new class you create&#xD;
    should preferably inherit itself to support multiple levels of inheritance.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For most systems, the user often has to change the inheritance group for particular objects since the user does not&#xD;
    know in advance exactly how the inheritance groups should be structured. Provide an operation for that.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If you decide to support user-controlled inheritance in your system, analyze what things (attributes, associations,&#xD;
    class) need to be inherited and then support inheritance only for these things. This will lead to a less generic but&#xD;
    easier way (for both users and developers) to manage functionality. Model those things that should be inherited in your&#xD;
    new class. Many attributes will then be modeled both in the inheriting class and in the inherited class. Remember that&#xD;
    user-controlled inheritance is meant to save time for the user, not for you. If the class inherits itself, this implies&#xD;
    that everything is inheritable.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Decide if the user really needs to create new objects of the inherited class or if the system can provide a sufficient&#xD;
    number of objects once and for all. Prohibiting the user from creating new objects will greatly decrease the&#xD;
    flexibility of inheritance but on the other hand it will make it easier to operate.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Also decide if changes to numerical attributes in the inheriting objects should be interpreted as relative to the&#xD;
    inherited value or as fixed. Say, for example, that an object inherits font size 12 and user changes it to 14. By&#xD;
    relative interpretation, the system will remember the object's font size as inherited value +2; that is, if the font&#xD;
    size of the inherited object changes the font size, the inheriting object will also change the font size. If you&#xD;
    support relative interpretation, it should be noted on the attribute of the inherited object (because that's where you&#xD;
    look when you want to examine inheritance). It is important that the relative interpretation is presented to the user&#xD;
    (e.g., &quot;font size: 12+2=14,&quot; rather than just &quot;font size: 14&quot;). You can explore with scenarios to find situations in&#xD;
    favor of relative or fixed interpretation. You may have to support both.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Since user-controlled inheritance is only for intermediate and power-users, you must design it so that it will not&#xD;
    interfere with normal use (for example, when the user doesn't use inheritance); otherwise, novice users will be&#xD;
    intimidated.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Remember that the user-controlled inheritance you construct is intended to make life easier for the user; it doesn't&#xD;
    have to be generic or pure, but it has to be usable.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__browsing_hierarchies&quot;&#xD;
    name=&quot;XE_user-interface_guidelines__browsing_hierarchies&quot;>&lt;/a>&lt;a id=&quot;Browsing Hierarchies&quot;&#xD;
    name=&quot;Browsing Hierarchies&quot;>&lt;/a>&lt;a id=&quot;XE_browsing_hierarchies__user-interface_guidelines&quot;&#xD;
    name=&quot;XE_browsing_hierarchies__user-interface_guidelines&quot;>Browsing Hierarchies&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A browsing hierarchy allows the user (or possibly the system) to categorize the objects into primary windows or&#xD;
    composites, which are organized hierarchically. Browsing hierarchies ensures that the user only has to search one (or a&#xD;
    few) categories. This reduces the number of objects that have to be displayed at a given point in time. A drawback is&#xD;
    that the user (usually) have to manage the categorization. An example of this technique is file browsers: the reason&#xD;
    for having directories or folders is to help the user find files.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_window_management__user-interface_guidelines&quot; name=&quot;XE_window_management__user-interface_guidelines&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_user-interface_guidelines__window_management&quot; name=&quot;XE_user-interface_guidelines__window_management&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Window Management&quot; name=&quot;Window Management&quot;>&lt;/a>Window Management&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Window size and position is usually in complete user control. You can, however, consider reducing windowing overhead by&#xD;
    letting the system influence size and position of windows.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The bigger a primary window is, the more objects can be shown, but the more screen area is also consumed. A primary&#xD;
    window should normally show as many objects as possible but without unnecessary consumption of screen area.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Make each primary window big enough that all objects can be shown, but not bigger than the screen. Make each&#xD;
        primary window big enough to show the whole objects but avoid areas that don't show anything useful like the&#xD;
        margins in a desktop publisher. Even if you have space for showing these empty areas, they might obscure other&#xD;
        applications.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Remember that a user resizes between sessions. If the number of objects increases, increase window size so much&#xD;
        that all objects are visible, unless it is already full screen height or if the user has chosen a size that is&#xD;
        smaller than the default. If the number of objects decreases, decrease the size, unless the user has chosen a size&#xD;
        greater than the default. This rule ensures that you follow the intention of the user's resizing operations.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A possible further limitation on the size of a primary window is if you often need to use the application in parallel&#xD;
    with other applications. Then you might maximize default size of the window to half screen (as opposed to full screen).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Make the default position of a primary window so that it obscures as little as possible of other applications. If you&#xD;
    have to obscure some windows, chose those that have been unused for longest time, and try to leave at least a little&#xD;
    bit of the windows visible so that the user can easily activate them.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A disadvantage with applying the rules above is that it will take some amount of control away from the user (the system&#xD;
    will resize a window without being asked, and not remember user repositioning between sessions). Therefore, if you&#xD;
    apply these rules, you should allow the user to switch them off (with a control).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For secondary windows, their size and position should be such that they don't obscure the window they were called from&#xD;
    and possibly so that they don't obscure other secondary windows. If they must obscure the window they were called from,&#xD;
    try to make sure that they don't obscure selected objects. Obscuring vital things, like selected objects, is a common&#xD;
    usability flaw for secondary windows.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For primary windows other than the main primary window, you should also apply the sizing rule of the last paragraph.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Dialog boxes, however, should be placed so that they obscure the active window. Since they are normally temporary and&#xD;
    small, the user usually doesn't need to see the active window while the dialog window is open. Placing dialog boxes&#xD;
    over the active window makes sure that the user acknowledges them, and decreases necessary mouse movement since the&#xD;
    cursor is normally already over the active window.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For property windows, the number of attributes determines the size. If the size is too big (approximately 1/4 of the&#xD;
    screen), you should use more tabs.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__session_information&quot;&#xD;
    name=&quot;XE_user-interface_guidelines__session_information&quot;>&lt;/a>&lt;a id=&quot;XE_session_information__user-interface_guidelines&quot;&#xD;
    name=&quot;XE_session_information__user-interface_guidelines&quot;>&lt;/a>&lt;a id=&quot;Session Information&quot;&#xD;
    name=&quot;Session Information&quot;>&lt;/a>Session Information&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    All application configurations should be saved between sessions (without the user having to specify it). The size and&#xD;
    position of windows, which view is selected, and the positions of scroll bars should also be saved. When users restart&#xD;
    an application, it should look exactly as when they exited it the last time. The motive for this is that usually the&#xD;
    first thing users will do when starting a session is to work back to where they were when they exited the last session.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__online_help&quot; name=&quot;XE_user-interface_guidelines__online_help&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_online_help__user-interface_guidelines&quot; name=&quot;XE_online_help__user-interface_guidelines&quot;>&lt;/a>&lt;a id=&quot;Online Help&quot;&#xD;
    name=&quot;Online Help&quot;>&lt;/a>Online Help&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Online help is a very important part of the system. A well-designed help system should even be able to replace the user&#xD;
    manuals for most systems. Most projects spend considerable efforts on constructing and producing manuals when it is a&#xD;
    known fact that most users never use them. You should consider investing these efforts in a good help system instead.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are a number of possible help tools you should consider:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Help-on-subject&lt;/b> is the most important help tool. It lets the user enter a subject or browse an existing&#xD;
        subject and provides help on these subjects. The key is to provide a large help index with lots of synonyms.&#xD;
        Remember: the user may not know the correct term when needing help.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Help-on-object&lt;/b> is context-sensitive help. It displays text that explains a specific part (object) of the&#xD;
        user interface. The user requests context-sensitive help and then selects the part of the user interface where help&#xD;
        is needed. This type of help should be supported for every part of the user interface, if it is to be usable.&#xD;
        Another alternative is to provide implicit help in pop-up windows-a condensed form of context sensitive help that&#xD;
        the system presents adjacent to the cursor when the user lingers for a few seconds. Using implicit help in pop-up&#xD;
        windows has the advantage that it doesn't interfere with the normal operation of the user interface.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Message area&lt;/b> is an area (usually in the main window) where the system prints unsolicited &quot;comments&quot; on the&#xD;
        user's actions. It should be optional if provided.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Wizards&lt;/b> are a popular technique you should consider providing when the user asks for help on how to do&#xD;
        something. A wizard guides the user through a (non-trivial) task using a &quot;hand-holding&quot; technique. It shows&#xD;
        descriptive text in conjunction with operations (buttons) that let the user carry out the parts of task explained&#xD;
        in the text. Alternatively, a wizard will ask questions, and, based on the user's responses, automatically carry&#xD;
        out the task. Wizards are excellent for tasks that are non-trivial and infrequently used.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The need for context-sensitive help and wizards is likely to be identified during use testing. If, during use testing,&#xD;
    users don't understand what different portions of the user interface are, it is an indication to the need for&#xD;
    context-sensitive help. If they have difficulties performing a certain task, it is an indication to the need for&#xD;
    wizards.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The problem with many help systems is that they are either written for novices (spending an enormous amount of text&#xD;
    explaining the obvious) or for experts (reference manuals that anticipate the user knows almost as much as the&#xD;
    programmer who made the application). For most systems, most users are &quot;improving intermediates.&quot; Write the help text&#xD;
    for them.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__undo&quot; name=&quot;XE_user-interface_guidelines__undo&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_undo__user-interface_guidelines&quot; name=&quot;XE_undo__user-interface_guidelines&quot;>&lt;/a>&lt;a id=&quot;Undo&quot; name=&quot;Undo&quot;>&lt;/a>Undo&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Undo is a very useful feature, although it is hard to achieve (implement) in general. It enables users to learn faster,&#xD;
    since they will not have to be afraid of destroying things. It also reduces the risk of losing information. An&#xD;
    alternative solution for avoiding loss of information is to require that the user confirms all operations that might&#xD;
    result in loss of information. This is usually a bad solution, however, since it adds considerable interaction overhead&#xD;
    and the users soon learn to confirm unconsciously, thus rendering this solution inadequate.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An ambitious option is to also provide redo and possibly multiple levels of undo and redo. However, the first undo&#xD;
    level achieves most of the increased usability.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__macro_agent&quot; name=&quot;XE_user-interface_guidelines__macro_agent&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_macro_agent__user-interface_guidelines&quot; name=&quot;XE_macro_agent__user-interface_guidelines&quot;>&lt;/a>&lt;a id=&quot;Macro Agent&quot;&#xD;
    name=&quot;Macro Agent&quot;>&lt;/a>Macro Agent&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    If you provide macros, it may be very useful to employ an agent that continuously monitors the user's actions, looking&#xD;
    for repeated interaction sequences. As soon as a repeated interaction sequence is found, the agent creates a macro for&#xD;
    it (after asking the user for permission). Let's say the user has ordered &quot;Underline&quot; for two text paragraphs and both&#xD;
    times the user has also changed the text color to blue immediately after ordering &quot;Underline.&quot; Then the agent should&#xD;
    ask the user if the user wants a macro that does both &quot;Underline&quot; and &quot;Set color to blue&quot; for the selected text&#xD;
    paragraph. If so, the agent should create such a macro and a push-button (or a menu item) that executes the macro.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the user selects an object during recording, this should normally be interpreted as a &quot;delta&quot; specification, that&#xD;
    is, what object has been selected in relation to previous selection (like &quot;select next&quot;, &quot;select first child,&quot; and so&#xD;
    on).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Whether you should interpret the changing of an object's attributes as a delta specification (for example, interpreting&#xD;
    the change of an attribute value from 12 to 14 as an increase by 2 rather than as a setting to 14) is not as obvious.&#xD;
    Interpreting it as a delta specification is usually more powerful, since changing an attribute to a fixed value for&#xD;
    multiple objects can often be accomplished by selecting multiple objects and then opening an attribute window for them,&#xD;
    in which you set the attribute (to 14) once and for all.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_user-interface_guidelines__dynamic_highlighting&quot;&#xD;
    name=&quot;XE_user-interface_guidelines__dynamic_highlighting&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_dynamic_highlighting__user-interface_guidelines_for&quot;&#xD;
    name=&quot;XE_dynamic_highlighting__user-interface_guidelines_for&quot;>&lt;/a>&lt;a id=&quot;Dynamic Highlighting&quot;&#xD;
    name=&quot;Dynamic Highlighting&quot;>&lt;/a>Dynamic Highlighting&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Quite often, associations between classes are bi-directional, meaning that in the real user interface, the association&#xD;
    is shown on both objects. If a user, focusing on object &lt;b>A&lt;/b>, can see that &lt;b>A&lt;/b> is associated to object&#xD;
    &lt;b>B&lt;/b>, then the reverse is normally also interesting for the user (that is, when focusing on object &lt;b>B&lt;/b>, the&#xD;
    user can see that &lt;b>B&lt;/b> is associated to &lt;b>A&lt;/b>). The association is normally shown in the property windows of the&#xD;
    objects, identifying the associated object by name.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In general, visualizing associations between objects in a primary window is tricky. Visualizing the associations as&#xD;
    arrows or lines often leads to a rather unappealing and obtrusive &quot;snake pit.&quot; A nice way of visualizing associations&#xD;
    is to highlight all associated objects when the cursor is above an associating object. An example of this is when&#xD;
    footnotes are associated with characters in a document editor, and the footnotes are highlighted when the cursor is&#xD;
    above the associated character.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
