<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1zGiRNnmEdmO6L4XMImrsA" name="analysis_class,2.2738948033145062E-306" guid="_1zGiRNnmEdmO6L4XMImrsA" changeDate="2005-11-15T20:18:44.769-0800" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Analysis Class Stereotypes&quot; name=&quot;Analysis Class Stereotypes&quot;>Analysis Class Stereotypes&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Analysis classes may be stereotyped as one of the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Boundary classes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Control classes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Entity classes&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Apart from giving you more specific process guidance when finding classes, this stereotyping results in a robust object&#xD;
    model because changes to the model tend to affect only a specific area. Changes in the user interface, for example,&#xD;
    will affect only boundary classes. Changes in the control flow will affect only control classes. Changes in long-term&#xD;
    information will affect only entity classes. However, these stereotypes are specially useful in helping you to identify&#xD;
    classes in analysis and early design. You should probably consider using a slightly different set of stereotypes in&#xD;
    later phases of design to better correlate to the implementation environment, the application type, and so on.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Boundary Class Def&quot; name=&quot;Boundary Class Def&quot;>Boundary Class&lt;/a> &lt;font size=&quot;2&quot;>&lt;img height=&quot;31&quot;&#xD;
    alt=&quot;boundary class icon&quot; src=&quot;resources/bcls.jpg&quot; width=&quot;47&quot; />&lt;/font>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A &lt;b>boundary class&lt;/b> is a class used to model interaction between the system's surroundings and its inner workings.&#xD;
    Such interaction involves transforming and translating events and noting changes in the system presentation (such as&#xD;
    the interface).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Boundary classes model the parts of the system that depend on its surroundings. Entity classes and control classes&#xD;
    model the parts that are independent of the system's surroundings. Thus, changing the GUI or communication protocol&#xD;
    should mean changing only the boundary classes, not the entity and control classes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Boundary classes also make it easier to understand the system because they clarify the system's boundaries. They aid&#xD;
    design by providing a good point of departure for identifying related services. For example, if you identify a printer&#xD;
    interface early in the design, you will soon see that you must also model the formatting of printouts.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Common boundary classes include windows, communication protocols, printer interfaces, sensors, and terminals. You do&#xD;
    not have to model routine interface parts, such as buttons, as separate boundary classes. Generally the entire window&#xD;
    is the finest grained boundary object. Boundary classes are also useful for capturing interfaces to possibly nonobject&#xD;
    oriented API's, such as legacy code.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You should model boundary classes according to what kind of boundary they represent. Communication with another system&#xD;
    and communication with a human actor (through a user interface) have very different objectives. For communication with&#xD;
    a human actor, the most important concern is how the interface will be presented to the user. For communication with&#xD;
    another system, the most important concern is the communication protocol.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A boundary object (an instance of a boundary class) can outlive a use case instance if, for example, it must appear on&#xD;
    a screen between the performance of two use cases. Normally, however, boundary objects live only as long as the use&#xD;
    case instance.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Finding boundary classes&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A boundary class intermediates the interface to something outside the system. Boundary objects insulate the system from&#xD;
    changes in the surroundings (changes in interfaces to other systems, changes in user requirements, etc.), keeping these&#xD;
    changes from affecting the rest of the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A system may have several types of boundary classes:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>User interface classes&lt;/b> - classes which intermediate communication with human users of the system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>System interface classes&lt;/b> - classes which intermediate communication with other system&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Device interface classes&lt;/b> - classes which provide the interface to devices (such as sensors), which detect&#xD;
        external events&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h5>&#xD;
    Find user-interface classes&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Define one boundary class for each use-case actor-pair. This class can be viewed as having responsibility for&#xD;
    coordinating the interaction with the actor. You may also define additional boundary classes to represent&#xD;
    &lt;b>subsidiary&lt;/b> classes to which the primary boundary class delegates some of its responsibilities. This is&#xD;
    particularly true for window-based GUI applications, where you may model one boundary object for each window, or one&#xD;
    for each form. Only model the key abstractions of the system; do not model every button, list and widget in the GUI.&#xD;
    The goal of analysis is to form a good picture of how the system is composed, not to design every last detail. In other&#xD;
    words, identify boundary classes only for phenomena in the system or for things mentioned in the &lt;b>flow of events&lt;/b>&#xD;
    of the analysis use-case realization.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Make sketches, or use screen dumps from a &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_user_interface_prototype_7237E5AA.html&quot;&#xD;
    guid=&quot;{3DF10D00-8C80-4429-92B8-C6A221F0F90C}&quot;>User-Interface Prototype&lt;/a>, that illustrate the behavior and appearance&#xD;
    of the boundary classes.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Find system-interface classes&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A boundary class which communicates with an external system is responsible for managing the dialogue with the external&#xD;
    system; it provides the interface to that system for the system being built.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In an Automated Teller Machine, withdrawal of funds must be verified through the ATM Network, an actor (which in turn&#xD;
    verifies the withdrawal with the bank accounting system). An object called ATM Network Interface can be identified to&#xD;
    provide communication with the ATM Network.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The interface to an existing system may already be well-defined; if it is, the responsibilities should be derived&#xD;
    directly from the interface definition. If a formal interface definition exists, it may be reverse engineered and we&#xD;
    need not formally define it here; simply make note of the fact that the existing interface will be reused during&#xD;
    design.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Find device interface classes&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The system may contain elements that act as if they were external (change value spontaneously without any object in the&#xD;
    system affecting them), such as sensor equipment. Although it is possible to represent this type of external device&#xD;
    using actors, users of the system may find doing so &quot;confusing&quot;, as it tends to put devices and human actors on the&#xD;
    same &quot;level.&quot; Once we move away from gathering requirements, however, we need to consider the source for all external&#xD;
    events and make sure we have a way for the system to detect these events.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the device is represented as an actor in the use-case model, it is easy to justify using a boundary class to&#xD;
    intermediate communication between the device and the system. If the use-case model does not include these&#xD;
    &quot;device-actors&quot;, now is the appropriate time to add them, updating the Supplementary Descriptions of the Use Cases&#xD;
    where appropriate.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For each &quot;device-actor&quot;, create a boundary class to capture the responsibilities of the device or sensor. If there is a&#xD;
    well-defined interface already existing for the device, make note of it for later reference during design.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Control Class Def&quot; name=&quot;Control Class Def&quot;>Control Class&lt;/a> &lt;font size=&quot;2&quot;>&lt;img height=&quot;37&quot;&#xD;
    alt=&quot;control class icon&quot; src=&quot;resources/control.jpg&quot; width=&quot;36&quot; />&lt;/font>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A &lt;b>control class&lt;/b> is a class used to model control behavior specific to one or a few use cases. Control objects&#xD;
    (instances of control classes) often control other objects, so their behavior is of the coordinating type. Control&#xD;
    classes encapsulate use-case specific behavior.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The behavior of a control object is closely related to the realization of a specific use case. In many scenarios, you&#xD;
    might even say that the control objects &quot;run&quot; the analysis use-case realizations. However, some control objects can&#xD;
    participate in more than one analysis use-case realization if the use-case tasks are strongly related. Furthermore,&#xD;
    several control objects of different control classes can participate in one use case. Not all use cases require a&#xD;
    control object. For example, if the flow of events in a use case is related to one entity object, a boundary object may&#xD;
    realize the use case in cooperation with the entity object. You can start by identifying one control class per analysis&#xD;
    use-case realization, and then refine this as more analysis use-case realizations are identified and commonality is&#xD;
    discovered.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Control classes can contribute to understanding the system because they represent the dynamics of the system, handling&#xD;
    the main tasks and control flows.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When the system performs the use case, a control object is created. Control objects usually die when their&#xD;
    corresponding use case has been performed.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that a control class does not handle &lt;b>everything&lt;/b> required in a use case. Instead, it coordinates the tasks&#xD;
    of other objects that implement the functionality. The control class delegates work to the objects that have been&#xD;
    assigned the responsibility for the functionality.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Finding control classes&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Control classes provide coordinating behavior in the system. The system can perform some use cases without control&#xD;
    objects (just using entity and boundary objects)-particularly use cases that involve only the simple manipulation of&#xD;
    stored information.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    More complex use cases generally require one or more control classes to coordinate the behavior of other objects in the&#xD;
    system. Examples of control objects include programs such as transaction managers, resource coordinators, and error&#xD;
    handlers.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Control classes effectively de-couple boundary and entity objects from one another, making the system more tolerant of&#xD;
    changes in the system boundary. They also de-couple the use-case specific behavior from the entity objects, making them&#xD;
    more reusable across use cases and systems.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Control classes provide behavior that:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Is surroundings-independent (does not change when the surroundings change),&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Defines control logic (order between events) and transactions within a use case.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Changes little if the internal structure or behavior of the entity classes changes,&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Uses or sets the contents of several entity classes, and therefore needs to coordinate the behavior of these entity&#xD;
        classes.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Is not performed in the same way every time it is activated (flow of events features several states).&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h5>&#xD;
    Determine whether a control class is needed&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The flow of events of a use case defines the order in which different tasks are performed. Start by investigating if&#xD;
    the flow can be handled by the already identified boundary and entity classes. For simple &lt;b>flows of events&lt;/b> which&#xD;
    primarily enter, retrieve and display, or modify information, a separate control class is not usually justified; the&#xD;
    boundary classes will be responsible for coordinating the use case.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The &lt;b>flows of events&lt;/b> should be encapsulated in a separate control class when it is complex and consists of&#xD;
    dynamic behavior that may change independently from the interfaces (boundary classes) or information stores (entity&#xD;
    classes) of the system. By encapsulating the &lt;b>flows of events&lt;/b>, the same control class can potentially be re-used&#xD;
    for a variety of systems which may have different interfaces and different information stores (or at least the&#xD;
    underlying data structures).&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    &lt;b>Example: managing a queue of tasks&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    You can identify a control class from the use case Perform Task in the Depot-Handling System. This control class&#xD;
    handles a queue of Tasks, ensuring that Tasks are performed in the right order. It performs the next Task in the queue&#xD;
    as soon as suitable transportation equipment is allocated. The system can therefore perform several Tasks at the same&#xD;
    time.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The behavior defined by the corresponding control object is easier to describe if you split it into two control&#xD;
    classes, Task Performer and Queue Handler. A Queue Handler object will handle only the queue order and the allocation&#xD;
    of transportation equipment. One Queue Handler object is needed for the whole queue. As soon as the system performs a&#xD;
    Task, it will create a new Task Performer object, which will perform the Task. We thus need one Task Performer object&#xD;
    for each Task the system performs.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;164&quot;&#xD;
    alt='&quot;too complex&quot; classes should be split into classes with a consistent, related set of responsibilities'&#xD;
    src=&quot;resources/splitclass.gif&quot; width=&quot;403&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Complex classes should be divided along lines of similar responsibilities&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The principal benefit of this split is that we have separated queue handling responsibilities (something generic to&#xD;
    many use cases) from the specific tasks of task management, which are specific to this use case. This makes the classes&#xD;
    easier to understand and easier to adapt as the design matures. It also has benefits in balancing the load of the&#xD;
    system, as many Task Performers can be created as necessary to handle the workload.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Encapsulating the main flow of events and alternate/exceptional flows of events in separate control classes&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    To simplify changes, encapsulate the main flow of events and alternate flows of events in different control classes. If&#xD;
    alternate and exception flows are completely independent, separate them as well. This will make the system easier to&#xD;
    extend and maintain over time.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Divide control classes where two actors share the same control class&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Control classes may also need to be divided when several actors use the same control class. By doing this, we isolate&#xD;
    changes in the requirements of one actor from the rest of the system. In cases where the cost of change is high or the&#xD;
    consequences dire, you should identify all control classes which are related to more than one actor and divide them. In&#xD;
    the ideal case, each control class should interact (via some boundary object) with one actor or none at all.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example: call management&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    Consider the use case &lt;b>Local Call&lt;/b>. Initially, we can identify a control class to manage the call itself.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;295&quot; alt=&quot;Different actors invloved in a use case usually require separate control classes&quot;&#xD;
    src=&quot;resources/ac_ucan2.gif&quot; width=&quot;362&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The control class handling local phone calls in a telephone system can quickly be divided into two control classes,&#xD;
    &lt;b>A-behavior&lt;/b> and &lt;b>B-behavior&lt;/b>, one for each actor involved.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In a local phone call, there are two actors: &lt;b>A-subscriber&lt;/b> who initiates the call, and &lt;b>B-subscriber&lt;/b> who&#xD;
    receives the call. The &lt;b>A-subscriber&lt;/b> lifts the receiver, hears the dial tone, and then dials a number of digits,&#xD;
    which the system stores and analyzes. When the system has received all the digits, it sends a ringing tone to&#xD;
    &lt;b>A-subscriber&lt;/b>, and a ringing signal to &lt;b>B-subscriber&lt;/b>. When &lt;b>B-subscriber&lt;/b> answers, the tone and the&#xD;
    signal stop, and the conversation between the subscribers can begin. The call is finished when both subscribers hang&#xD;
    up.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    Two behaviors must be controlled: What happens at A-subscriber's place and what happens at B-subscriber's place. For&#xD;
    this reason, the original control object was split into two control objects, &lt;b>A-behavior&lt;/b> and &lt;b>B-behavior&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You do not have to divide a control class if:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        You can be reasonably sure that the behavior of the actors related to the objects of the control class will never&#xD;
        change, or change very little.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The behavior of an object of the control class toward one actor is very insignificant compared with its behavior&#xD;
        toward another actor, a single object can hold all the behavior. Combining behavior in this way will have a&#xD;
        negligible effect on changeability.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Entity Class Def&quot; name=&quot;Entity Class Def&quot;>Entity Class&lt;/a> &lt;font size=&quot;2&quot;>&lt;img height=&quot;37&quot;&#xD;
    alt=&quot;entity class icon&quot; src=&quot;resources/entity.jpg&quot; width=&quot;37&quot; />&lt;/font>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An &lt;b>entity class&lt;/b> is a class used to model information and associated behavior that must be stored. Entity objects&#xD;
    (instances of entity classes) are used to hold and update information about some phenomenon, such as an event, a&#xD;
    person, or some real-life object. They are usually persistent, having attributes and relationships needed for a long&#xD;
    period, sometimes for the life of the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An entity object is usually not specific to one analysis use-case realization; sometimes, an entity object is not even&#xD;
    specific to the system itself. The values of its attributes and relationships are often given by an actor. An entity&#xD;
    object may also be needed to help perform internal system tasks. Entity objects can have behavior as complicated as&#xD;
    that of other object stereotypes. However, unlike other objects, this behavior is strongly related to the phenomenon&#xD;
    the entity object represents. Entity objects are independent of the environment (the actors).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Entity objects represent the key concepts of the system being developed. Typical examples of entity classes in a&#xD;
    banking system are &lt;b>Account&lt;/b> and &lt;b>Customer.&lt;/b> In a network-handling system, examples are &lt;b>Node&lt;/b> and&#xD;
    &lt;b>Link&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the phenomenon you wish to model is not used by any other class, you can model it as an attribute of an entity&#xD;
    class, or even as a relationship between entity classes. On the other hand, if the phenomenon is used by any other&#xD;
    class in the design model, you must model it as a class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Entity classes provide another point of view from which to understand the system because they show the logical data&#xD;
    structure, which can help you understand what the system is supposed to offer its users.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Finding entity classes&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Entity classes represent stores of information in the system; they are typically used to represent the key concepts the&#xD;
    system manages. Entity objects are frequently passive and persistent. Their main responsibilities are to store and&#xD;
    manage information in the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A frequent source of inspiration for entity classes are the Glossary (developed during requirements) and a&#xD;
    business-domain model (developed during business modeling, if business modeling has been performed).&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Recommended Restrictions on the Use of Association&quot;&#xD;
    name=&quot;Recommended Restrictions on the Use of Association&quot;>Association Stereotype Usage Restrictions&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    &lt;b>&lt;a id=&quot;Restrictions for Boundary Classes&quot; name=&quot;Restrictions for Boundary Classes&quot;>Restrictions for Boundary&#xD;
    Classes&lt;/a>&lt;/b>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The following are allowable:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Communicate associations between two Boundary classes, for instance, to describe how a specific window is related&#xD;
        to other boundary objects.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Communicate or subscribe associations from a Boundary class to an Entity class, because boundary objects might need&#xD;
        to keep track of certain entity objects between actions in the boundary object, or be informed of state changes in&#xD;
        the entity object.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Communicate associations from a Boundary class to a Control class, so that a boundary object may trigger particular&#xD;
        behavior.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;b>&lt;a id=&quot;Restrictions for Control Classes&quot; name=&quot;Restrictions for Control Classes&quot;>Restrictions for Control&#xD;
    Classes&lt;/a>&lt;/b>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The following are allowable:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Communicate or subscribe associations between Control classes and Entity classes, because control objects might&#xD;
        need to keep track of certain entity objects between actions in the control object, or be informed of state changes&#xD;
        in the entity object.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Communicate associations between Control and Boundary classes, allowing the results of invoked behavior to be&#xD;
        communicated to the environment.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Communicate associations between Control classes, allowing the construction of more complex behavioral patterns.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;b>&lt;a id=&quot;Restrictions Entity Classes&quot; name=&quot;Restrictions Entity Classes&quot;>Restrictions for Entity Classes&lt;/a>&lt;/b>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Entity classes should only be the source of associations (communicate or subscribe) to other entity classes. Entity&#xD;
    class objects tend to be long-lived; control and boundary class objects tend to be short-lived. It is sensible from an&#xD;
    architectural viewpoint to limit the visibility that an entity object has of its surroundings, that way, the system is&#xD;
    more amenable to change.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;b>&lt;a id=&quot;Summary of Restrictions&quot; name=&quot;Summary of Restrictions&quot;>Summary of Restrictions&lt;/a>&lt;/b>&#xD;
&lt;/h4>&#xD;
&lt;div align=&quot;center&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;85%&quot;&#xD;
    summary=&quot;Valid Association Stereotype Combinations&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;col&quot; width=&quot;20%&quot;>&#xD;
                    FromTo&lt;br />&#xD;
                     (navigability)&#xD;
                &lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;26%&quot;>&#xD;
                    &lt;p class=&quot;tableheading&quot;>&#xD;
                        Boundary&#xD;
                    &lt;/p>&#xD;
                &lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;27%&quot;>&#xD;
                    &lt;b>Entity&lt;/b>&#xD;
                &lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;27%&quot;>&#xD;
                    &lt;p class=&quot;tableheading&quot;>&#xD;
                        Control&#xD;
                    &lt;/p>&#xD;
                &lt;/th>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th width=&quot;20%&quot;>&#xD;
                    &lt;p class=&quot;tableheading&quot;>&#xD;
                        Boundary&#xD;
                    &lt;/p>&#xD;
                &lt;/th>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;26%&quot;>&#xD;
                    &lt;p align=&quot;center&quot;>&#xD;
                        communicate&#xD;
                    &lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;27%&quot;>&#xD;
                    communicate &#xD;
                    &lt;p>&#xD;
                        subscribe&#xD;
                    &lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;27%&quot;>&#xD;
                    communicate&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th width=&quot;20%&quot;>&#xD;
                    &lt;p class=&quot;tableheading&quot;>&#xD;
                        Entity&#xD;
                    &lt;/p>&#xD;
                &lt;/th>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;26%&quot;>&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;27%&quot;>&#xD;
                    communicate &#xD;
                    &lt;p>&#xD;
                        subscribe&#xD;
                    &lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;27%&quot;>&#xD;
                    &amp;nbsp;&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th width=&quot;20%&quot;>&#xD;
                    &lt;p class=&quot;tableheading&quot;>&#xD;
                        Control&#xD;
                    &lt;/p>&#xD;
                &lt;/th>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;26%&quot;>&#xD;
                    &lt;p align=&quot;center&quot;>&#xD;
                        communicate&#xD;
                    &lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;27%&quot;>&#xD;
                    communicate &#xD;
                    &lt;p>&#xD;
                        subscribe&#xD;
                    &lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;27%&quot;>&#xD;
                    communicate&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Valid Association Stereotype Combinations&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Enforcing Consistency&quot; name=&quot;Enforcing Consistency&quot;>Enforcing Consistency&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        When a new behavior is identified, check to see if there is an existing class that has similar responsibilities,&#xD;
        reusing classes where possible. Only when sure that there is not an existing object that can perform the behavior&#xD;
        should you create new classes.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        As classes are identified, examine them to ensure they have consistent responsibilities. When classes&#xD;
        responsibilities are disjoint, split the object into two or more classes. Update the interaction diagrams&#xD;
        accordingly.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If the a class is split because disjoint responsibilities are discovered, examine the collaborations in which the&#xD;
        class plays a role to see if the collaboration needs to be updated. Update the collaboration if needed.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A class with only one responsibility is not a problem, per se, but it should raise questions on why it is needed.&#xD;
        Be prepared to challenge and justify the existence of all classes.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
