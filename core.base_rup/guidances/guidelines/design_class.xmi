<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_133thNnmEdmO6L4XMImrsA" name="design_class,2.914882084937444E-305" guid="_133thNnmEdmO6L4XMImrsA" changeDate="2005-06-21T10:22:43.798-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_class__guidelines_for&quot; name=&quot;XE_class__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Explanation&quot; name=&quot;Explanation&quot;>Definition&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    &lt;a id=&quot;XE_class__definition&quot; name=&quot;XE_class__definition&quot;>&lt;/a>A &lt;b>design class&lt;/b> represents an abstraction of one or&#xD;
    several classes in the system's implementation; exactly what it corresponds to depends on the implementation language.&#xD;
    For example, in an object-oriented language such as C++, a class can correspond to a plain class. Or in Ada, a class&#xD;
    can correspond to a tagged type defined in the visible part of a package.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Classes define &lt;b>objects&lt;/b>, which in turn realize (implement) the use cases. A class originates from the&#xD;
    requirements the use-case realizations make on the objects needed in the system, as well as from any previously&#xD;
    developed object model.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Whether or not a class is good depends heavily on the implementation environment. The proper size of the class and its&#xD;
    objects depends on the programming language, for example. What is considered right when using Ada might be wrong when&#xD;
    using Smalltalk. Classes should map to a particular phenomenon in the implementation language, and the classes should&#xD;
    be structured so that the mapping results in good code.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Even though the peculiarities of the implementation language influence the design model, you must keep the class&#xD;
    structure easy to understand and modify. You should design as if you had classes and encapsulation even if the&#xD;
    implementation language does not support this.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;operations&quot; name=&quot;operations&quot;>Operations&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The only way other objects can get access to or affect the attributes or relationships of an object is through its&#xD;
    &lt;b>operations&lt;/b>. The operations of an object are defined by its class. A specific behavior can be performed via the&#xD;
    operations, which may affect the attributes and relationships the object holds and cause other operations to be&#xD;
    performed. An operation corresponds to a member function in C++ or to a function or procedure in Ada. What behavior you&#xD;
    assign to an object depends on what role it has in the use-case realizations.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;parameters&quot; name=&quot;parameters&quot;>Parameters&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In the specification of an operation, the parameters constitute &lt;b>formal parameters&lt;/b>. Each parameter has a name and&#xD;
    type. You can use the implementation language syntax and semantics to specify the operations and their parameters so&#xD;
    that they will already be specified in the implementation language when coding starts.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In the &lt;b>Recycling Machine System&lt;/b>, the objects of a &lt;b>Receipt Basis&lt;/b> class keep track of how many deposit&#xD;
    items of a certain type a customer has handed in. The behavior of a &lt;b>Receipt Basis&lt;/b> object includes incrementing&#xD;
    the number of objects returned. The operation &lt;b>insertItem,&lt;/b> which receives a reference to the item handed in,&#xD;
    fills this purpose.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;44&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_clas3.gif&quot; width=&quot;210&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Use the implementation language syntax and semantics when specifying operations.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_class__operations_on&quot; name=&quot;XE_class__operations_on&quot;>&lt;/a>&lt;b>&lt;a id=&quot;Class Operations&quot;&#xD;
    name=&quot;Class Operations&quot;>Class Operations&lt;/a>&lt;/b>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An operation nearly always denotes object behavior. An operation can also denote behavior of a class, in which case it&#xD;
    is a &lt;b>class operation&lt;/b>. This can be modeled in the UML by type-scoping the operation.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Operation Visibility&quot; name=&quot;Operation Visibility&quot;>Operation Visibility&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    The following visibilities are possible on an operation:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Public&lt;/b>: the operation is visible to model elements other than the class itself.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Protected&lt;/b>: the operation is visible only to the class itself, to its subclasses, or to &lt;b>friends&lt;/b> of the&#xD;
        class (language dependent)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Private&lt;/b>: the operation is only visible to the class itself and to &lt;b>friends&lt;/b> of the class&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Implementation&lt;/b>: the operation is visible only within to the class itself.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    &lt;b>Public&lt;/b> visibility should be used &lt;b>very&lt;/b> &lt;b>sparingly&lt;/b>, only when an operation is needed by another&#xD;
    class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Protected&lt;/b> visibility should be the &lt;b>default&lt;/b>; it protects the operation from use by external classes, which&#xD;
    promotes loose coupling and encapsulation of behavior.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Private&lt;/b> visibility should be used in cases where you want to prevent &lt;b>subclasses&lt;/b> from inheriting the&#xD;
    operation. This provides a way to de-couple subclasses from the super-class and to reduce the need to remove or exclude&#xD;
    unused inherited operations.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Implementation&lt;/b> visibility is the &lt;b>most restrictive&lt;/b>; it is used in cases where only the class itself is&#xD;
    able to use the operation. It is &lt;b>a variant of Private visibility&lt;/b>, which for most cases is suitable.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;States&quot; name=&quot;States&quot;>States&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    An object can react differently to a specific message depending on what state it is in; the state-dependent behavior of&#xD;
    an object is defined by an associated statechart diagram. For each state the object can enter, the statechart diagram&#xD;
    describes what messages it can receive, what operations will be carried out, and what state the object will be in&#xD;
    thereafter. Refer to &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html&quot; guid=&quot;1.4528459404144188E-304&quot;>Guideline:&#xD;
    Statechart Diagram&lt;/a> for more information.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Interaction Between Objects&quot; name=&quot;Interaction Between Objects&quot;>Collaborations&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A collaboration is a dynamic set of object interactions in which a set of objects communicate by sending&#xD;
    &lt;b>messages&lt;/b> to each other. Sending a message is straightforward in Smalltalk; in Ada it is done as a subprogram&#xD;
    call. A message is sent to a receiving object that invokes an operation within the object. The message indicates the&#xD;
    name of the operation to perform, along with the required parameters. When messages are sent, &lt;b>actual parameters&lt;/b>&#xD;
    (values for the formal &lt;b>parameter&lt;/b>s) are supplied for all the &lt;b>parameter&lt;/b>s.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The message transmissions among objects in a use-case realization and the focus of control the objects follow as the&#xD;
    operations are invoked are described in interaction diagrams. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/sequence_diagram_AFA76EBB.html&quot; guid=&quot;3.211008403369512E-306&quot;>Guideline:&#xD;
    Sequence Diagram&lt;/a> and &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/communication_diagram_FFFEA1B5.html&quot;&#xD;
    guid=&quot;4.5194432001390347E-305&quot;>Guideline: Communication Diagram&lt;/a> for information about these diagrams.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;XE_class_attribute__definition&quot; name=&quot;XE_class_attribute__definition&quot;>&lt;/a>&lt;a id=&quot;Attributes&quot;&#xD;
    name=&quot;Attributes&quot;>&lt;/a>&lt;a id=&quot;XE_attribute__definition_for&quot; name=&quot;XE_attribute__definition_for&quot;>Attributes&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    An attribute is a named property of an object. The attribute name is a noun that describes the attribute's role in&#xD;
    relation to the object. An attribute can have an initial value when the object is created.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You should model attributes only if doing so makes an object more understandable. You should model the property of an&#xD;
    object as an attribute only if it is a property of &lt;b>that object alone&lt;/b>. Otherwise, you should model the property&#xD;
    with an association or aggregation relationship to a class whose objects represent the property.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;63&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_clas4.gif&quot; width=&quot;162&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    An example of how an attribute is modeled. Each member of a family has a name and an address. Here, we have identified&#xD;
    the attributes &lt;b>my name&lt;/b> and &lt;b>home address&lt;/b> of type &lt;b>Name&lt;/b> and &lt;b>Address&lt;/b>, respectively:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;45&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_clas5.gif&quot; width=&quot;308&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In this example, an association is used instead of an attribute. The &lt;b>my name&lt;/b> property is probably unique to each&#xD;
    member of a family. Therefore we can model it as an attribute of the attribute type &lt;b>Name&lt;/b>. An address, though, is&#xD;
    shared by all family members, so it is best modeled by an association between the &lt;b>Family Member&lt;/b> class and the&#xD;
    &lt;b>Address&lt;/b> class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It is not always easy to decide immediately whether to model some concept as a separate object or as an attribute of&#xD;
    another object. Having unnecessary objects in the object model leads to unnecessary documentation and development&#xD;
    overhead. You must therefore establish certain criteria to determine how important a concept is to the system.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Accessibility&lt;/b>. What governs your choice of object versus attribute is not the importance of the concept in&#xD;
        real life, but the need to access it during the use case. If the unit is accessed frequently, model it as an&#xD;
        object.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Separateness during execution&lt;/b>. Model concepts handled separately during the execution of use cases as&#xD;
        objects.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Ties to other concepts&lt;/b>. Model concepts strictly tied to certain other concepts and never used separately,&#xD;
        but always via an object, as an attribute of the object.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Demands from relationships&lt;/b>. If, for some reason, you must relate a unit from two directions, re-examine the&#xD;
        unit to see if it should be a separate object. Two objects cannot associate the same instance of an attribute type.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Frequency of occurrence.&lt;/b> If a unit exists only during a use case, do not model it as an object. Instead&#xD;
        model it as an attribute to the object that performs the behavior in question, or simply mention it in the&#xD;
        description of the affected object.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Complexity.&lt;/b> If an object becomes too complicated because of its attributes, you may be able to extract some&#xD;
        of the attributes into separate objects. Do this in moderation, however, so that you do not have too many objects.&#xD;
        On the other hand, the units may be very straightforward. For example, classified as attributes are (1) units that&#xD;
        are simple enough to be supported directly by primitive types in the implementation language, such as, integers in&#xD;
        C++, and (2) units that are simple enough to be implemented by using the application-independent components of the&#xD;
        implementation environment, such as, &lt;b>String&lt;/b> in C++ and Smalltalk-80.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    You will probably model a concept differently for different systems. In one system, the concept may be so vital that&#xD;
    you will model it as an object. In another, it may be of minor importance, and you will model it as an attribute of an&#xD;
    object.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    For example, for an airline company you would develop a system that supports departures.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;75&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_clas6.gif&quot; width=&quot;146&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    A system that supports departures. Suppose the personnel at an airport want a system that supports departures. For each&#xD;
    departure, you must define the time of departure, the airline, and the destination. You can model this as an object of&#xD;
    a class &lt;b>Departure&lt;/b>, with the attributes &lt;b>time of departure&lt;/b>, &lt;b>airline&lt;/b>, and &lt;b>destination&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    If, instead, the system is developed for a travel agency, the situation might be somewhat different.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;65&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_clas7.gif&quot; width=&quot;391&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Flight destinations forms its own object, &lt;b>Destination.&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The time of departure, airline, and destination will, of course, still be needed. Yet there are other requirements,&#xD;
    because a travel agency is interested in finding a departure with a specific destination. You must therefore create a&#xD;
    separate object for &lt;b>Destination&lt;/b>. The objects of &lt;b>Departure&lt;/b> and &lt;b>Destination&lt;/b> must, of course, be&#xD;
    aware of each other, which is enabled by an association between their classes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The argument for the importance of certain concepts is also valid for determining what attributes should be defined in&#xD;
    a class. The class &lt;b>Car&lt;/b> will no doubt define different attributes if its objects are part of a motor-vehicle&#xD;
    registration system than if its objects are part of an automobile manufacturing system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Finally, the rules for what to represent as objects and what to represent as attributes are not absolute.&#xD;
    Theoretically, you can model everything as objects, but this is cumbersome. A simple rule of thumb is to view an object&#xD;
    as something that at some stage is used irrespective of other objects. In addition, you do not have to model every&#xD;
    object property using an attribute, only properties necessary to understand the object. You should not model details&#xD;
    that are so implementation-specific that they are better handled by the implementer.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_attribute__class,_definition_for&quot; name=&quot;XE_attribute__class,_definition_for&quot;>&lt;/a>&lt;a id=&quot;Class_Attributes&quot;&#xD;
    name=&quot;Class_Attributes&quot;>&lt;/a>Class Attributes&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An attribute nearly always denotes object properties. An attribute can also denote properties of a class, in which case&#xD;
    it is a &lt;b>class attribute&lt;/b>. This can be modeled in the UML by type-scoping the attribute.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;XE_external_units__modeling_with_attributes&quot; name=&quot;XE_external_units__modeling_with_attributes&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Modeling_External&quot; name=&quot;Modeling_External&quot;>&lt;/a>&lt;a id=&quot;XE_attribute__modeling_external_units_with&quot;&#xD;
    name=&quot;XE_attribute__modeling_external_units_with&quot;>Modeling External Units with Attributes&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An object can encapsulate something whose value can change without the object performing any behavior. It might be&#xD;
    something that is really an external unit, but that was not modeled as an actor. For example, system boundaries may&#xD;
    have been chosen so that some form of sensor equipment lies within them. The sensor can then be encapsulated within an&#xD;
    object, so that the value it measures constitutes an attribute. This value can then change continually, or at certain&#xD;
    intervals without the object being influenced by any other object in the system.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    You can model a thermometer as an object; the object has an attribute that represents temperature, and changes value in&#xD;
    response to changes in the temperature of the environment. Other objects may ask for the current temperature by&#xD;
    performing an operation on the thermometer object.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;45&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_clas8.gif&quot; width=&quot;153&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The value of the attribute &lt;b>temperature&lt;/b> changes spontaneously in the &lt;b>Thermometer&lt;/b> object.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You can still model an encapsulated value that changes in this way as an ordinary attribute, but you should describe in&#xD;
    the object's class that it changes &lt;b>spontaneously&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Attribute Visibility&quot; name=&quot;Attribute Visibility&quot;>Attribute Visibility&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Attribute visibility assumes one of the following values:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Public&lt;/b>: the attribute is visible both inside and outside the package containing the class.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Protected&lt;/b>: the attribute is visible only to the class itself, to its subclasses, or to &lt;b>friends&lt;/b> of the&#xD;
        class (language dependent)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Private&lt;/b>: the attribute is only visible to the class itself and to &lt;b>friends&lt;/b> of the class&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Implementation&lt;/b>: the attribute is visible to the class itself.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    &lt;b>Public&lt;/b> visibility should be used &lt;b>very&lt;/b> &lt;b>sparingly&lt;/b>, only when an attribute is directly accessible by&#xD;
    another class. Defining public visibility is effectively a short-hand notation for defining the attribute visibility as&#xD;
    protected, private or implementation, with associated public operations to get and set the attribute value. Public&#xD;
    attribute visibility can be used as a declaration to a code generator that these get/set operations should be&#xD;
    automatically generated, saving time during class definition.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Protected&lt;/b> visibility should be the &lt;b>default&lt;/b>; it protects the attribute from use by external classes, which&#xD;
    promotes loose coupling and encapsulation of behavior.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Private&lt;/b> visibility should be used in cases where you want to prevent &lt;b>subclasses&lt;/b> from inheriting the&#xD;
    attribute. This provides a way to de-couple subclasses from the super-class and to reduce the need to remove or exclude&#xD;
    unused inherited attributes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Implementation&lt;/b> visibility is the &lt;b>most restrictive&lt;/b>; it is used in cases where only the class itself is&#xD;
    able to use the attribute. It is &lt;b>a variant of Private visibility&lt;/b>, which for most cases is suitable.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Internal Structure&quot; name=&quot;Internal Structure&quot;>Internal Structure&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Some classes may represent complex abstractions and have a complex structure. While modeling a class, the designer may&#xD;
    want to represent its internal participating elements and their relationships, to make sure that the implementer will&#xD;
    accordingly implement the collaborations happening inside that class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In UML 2.0, classes are defined as &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/termdefinitions/structured_class_4BB99B12.html&quot;&#xD;
    guid=&quot;_yW3E4NnmEdmO6L4XMImrsA&quot;>structured classes&lt;/a>, with the capability to have a internal structure and ports.&#xD;
    Then, classes may be decomposed into collections of connected parts that may be further decomposed in turn. A class may&#xD;
    be encapsulated by forcing communications from outside to pass through ports obeying declared interfaces.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Thus, in addition to using class diagrams to represent class relationships (e.g. associations, compositions and&#xD;
    aggregations) and attributes, the designer may want to use a composite structure diagram. This diagram provides the&#xD;
    designer a mechanism to show how instances of internal parts play their roles within an instance of a given class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For more information on this topic and examples on composite structure diagram, see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html&quot; guid=&quot;1.1994826813129747E-304&quot;>Concept:&#xD;
    Structured Class&lt;/a>.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
