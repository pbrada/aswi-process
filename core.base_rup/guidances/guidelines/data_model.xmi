<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1vra0dnmEdmO6L4XMImrsA" name="data_model,3.4196799396281445E-306" guid="_1vra0dnmEdmO6L4XMImrsA" changeDate="2006-02-08T06:23:24.055-0800" version="7.1.0">
  <copyrightStatement href="uma://{1F4FEA6F-AF12-40BF-94BE-D316CE25314B}#_egIacP1mEdm9-ZPZADkvIg"/>
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Overview&quot; name=&quot;Overview&quot;>&lt;/a>&lt;a id=&quot;XE_persistence__relational_databases_and_object_orientation&quot;&#xD;
    name=&quot;XE_persistence__relational_databases_and_object_orientation&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;Relational Databases and Object Orientation&quot; name=&quot;Relational Databases and Object Orientation&quot;>Overview&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/workproducts/rup_data_model_65B46980.html&quot;&#xD;
    guid=&quot;{9DCF1723-1A21-4F48-BEDE-DBC543489682}&quot;>Data Models&lt;/a> are used to design the structure of the persistent data&#xD;
    stores used by the system.&amp;nbsp;&amp;nbsp;The Unified Modeling Language (UML) profile for database design provides database&#xD;
    designers with a set of modeling elements that can be used to develop the detailed design of tables in the database and&#xD;
    model the physical storage layout of the database.&amp;nbsp; The UML database profile also provides constructs for modeling&#xD;
    referential integrity (constraints and triggers), as well as stored procedures used to manage access to the database.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Data Models might be constructed at the enterprise, departmental, or individual application level. Enterprise and&#xD;
    departmental level Data Models can be used to provide standard definitions for key business entities (such as customer&#xD;
    and employee) that will be used by all applications within a business or a business unit.&amp;nbsp;These types of Data&#xD;
    Models can also be used to define which system in the enterprise is the &quot;owner&quot; of the data for a specific business&#xD;
    entity and what other systems are users of (subscribers to) the data.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This guideline describes the model elements of the UML profile for database modeling used to construct a Data Model for&#xD;
    a relational database.&amp;nbsp;Because there are numerous existing publications on general database theory, it does not&#xD;
    cover this area.&amp;nbsp; For background information on relational Data Models and Object Models see &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/relational_databases_and_object_orientation_1C67069E.html&quot;&#xD;
    guid=&quot;3.2166604011257303E-305&quot;>Concept: Relational Databases and Object Orientation.&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note: The data modeling representations contained in this guideline are based on the UML 1.3. At the time that this&#xD;
    guideline was developed, the UML 1.4 data-modeling profile was not available.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Stages of Data Modeling&quot; name=&quot;Stages of Data Modeling&quot;>&lt;/a>&lt;a id=&quot;Persistence Frameworks&quot;&#xD;
    name=&quot;Persistence Frameworks&quot;>Stages of Data Modeling&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    As described in [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#NBG01&quot; guid=&quot;7.755968586980351E-308&quot;>NBG01&lt;/a>], there&#xD;
    are three general stages in the development of a Data Model: conceptual, logical, and physical.&amp;nbsp; These stages of&#xD;
    data modeling reflect the different levels of detail in the design of the persistent data storage and retrieval&#xD;
    mechanisms of the application. A discussion of conceptual data modeling is provided in &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/guidances/concepts/conceptual_data_modeling_5CF78A88.html&quot;&#xD;
    guid=&quot;7.217811033438091E-305&quot;>Concepts&lt;/a>&lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/conceptual_data_modeling_5CF78A88.html&quot;&#xD;
    guid=&quot;7.217811033438091E-305&quot;>Conceptual Data Modeling&lt;/a>.&amp;nbsp; Summaries of logical and physical data modeling are&#xD;
    provided in the next two sections of this guideline.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Logical data modeling&quot; name=&quot;Logical data modeling&quot;>Logical&lt;/a> Data Modeling&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In logical data modeling, the &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/roles/rup_database_designer_524DC34F.html&quot;&#xD;
    guid=&quot;{87EE3BF5-17CA-4211-BD3D-32F361E58550}&quot;>Database Designer&lt;/a> is concerned with identifying the key entities and&#xD;
    relationships that capture the critical information that the application needs to persist in the database.&amp;nbsp; During&#xD;
    the &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/tasks/use_case_analysis_A6990185.html&quot;&#xD;
    guid=&quot;{28014615-A62F-452D-B821-30C7CAB0EC44}&quot;>Use-Case Analysis&lt;/a>, &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/tasks/use_case_design_92D13EEE.html&quot; guid=&quot;{76E2B93D-051C-4B8C-BEA1-B40A40CBD986}&quot;>Use-Case&#xD;
    Design&lt;/a>, and &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/tasks/class_design_98F20FF9.html&quot;&#xD;
    guid=&quot;{27AE0601-2E95-4A6A-8EB3-0A4BA8E5626B}&quot;>Class Design&lt;/a> tasks, the &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../../core.base_rup/roles/rup_database_designer_524DC34F.html&quot; guid=&quot;{87EE3BF5-17CA-4211-BD3D-32F361E58550}&quot;>Database&#xD;
    Designer&lt;/a> and the &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/roles/rup_designer_BA8DE74E.html&quot;&#xD;
    guid=&quot;{DB21F5EF-810B-4994-B120-79FA8774FA9D}&quot;>Designer&lt;/a> must work together to ensure that the evolving designs of&#xD;
    the analysis and design classes for the application will adequately support the development of the database.&amp;nbsp;&#xD;
    During the &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/tasks/class_design_98F20FF9.html&quot;&#xD;
    guid=&quot;{27AE0601-2E95-4A6A-8EB3-0A4BA8E5626B}&quot;>Class Design&lt;/a> task, the database designer and the designer must&#xD;
    identify the set of classes in the Design Model that will need to persist data in the database.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This set of persistent classes in the Design Model provides a Design Model View that, although different from the&#xD;
    traditional Logical Data Model, meets many of the same needs.&amp;nbsp;The persistent classes used in the Design Model&#xD;
    function in the same manner as the traditional entities in the Logical Data Model. These design classes accurately&#xD;
    reflect the data that must be persisted, including all of the data columns (attributes) that must be persisted and key&#xD;
    relationships. This makes these design classes an excellent starting point for the physical database design.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Creating a separate Logical Data Model is an option. However, in the best case it would end up capturing the same&#xD;
    information in a different form. In the worst case it would not, and thus in the end might not meet the business needs&#xD;
    of the application. In particular, if the database is intended to service a single application, then the application's&#xD;
    view of the data might be the best starting point. The database designer creates tables from this set of persistent&#xD;
    design classes to form an initial Physical Data Model.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Still, situations might exist that would require the database designer to create an idealized design of the database&#xD;
    that is independent from the application design.&amp;nbsp;In this case, the logical database design is represented in a&#xD;
    separate Logical Data Model that is part of the overall &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_data_model_65B46980.html&quot; guid=&quot;{9DCF1723-1A21-4F48-BEDE-DBC543489682}&quot;>Artifact:&#xD;
    Data Model&lt;/a>.&amp;nbsp;This Logical Data Model depicts the key logical entities and their relationships that are&#xD;
    necessary to satisfy the system requirements for persisting data consistent with the overall architecture of the&#xD;
    application.&amp;nbsp;The Logical Data Model might be constructed using the modeling elements of the UML profile for&#xD;
    database design described in later sections of this guideline.&amp;nbsp;For projects that use this approach, close&#xD;
    collaboration between the application designers and the database designers is absolutely critical to the successful&#xD;
    development of the database design.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Logical Data Model might be refined by applying the standard rules for normalization as defined in &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/concepts/normalization_47199FE9.html&quot;&#xD;
    guid=&quot;3.183357382287462E-306&quot;>Concept: Normalization&lt;/a> prior to evolving the elements of the Logical Data Model to&#xD;
    create the physical design of the database.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The figure below depicts the primary approach of using the Design Model classes as the source of logical database&#xD;
    design information for creating an initial Physical Data Model. It also illustrates the alternative approach of using a&#xD;
    separate Logical Data Model.&amp;nbsp;&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;500&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd25.gif&quot; width=&quot;706&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Logical Data Modeling Approaches&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Physical Data Modeling&quot; name=&quot;Physical Data Modeling&quot;>Physical&lt;/a> Data Modeling&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Physical data modeling is the final stage of development in the design of the database.&amp;nbsp; The Physical Data Model&#xD;
    consists of the detailed database table designs and their relationships created initially from the persistent design&#xD;
    classes and their relationships.&amp;nbsp; The mechanics of performing the transformation of the Design Model classes to&#xD;
    tables is discussed in &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/forward-engineering_relational_databases_53C0441E.html&quot;&#xD;
    guid=&quot;5.250868507423771E-305&quot;>Guideline: Forward-Engineering Relational Databases&lt;/a>.&amp;nbsp;The Physical Data Model is&#xD;
    part of the &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.base_rup/workproducts/rup_data_model_65B46980.html&quot;&#xD;
    guid=&quot;{9DCF1723-1A21-4F48-BEDE-DBC543489682}&quot;>Data Model&lt;/a>; it is not a separate artifact.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The tables in the Physical Data Model have well-defined columns, as well as keys and indexes as needed. The tables&#xD;
    might also have triggers defined as necessary to support the database functionality and referential integrity of the&#xD;
    system. In addition to the tables, stored procedures have been created, documented, and associated with the database in&#xD;
    which the stored procedure will reside.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The diagram below shows an example of some of the elements of the Physical Data Model.&amp;nbsp; This example model is a&#xD;
    part of the Physical Data Model of a fictional online auction application. It depicts four tables (Auction, Bid, Item,&#xD;
    and AuctionCategory), along with one stored procedure (sp_Auction) and its container class (AuctionManagement).&amp;nbsp;&#xD;
    The figure also depicts the columns of each table, the primary key and foreign key constraints, and the indexes defined&#xD;
    for the tables.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;656&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd18.gif&quot; width=&quot;748&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Example (Physical) Data Model Elements&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Physical Data Model also contains mappings of the tables to physical storage units (tablespaces) in the&#xD;
    database.&amp;nbsp;The figure below shows an example of this mapping.&amp;nbsp; In this example, the tables Auction and&#xD;
    OrderStatus are mapped to a tablespace called PRIMARY. The diagram also illustrates modeling the realization of the&#xD;
    tables to the database (named PearlCircle in this example).&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;668&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd19.gif&quot; width=&quot;695&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Example Data Storage Model Elements&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    On projects in which a database already exists, the database designer can reverse-engineer the existing database to&#xD;
    populate the Physical Data Model.&amp;nbsp; See&amp;nbsp; &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/reverse-engineering_relational_databases_902803B8.html&quot;&#xD;
    guid=&quot;1.338740134620651E-305&quot;>Guideline: Reverse-engineering Relational Databases&lt;/a> for more information.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Data Model Elements&quot; name=&quot;Data Model Elements&quot;>Data Model Elements&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This section describes the general modeling guidelines for each major element of the Data Model based on the UML&#xD;
    profile for database modeling. A brief description of each model element is followed by an example illustration of the&#xD;
    UML model element. The &lt;a href=&quot;#Relationship&quot;>Relationships&lt;/a> section of this guideline includes a description of&#xD;
    the usage of the model elements.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Package&quot; name=&quot;Package&quot;>Package&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Standard UML packages are used to group and organize elements of the Data Model.&amp;nbsp; For example, packages might be&#xD;
    defined to organize the Data Model into separate Logical and Physical Data Models.&amp;nbsp; Packages might also be used to&#xD;
    identify logically related groups of tables in the Data Model that constitute the major data &quot;subject areas&quot; of&#xD;
    importance to the business domain of the application being developed.&amp;nbsp; The figure below shows an example of two&#xD;
    subject area packages (Auction Management and UserAccount Management) used to organize views and tables in the Data&#xD;
    Model.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;254&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd02.gif&quot; width=&quot;250&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Subject Area Packages Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Table&quot; name=&quot;Table&quot;>Table&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In the UML profile for database modeling, a table is modeled as a class with a stereotype of&#xD;
    &amp;lt;&amp;lt;Table&amp;gt;&amp;gt;.&amp;nbsp; The columns in the table are modeled as attributes with the stereotype of&#xD;
    &amp;lt;&amp;lt;column&amp;gt;&amp;gt;. One or more columns might be designated as a primary key to provide for unique row entries in&#xD;
    the table. Columns might also be designated as foreign keys.&amp;nbsp; Primary keys and foreign keys have associated&#xD;
    constraints that are modeled as the stereotyped operations of &amp;lt;&amp;lt;Primary Key&amp;gt;&amp;gt; and &amp;lt;&amp;lt;Foreign&#xD;
    Key&amp;gt;&amp;gt; respectively.&amp;nbsp; The figure below depicts the structure of an example table used to manage information&#xD;
    about items sold at auction in a fictional&amp;nbsp; online auction system.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;214&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd03.gif&quot; width=&quot;294&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Table Example&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Tables might be related to other tables through the following types of relationships:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        identifying (composite aggregation)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        non-identifying (association)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The &lt;a href=&quot;#Relationship&quot;>Relationships&lt;/a> section of this guideline provides examples of how these relationships&#xD;
    are used. Information on how these types of relationships can be mapped to Design Model elements appears in &lt;a&#xD;
    class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/reverse-engineering_relational_databases_902803B8.html&quot;&#xD;
    guid=&quot;1.338740134620651E-305&quot;>Guideline: Reverse-engineering Relational Databases&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Trigger&quot; name=&quot;Trigger&quot;>Trigger&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A trigger is a procedural function designed to run as a result of some action on the table in which the trigger&#xD;
    resides. A trigger is defined to execute when a row in the table is inserted, updated, or deleted. Additionally, a&#xD;
    trigger is designated to execute either before or after the table command executes. Triggers are defined as operations&#xD;
    in a table. The operations are stereotyped &amp;lt;&amp;lt;Trigger&amp;gt;&amp;gt;.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;218&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd13.gif&quot; width=&quot;316&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Trigger Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Index&quot; name=&quot;Index&quot;>Index&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Indexes are used as mechanisms for enabling faster access of information when specific columns are used to search the&#xD;
    table.&amp;nbsp; An index is modeled as an operation in the table with a stereotype of &amp;lt;&amp;lt;index&amp;gt;&amp;gt;.&amp;nbsp; Indexes&#xD;
    might be designated as unique and might be designated as clustered or unclustered. Clustered indexes are used to force&#xD;
    the order of the data rows in the table to be aligned with the order of the index values. An example of an index&#xD;
    operation (IX_auctioncategory) is shown in the figure below.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;150&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd14.gif&quot; width=&quot;346&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Index Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;View&quot; name=&quot;View&quot;>View&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A view is a virtual table with no independent persistent storage. A view has the characteristics and behaviors of a&#xD;
    table and accesses the data in the columns from the table(s) with which the view has defined relationships.&amp;nbsp;Views&#xD;
    are used for providing more efficient access to information in one or more tables and also can be used to enforce&#xD;
    business rules for restricting access to data in the tables. In the example below, an AuctionView has been defined as a&#xD;
    &quot;view&quot; of information in the Auction table shown in the physical data modeling section of this guideline.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Views are modeled as classes with the stereotype of &amp;lt;&amp;lt;view&amp;gt;&amp;gt;.&amp;nbsp;The attributes of the view class are the&#xD;
    columns from the tables referenced by the view.&amp;nbsp;The datatypes of the columns in the view are inherited from the&#xD;
    tables with a defined dependency with the view.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &amp;nbsp;&lt;img height=&quot;244&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd21.gif&quot; width=&quot;451&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    View Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Domain&quot; name=&quot;Domain&quot;>Domain&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A domain is a mechanism used to create user-defined datatypes that can be applied to columns across multiple&#xD;
    tables.&amp;nbsp;A domain is modeled as a class with the stereotype &amp;lt;&amp;lt;Domain&amp;gt;&amp;gt;.&amp;nbsp; In the example below, a&#xD;
    domain has been defined for a &quot;zip + 4&quot; zipcode.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;98&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd20.gif&quot; width=&quot;225&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Domain Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Stored Procedure Container&quot; name=&quot;Stored Procedure Container&quot;>Stored Procedure Container&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A stored procedure container is a grouping of stored procedures within the Data Model. A stored procedure container is&#xD;
    created as a UML class that is stereotyped &amp;lt;&amp;lt;SP Container&amp;gt;&amp;gt;. Multiple stored procedure containers can be&#xD;
    created in a database design. Each stored procedure container must have at least one stored procedure.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;a id=&quot;Stored Procedure&quot; name=&quot;Stored Procedure&quot;>Stored Procedure&lt;/a>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A stored procedure is an independent procedure that typically resides on the database server. Stored procedures are&#xD;
    documented as operations that are grouped into classes stereotyped as &amp;lt;&amp;lt;SP Container&amp;gt;&amp;gt;. The operations are&#xD;
    stereotyped &amp;lt;&amp;lt;SP&amp;gt;&amp;gt;.&amp;nbsp; The example below shows a single stored procedure operation (SP_Auction) in a&#xD;
    container class named AuctionManagement.&amp;nbsp; When designing stored procedures, the database designer must be&#xD;
    cognizant of any naming conventions used by the specific RDBMS.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;88&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd12.gif&quot; width=&quot;165&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Stored Procedure Container and Stored Procedure Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Tablespace&quot; name=&quot;Tablespace&quot;>Tablespace&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A tablespace represents the amount of storage space to be allocated to such items as tables, stored procedures and&#xD;
    indexes. Tablespaces are linked to a specific database through a dependency relationship. The number of tablespaces and&#xD;
    how the individual tables will be mapped to them depends on the complexity of the Data Model.&amp;nbsp;Tables that will be&#xD;
    accessed frequently might need to be partitioned into multiple tablespaces. Tables that do not contain large amounts of&#xD;
    frequently accessed data might be grouped into a single tablespace.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A tablespace container is defined for each tablespace. The tablespace container is the physical storage device for the&#xD;
    tablespace. Although multiple tablespace containers can exist for a single tablespace, it is recommended that a&#xD;
    tablespace container be assigned to only a single tablespace. Tablespace containers are defined as attributes to the&#xD;
    tablespace; they are not explicitly modeled.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;69&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd15.gif&quot; width=&quot;132&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Tablespace Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Schema&quot; name=&quot;Schema&quot;>Schema&lt;/a> &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;./../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A schema documents the organization or structure of the database. A schema is represented as a package that is&#xD;
    stereotyped &amp;lt;&amp;lt;Schema&amp;gt;&amp;gt;. When a schema is defined as a package, the tables that make up that package should&#xD;
    be contained within the schema. A dependency between the database and the schema is created to document the&#xD;
    relationship between the database and the schema.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;86&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd17.gif&quot; width=&quot;105&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Schema Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Database&quot; name=&quot;Database&quot;>Database&lt;/a> &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;./../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A database is a collection of data that is organized such that the information in it can be accessed and managed.&amp;nbsp;&#xD;
    The management and access of information in the database is performed through the use of a commercial database&#xD;
    management system (DBMS).&amp;nbsp; A database is represented in the Data Model as a component that is stereotyped&#xD;
    &amp;lt;&amp;lt;Database&amp;gt;&amp;gt;.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;69&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd16.gif&quot; width=&quot;125&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Database Example&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Relationship&quot; name=&quot;Relationship&quot;>Relationship&lt;/a>s &lt;a href=&quot;#Top&quot;>&lt;img height=&quot;20&quot; alt=&quot;To top of page&quot;&#xD;
    src=&quot;./../../../core.base_rup/resources/top.gif&quot; width=&quot;26&quot; border=&quot;0&quot; />&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The UML profile for database modeling defines the valid relationships between the major elements of the Data Model. The&#xD;
    following sections provide examples of the different relationship types.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Non-Identifying&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A non-identifying relationship is a relationship between two tables that independently exist within the database. A&#xD;
    non-identifying relationship is documented by using an association between the tables. The association is stereotyped&#xD;
    &amp;lt;&amp;lt;Non-Identifying&amp;gt;&amp;gt;.&amp;nbsp; The example below depicts a non-identifying relationship between the Item table&#xD;
    and the AuctionCategory table.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;398&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd05.gif&quot; width=&quot;735&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Non-Identifying Relationship Example&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Identifying&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    An identifying relationship is a relationship between two tables in which the child table must coexist with the parent&#xD;
    table. An identifying relationship is documented by using a composite aggregation between two tables. The composite&#xD;
    aggregation is stereotyped as &amp;lt;&amp;lt;Identifying&amp;gt;&amp;gt;. The figure below is an example of an identifying&#xD;
    relationship. This example shows that instances of the child table (CreditCard) must have an associated entry in the&#xD;
    parent table (UserAccount).&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;443&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd06.gif&quot; width=&quot;747&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Identifying Relationship Example&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For both the association and composite aggregation, multiplicity should be defined to document the number of rows in&#xD;
    the relationship. In the example above, for each row in the UserAccount table, there can be 0 or more CreditCard rows&#xD;
    in the CreditCard table. For each row in the CreditCard table, there is exactly one row in the UserAccount table.&#xD;
    Multiplicity is also known as cardinality.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Database Views&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    When defining a database view's relationship with a table, a dependency relationship is used, drawn from the view to&#xD;
    the table. The stereotype of the dependency is &amp;lt;&amp;lt;Derive&amp;gt;&amp;gt;. Typically, the view dependency is named, and the&#xD;
    name of the dependency is the same as the name of the table that is defined in the dependency relationship with the&#xD;
    database view.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;513&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd22.gif&quot; width=&quot;763&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    View and Table Dependency Relationship Example&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Tablespace&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A dependency relationship is used to link a tablespace to a specific database. As shown in the figure below, the&#xD;
    relationship is drawn to show that the database has the dependency on the tablespace.&amp;nbsp;Multiple tablespaces can be&#xD;
    related to a single database in the model.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;88&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd08.gif&quot; width=&quot;298&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Tablespace and Database Dependency Relationship Example&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A dependency relationship is used to document the relationships between tablespaces and the tables within a&#xD;
    tablespace.&amp;nbsp; One or many tables can be related to a single tablespace, and a single table can be related to&#xD;
    multiple tablespaces. The example below shows that the table Auction is assigned to a single tablespace named PRIMARY.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;345&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd09.gif&quot; width=&quot;560&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Table and Tablespace Dependency Relationship Example&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    &lt;u>Realizations&lt;/u>&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Realizations are used to establish the relationship between a database and the tables that exist within it.&amp;nbsp;A&#xD;
    table can be realized by multiple databases in the Data Model.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;348&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd10.gif&quot; width=&quot;561&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Table and Database Realization Relationship Example&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Stored Procedures&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    A dependency relationship is used to document the relationship between the stored procedure container and the tables&#xD;
    that the stored procedures within the stored procedure containers act upon. The example below depicts this type of&#xD;
    relationship by showing that the stored procedure SP_Auction will be used to access information in the Auction table.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;344&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_datamd11.gif&quot; width=&quot;633&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Stored Procedure Container and Table Dependency Relationship Example&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Evolution of the Data Model&quot; name=&quot;Evolution of the Data Model&quot;>Evolution of the Data Model&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Inception Phase&quot; name=&quot;Inception Phase&quot;>Inception Phase&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In the &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/inception_D506BCB4.html&quot;&#xD;
    guid=&quot;_vyZOwCVuEdqSZ9OimJ-AzA&quot;>inception phase&lt;/a>, initial data modeling tasks might be performed in conjunction with&#xD;
    the development of any proof-of-concept prototypes as part of the&quot;Perform architectural synthesis activity&quot;&#xD;
    tasks.&amp;nbsp;On projects in which a database already exists, the database designer might reverse-engineer the existing&#xD;
    database to develop an initial Physical Data Model based on the structure of the existing database.&amp;nbsp;See &lt;a&#xD;
    class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/reverse-engineering_relational_databases_902803B8.html&quot;&#xD;
    guid=&quot;1.338740134620651E-305&quot;>Guideline: Reverse-engineering Relational Databases&lt;/a> for more information. Elements of&#xD;
    the Physical Data Model might be transformed into Design Model elements as needed to support any proof-of-concept&#xD;
    prototyping tasks.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Elaboration Phase&quot; name=&quot;Elaboration Phase&quot;>Elaboration Phase&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The goal of the &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/elaboration_6A203A50.html&quot;&#xD;
    guid=&quot;_-kFhcCVuEdqSZ9OimJ-AzA&quot;>elaboration phase&lt;/a> is to eliminate technical risk and to produce a stable (baselined)&#xD;
    architecture for the system. In large-scale systems, poor performance resulting from a badly designed Data Model is a&#xD;
    major architectural concern. As a result, both data modeling and the development of an architectural prototype that&#xD;
    allows the performance of the database to be evaluated are essential to achieving a stable architecture.&amp;nbsp;As the&#xD;
    architecturally significant use cases are detailed and analyzed in each iteration, Data Model elements are defined&#xD;
    based on the development of the persistent class designs from the use cases. As the class designs stabilize, the&#xD;
    database designer might periodically transform the class designs into tables in the Data Model and define the&#xD;
    appropriate data storage model elements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    By the end of the elaboration phase, the major database structures (tables, indexes, and primary and foreign key&#xD;
    columns) must be put in place to support the execution of the defined architecturally significant scenarios for the&#xD;
    application. In addition, representative data volumes must be loaded into the database to support architectural&#xD;
    performance testing. Based on the results of performance testing, the Data Model might need to be adjusted with&#xD;
    optimization techniques, including but not limited to de-normalizing, optimizing physical storage attributes or&#xD;
    distribution, and indexing.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Construction Phase&quot; name=&quot;Construction Phase&quot;>Construction Phase&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Major restructuring of the Data Model must not occur during the &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/construction_102AF1EA.html&quot; guid=&quot;_SkuIwCVwEdqSZ9OimJ-AzA&quot;>construction&#xD;
    phase&lt;/a>. Additional tables and data storage elements might be defined during the construction phase iterations based&#xD;
    on the detailed design of the set of use cases and approved change requests allocated to the iteration. A primary focus&#xD;
    of database design during the construction phase is to continually monitor the performance of the database and optimize&#xD;
    the database design as needed through de-normalizing, defining indexes, creating database views, and other optimization&#xD;
    techniques.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Physical Data Model is the design artifact that the database designer maintains during the construction phase. It&#xD;
    can be maintained by either making direct updates in the model or as a result of a tool reading updates that have been&#xD;
    made directly on the database.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Transition Phase&quot; name=&quot;Transition Phase&quot;>Transition Phase&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The Data Model, like the Design Model, is maintained during the &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/transition_1018F224.html&quot; guid=&quot;_cn2akCVwEdqSZ9OimJ-AzA&quot;>transition phase&lt;/a> in&#xD;
    response to approved change requests. The database designer must keep the Data Model synchronized with the database as&#xD;
    the application goes through final acceptance test and is deployed into production.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Roundtrip Engineering Considerations&quot; name=&quot;Roundtrip Engineering Considerations&quot;>Round-trip Engineering&#xD;
    Considerations&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    If a development team is using modern visual modeling tools that have the ability to convert classes to tables (and&#xD;
    vice versa) and/or has the ability to reverse and forward engineer databases, then the team needs to establish&#xD;
    guidelines for managing the transformation and engineering processes.&amp;nbsp;The guidelines are primarily needed for&#xD;
    large projects in which a team is working in parallel on the database and application design.&amp;nbsp;The development team&#xD;
    must define the points in the development of the application (build/release cycle) at which it will be appropriate to&#xD;
    perform the class-to-table transformations and to forward-engineer the database.&amp;nbsp;Once the initial database is&#xD;
    created, the development team must define guidelines for the team to manage the synchronization of the Data Model and&#xD;
    database as the design and code of the system evolve throughout the project.&#xD;
&lt;/p>&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
