<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1p3GsdnmEdmO6L4XMImrsA" name="statechart_diagram,1.4528459404144188E-304" guid="_1p3GsdnmEdmO6L4XMImrsA" changeDate="2005-06-22T18:52:52.203-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_state_machine__guidelines_for&quot; name=&quot;XE_state_machine__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Explanation&quot; name=&quot;Explanation&quot;>Explanation&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    State machines are used to model the dynamic behavior of a model element, and more specifically, the event-driven&#xD;
    aspects of the system's behavior (see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/events_and_signals_734567DC.html&quot; guid=&quot;1.800598287887014E-305&quot;>Concept: Events&#xD;
    and Signals&lt;/a>). State machines are specifically used to define state-dependent behavior, or behavior that varies&#xD;
    depending on the state in which the model element is in. Model elements whose behavior does not vary with its state of&#xD;
    the element do not require state machines to describe their behavior (these elements are typically passive classes&#xD;
    whose primary responsible is to manage data). In particular, state machines must be used to model the behavior of&#xD;
    active classes that use call events and signal events to implement their operations (as transitions in the class's&#xD;
    state machine).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A state machine consists of states, linked by transitions. A state is a condition of an object in which it performs&#xD;
    some task or waits for an event. A transition is a relationship between two states which is triggered by some event,&#xD;
    which performs certain actions or evaluations, and which results in a specific end-state. The elements of a state&#xD;
    machine are depicted in Figure 1.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;278&quot; alt=&quot;Diagram showing state machine notation.&quot; src=&quot;resources/md_state1.gif&quot; width=&quot;511&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Figure 1. State machine notation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A simple editor can be viewed as a finite state machine with the states &lt;b>Empty,&lt;/b> &lt;b>Waiting for a command,&lt;/b> and&#xD;
    &lt;b>Waiting for text&lt;/b>. The events &lt;b>Load file,&lt;/b> &lt;b>Insert text,&lt;/b> &lt;b>Insert character,&lt;/b> and &lt;b>Save and&#xD;
    quit&lt;/b> cause transitions in the state machine. The state machine for the editor is depicted in Figure 1 below.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;263&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;resources/md_stad2.gif&quot; width=&quot;437&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Figure 2. The state machine for a simple editor.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;States&quot; name=&quot;States&quot;>States&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p align=&quot;left&quot;>&#xD;
    A state is a condition of an object in which it performs some task or waits for an event. An object may remain in a&#xD;
    state for a finite amount of time. A state has several properties:&#xD;
&lt;/p>&#xD;
&lt;div align=&quot;center&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;65%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    Name&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    A textual string which distinguishes the state from other states; a state may also be anonymous,&#xD;
                    meaning that it has no name.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    Entry/exit actions&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    Actions executed on entering and exiting the state.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    Internal transitions&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    Transitions that are handled without causing a change in state.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    Substates&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    The nested structure of a state, involving disjoint (sequentially active) or concurrent (concurrently&#xD;
                    active) substates.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    Deferred events&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    A list of events that are not handled in that state but are postponed and queued for handling by the&#xD;
                    object in another state.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    As depicted in Figure 1, there are two special states that may be defined for an object's state machine. The initial&#xD;
    state indicates the default starting place for the state machine or substate. An initial state is depicted as a filled&#xD;
    black circle. The final state indicates the completion of the execution of the state machine or that the enclosing&#xD;
    state has been completed. A final state is represented as a filled black circle surrounded by an unfilled circle.&#xD;
    Initial and final states are really pseudostates. Neither may have the usual parts of a normal state, except for a&#xD;
    name. A transition from an initial state to a final state may have the full complement of features, including a guard&#xD;
    condition and an action, but may not have a trigger event.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Transitions&quot; name=&quot;Transitions&quot;>Transitions&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Event%20Triggers&quot;>Event Triggers&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Guard%20Conditions&quot;>Guard Conditions&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Actions&quot;>Actions&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Entry%20and%20Exit%20Actions&quot;>Entry and Exit Actions&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Internal%20Transitions&quot;>Internal Transitions&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Deferred%20Events&quot;>Deferred Events&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A transition is a relationship between two states indicating that an object in the first state will perform certain&#xD;
    actions and enter a second state when a specified event occurs and specified conditions are satisfied. On such a change&#xD;
    of state, the transition is said to 'fire'. Until the transition fires, the object is said to be in the 'source' state;&#xD;
    after it fires, it is said to be in the 'target' state. A transition has several properties:&#xD;
&lt;/p>&#xD;
&lt;div align=&quot;center&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;85%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    Source state&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    The state affected by the transition; if an object is in the source state, an outgoing transition may&#xD;
                    fire when the object receives the trigger event of the transition and if the guard condition, if any,&#xD;
                    is satisfied.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    &lt;b>Event trigger&lt;/b>&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    The event that makes the transition eligible to fire (providing its guard condition is satisfied) when&#xD;
                    received by the object in the source state.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    &lt;b>Guard condition&lt;/b>&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    A boolean expression that is evaluated when the transition is triggered by the reception of the event&#xD;
                    trigger; if the expression evaluates True, the transition is eligible to fire; if the expression&#xD;
                    evaluates to False, the transition does not fire. If there is no other transition that could be&#xD;
                    triggered by the same event, the event is lost.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    Action&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    An executable atomic computation that may directly act upon the object that owns the state machine, and&#xD;
                    indirectly on other objects that are visible to the object.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;row&quot; width=&quot;40%&quot;>&#xD;
                    Target state&#xD;
                &lt;/th>&#xD;
                &lt;td width=&quot;60%&quot;>&#xD;
                    The state that is active after the completion of the transition.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    A transition may have multiple sources, in which case it represents a join from multiple concurrent states, as well as&#xD;
    multiple targets, in which case it represents a fork to multiple concurrent states.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Event Triggers&quot; name=&quot;Event Triggers&quot;>Event Triggers&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In the context of the state machine, an event is an occurrence of a stimulus that can trigger a state transition.&#xD;
    Events may include signal events, call events, the passing of time, or a change in state. A signal or call may have&#xD;
    parameters whose values are available to the transition, including expressions for the guard conditions and action. It&#xD;
    is also possible to have a triggerless transition, represented by a transition with no event trigger. These&#xD;
    transitions, also called completion transitions, is triggered implicitly when its source state has completed its task.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Guard Conditions&quot; name=&quot;Guard Conditions&quot;>Guard Conditions&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    A guard condition is evaluated after the trigger event for the transition occurs. It is possible to have multiple&#xD;
    transitions from the same source state and with the same event trigger, as long as the guard conditions don't overlap.&#xD;
    A guard condition is evaluated just once for the transition at the time the event occurs. The boolean expression may&#xD;
    reference the state of the object.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Actions&quot; name=&quot;Actions&quot;>Actions&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An action is an executable atomic computation, meaning that it cannot be interrupted by an event and therefore runs to&#xD;
    completion. This is in contrast to an task, which may be interrupted by other events. Actions may include operation&#xD;
    calls (to the owner of the state machine as well as other visible objects), the creation or destruction of another&#xD;
    object, or the sending of a signal to another object. In the case of sending a signal, the signal name is prefixed with&#xD;
    the keyword 'send'.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Entry and Exit Actions&quot; name=&quot;Entry and Exit Actions&quot;>Entry and Exit Actions&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Entry and exit actions allow the same action to be dispatched every time the state is entered or left, respectively.&#xD;
    Entry and exit actions enable this to be done cleanly, without having to explicitly put the actions on every incoming&#xD;
    or outgoing transition explicitly. Entry and exit actions may not have arguments or guard conditions. The entry actions&#xD;
    at the top-level of a state machine for a model element may have parameters representing the arguments that the machine&#xD;
    receives when the element is created.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Internal Transitions&quot; name=&quot;Internal Transitions&quot;>Internal Transitions&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Internal transitions allow events to be handled within the state without leaving the state, thereby avoiding triggering&#xD;
    entry or exit actions. Internal transitions may have events with parameters and guard conditions, and essentially&#xD;
    represent interrupt-handlers.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Deferred Events&quot; name=&quot;Deferred Events&quot;>Deferred Events&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Deferred events are those whose handling is postponed until a state in which the event is not deferred becomes active.&#xD;
    When this state becomes active, the event occurrence is triggered and may cause transitions as if it had just occurred.&#xD;
    The implementation of deferred events requires the presence of an internal queue of events. If an event occurs but is&#xD;
    listed as deferred, it is queued. Events are taken off this queue as soon as the object enters a state that does not&#xD;
    defer these events.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Substates&quot; name=&quot;Substates&quot;>Substates&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A simple state is one which has no substructure. A state which has substates (nested states) is called a composite&#xD;
    state. Substates may be nested to any level. A nested state machine may have at most one initial state and one final&#xD;
    state. Substates are used to simplify complex flat state machines by showing that some states are only possible within&#xD;
    a particular context (the enclosing state).&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;279&quot; alt=&quot;Diagram showing substates.&quot; src=&quot;resources/md_state2.gif&quot; width=&quot;449&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Figure 3. Substates.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    From a source outside an enclosing composite state, a transition may target the composite state or it may target a&#xD;
    substate. If its target is the composite state, the nested state machine must include an initial state, to which&#xD;
    control passes after entering the composite state and after dispatching its entry action (if any). If its target is the&#xD;
    nested state, control passes to the nested state after dispatching the entry action of the composite state (if any),&#xD;
    and then the entry action of the nested state (if any).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A transition leading out of a composite state may have as its source the composite state or a substate. In either case,&#xD;
    control first leaves the nested state (and its exit action, if any, is dispatched), then it leaves the composite state&#xD;
    (and its exit action, if any, is dispatched). A transition whose source is the composite state essentially interrupts&#xD;
    the task of the nested state machine.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;History States&quot; name=&quot;History States&quot;>History States&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Unless otherwise specified, when a transition enters a composite state, the action of the nested state machine starts&#xD;
    over again at the initial state (unless the transition targets a substate directly). History states allow the state&#xD;
    machine to re-enter the last substate that was active prior to leaving the composite state. An example of history state&#xD;
    usage is presented in Figure 3.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;211&quot; alt=&quot;Diagram showing history states.&quot; src=&quot;resources/md_state3.gif&quot; width=&quot;412&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Figure 4. History State.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Common Modeling Techniques&quot; name=&quot;Common Modeling Techniques&quot;>Common Modeling Techniques&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    State machines are used most commonly to model the behavior of an object across its lifetime. They are particularly&#xD;
    needed when objects have state-dependent behavior. Objects which may have state machines include classes, subsystems,&#xD;
    use cases and interfaces (to assert states which must be satisfied by an object which realizes the interface).In the&#xD;
    case of real-time systems, state machines are also used for capsules and protocols (to assert states which must be&#xD;
    satisfied by an object which realizes the protocol).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Not all objects require state machines. If an object's behavior is simple, such that it simply store or retrieves data,&#xD;
    the behavior of the object is state-invariant and its state machine is of little interest.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Modeling the lifetime of an object involves three things: specifying the events to which the object can respond, the&#xD;
    response to those events, and the impact of the past on current behavior. Modeling the lifetime of an object also&#xD;
    involves deciding the order in which the object can meaningfully respond to events, starting at the time of the&#xD;
    object's creation and continuing until its destruction.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To model the lifetime of an object:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Set the context for the state machine, whether it is a class, a use case, or the system as a whole. &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                If the context is a class or a use case, collect the neighboring classes, including parent classes or&#xD;
                classes reachable by associations or dependencies. These neighbors are candidate targets for actions and&#xD;
                are candidate targets for inclusion in guard conditions.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                If the context is the system as a whole, narrow your focus to one behavior of the system, and then consider&#xD;
                the lifetimes of the objects involved in that aspect. The lifetime of the entire system is simply too big&#xD;
                too be a meaningful focus.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Establish initial and final states for the object. If there are preconditions or postconditions of the initial and&#xD;
        final states, define those as well.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Determine the events to which the object responds. These can be found in the object's interfaces. In the case of&#xD;
        real-time systems, these can also be found in the object's protocols.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Starting from the initial state to the final state, lay-out the top-level states the object may be in. Connect&#xD;
        these states with transitions triggered by the appropriate events. Continue by adding these transitions.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Identify any entry or exit actions.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Expand or simplify the state machine by using substates.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Check that all events triggering transitions in the state machine match events expected by the interfaces realized&#xD;
        by the object. Similarly, check that all events expected by the interfaces of the object are handled by the state&#xD;
        machine. In the case of real-time systems, make equivalent checks for a capsule's protocols. Finally, look to&#xD;
        places where you explicitly want to ignore events (e.g. deferred events).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Check that all actions in the state machine are supported by relationships, methods, and operations of the&#xD;
        enclosing object.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Trace through the state machine, comparing it with expected sequences of events and their responses. Search for&#xD;
        unreachable states and states in which the machine gets stuck.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If you re-arrange or re-structure the state machine, check to make sure that the semantics have not changed.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Hints and Tips&quot; name=&quot;Hints and Tips&quot;>Hints and Tips&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        When given a choice, use the visual semantics of the state machine rather than writing detail transition code. For&#xD;
        example, do not trigger one transition on several signals, then use detail code to manage the flow of control&#xD;
        differently depending on the signal. Use separate transitions, triggered by separate signals. Avoid conditional&#xD;
        logic in transition code that hides additional behavior.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Name states according to what you are waiting for or what is happening during the state. Remember that a state is&#xD;
        not a 'point in time'; it's a period during which the state machine is waiting for something to happen. For&#xD;
        example, 'waitingForEnd' is a better name than 'end'; 'timingSomeTask' is better than 'timeout'. Do not name states&#xD;
        as if they were actions.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Name all states and transitions within a state machine uniquely; this will make source-level debugging easier.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Use state variables (attributes used to control behavior) cautiously; do not use them in lieu of creating new&#xD;
        states. Where states are few, with little or no state-dependent behavior, and where there is little or no behavior&#xD;
        that might be concurrent with or independent of the object containing the state machine, state variables may be&#xD;
        used. If there is complex, state-dependent behavior which is potentially concurrent, or if events which must be&#xD;
        handled may originate outside the object containing the state machine, consider using a collaboration of two or&#xD;
        more active objects (possibly defined as a composition). In real-time systems, complex&amp;nbsp; state-dependent,&#xD;
        concurrent behavior should be modeled using a capsule containing subcapsules.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If there are more than 5 ± 2 states on a single diagram, consider using substates. Common sense applies: ten states&#xD;
        in an absolutely regular pattern might be fine, but two states with forty transitions between them obviously needs&#xD;
        to be re-thought. Make sure the state machine is understandable.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Name transitions for what triggers the event and/or what happens during the transition. Choose names that improve&#xD;
        understandability.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        When you see a choice vertex, you should ask whether you can delegate the responsibility for that choice to another&#xD;
        component, such that it gets presented to the object as a distinct set of signals to be acted upon (e.g., instead&#xD;
        of a choice on msg-&amp;gt;data &amp;gt; x), have the sender or some other intermediate actor make the decision and send a&#xD;
        signal with the decision explicit in the signal name (e.g., use signals named isFull and isEmpty instead of having&#xD;
        a signal named value and checking message data).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Name the question answered at the choice vertex descriptively, e.g. 'isThereStillLife' or 'isItTimeToComplain'.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Within any given object, try to keep choice vertex names unique (for the same reason as keeping transition names&#xD;
        unique).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Are there overly long code fragments on transitions? Should functions be used instead, and are common code&#xD;
        fragments captured as functions? A transition should read like high-level pseudo-code, and should adhere to the&#xD;
        same or even more stringent rules of length as C++ functions. For example, a transition with more than 25 lines of&#xD;
        code is considered excessively long.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Functions should be named by what they do.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Pay particular attention to entry and exit actions: it is particularly easy to make changes and forget to change&#xD;
        the entry and exit actions.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Exit actions can be used to provide safety features, e.g. the exit action from the 'heaterOn' state turns the&#xD;
        heater off, where the actions are used to enforce an assertion.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Generally substates should contain two or more states unless the state machine is abstract and will be refined by&#xD;
        sub-classes of the enclosing element.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Choice points should be used in lieu of conditional logic in actions or transitions. Choice point are easily seen,&#xD;
        whereas conditional logic in code is hidden from view and easy to overlook.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Avoid guard conditions &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                If the event triggers several transitions, there is no control over which guard condition is evaluated&#xD;
                first. As a result, results can be unpredictable.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                More than one guard condition could be 'true', but only one transition can be followed. The path chosen can&#xD;
                be unpredictable.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Guard conditions are non-visual; it is harder to 'see' their presence.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Avoid state machines which resemble flow charts. &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                This may indicate an attempt to model an abstraction that is not really there, such as: &#xD;
                &lt;ul>&#xD;
                    &lt;li>&#xD;
                        using an active class to model behavior that is best suited for a passive or data class&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        modeling a data class by using a data class and an active class that are very tightly coupled (i.e.&#xD;
                        the data class was used for passing type information around but the active class contains most of&#xD;
                        the data that should be associated with the data class).&#xD;
                    &lt;/li>&#xD;
                &lt;/ul>&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                This misuse of state machines can be recognized by the following symptoms: &#xD;
                &lt;ul>&#xD;
                    &lt;li>&#xD;
                        messages sent to 'self', primarily just to re-use code&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        few states, with many choice points&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        in some cases a state machine without cycles. Such state machines are valid in process control&#xD;
                        applications or when trying to control a sequence of events; their presence during analysis usually&#xD;
                        represents the degeneration of the state machine into a flow chart.&#xD;
                    &lt;/li>&#xD;
                &lt;/ul>&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                When the problem is identified: &#xD;
                &lt;ul>&#xD;
                    &lt;li>&#xD;
                        Consider splitting the active class into smaller units with more distinct responsibilities,&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        Move more behavior into a data class that is associated with the problem active class.&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        Move more behavior into active class functions.&#xD;
                    &lt;/li>&#xD;
                    &lt;li>&#xD;
                        Make more meaningful signals instead of relying on data.&#xD;
                    &lt;/li>&#xD;
                &lt;/ul>&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Designing Abstract State Machines&quot; name=&quot;Designing Abstract State Machines&quot;>Designing with Abstract State&#xD;
    Machines&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    An abstract state machine is a state machine that needs to have more detail added before it can be used for practical&#xD;
    purposes. Abstract state machines can be used to define generic, reusable behavior which is further refined in&#xD;
    subsequent model elements.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;201&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;resources/md_cpsl2.gif&quot; width=&quot;167&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Figure 5. An abstract state machine.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Consider the abstract state machine in Figure 5. The simple state machine depicted is representative of the most&#xD;
    abstract level of behavior (the &quot;control&quot; automaton) of many different types of elements in event-driven systems.&#xD;
    Although they all share this high-level form, the different element types may have widely different detailed behaviors&#xD;
    in the Running state depending on their purpose. Therefore, this state machine would most likely be defined in some&#xD;
    abstract class that serves as the root class for the different specialized active classes&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Let us therefore define two such different refinements of this abstract state machine, using inheritance. These two&#xD;
    refinements, R1 and R2, are shown in Figure 6. For clarity, we have drawn the elements inherited from the parent class&#xD;
    using a gray pen.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;204&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;resources/md_cpsl3.gif&quot; width=&quot;391&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Figure 6. Two refinements of the state machine in Figure 5.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The two refinements clearly differ in how they decompose the Running state and also how they extend the original&#xD;
    &quot;start&quot; transition. These choices can only be made, of course, once the refinement is known and, hence, could not have&#xD;
    been done with a single end-to-end transition in the abstract class.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Chain States&quot; name=&quot;Chain States&quot;>Chain States&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The ability to &quot;continue&quot; both incoming transitions and outgoing transitions is fundamental for the type of refinement&#xD;
    described above. It may seem that entry points and final states, combined with continuation transitions are sufficient&#xD;
    to provide these semantics. Unfortunately, this is not sufficient when there are multiple different transitions that&#xD;
    need to be extended.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    What is required for the abstract behavior pattern is a way of chaining two or more transition segments that are all&#xD;
    executed in the scope of a single run-to-completion step. This means that transitions entering a hierarchical state are&#xD;
    split into the incoming part that effectively terminates on the state boundary and an extension that continues within&#xD;
    the state. Similarly, outgoing transitions emanating from a hierarchically nested state are segmented into a part that&#xD;
    terminates on the enclosing state boundary and a part that continues from the state boundary to the target state. This&#xD;
    effect can be achieved in UML with the introduction the &lt;b>chain state&lt;/b> concept. This is modeled by a stereotype&#xD;
    (&amp;lt;&amp;lt;chainState&amp;gt;&amp;gt;) of the UML State concept. This is a state whose only purpose is to &quot;chain&quot; further&#xD;
    automatic (triggerless) transitions onto an input transition. A chain state has no internal structure-no entry action,&#xD;
    no internal task, no exit action. It also has no transitions triggered by events. It may have any number of input&#xD;
    transitions. It may have an outgoing transition with no trigger event; this transition automatically fires when an&#xD;
    input transition activates the state. The purpose of the state is to chain an input transition to a separate output&#xD;
    transition. Between the input transition(s) and the chained output transition, one connects to another state inside the&#xD;
    containing state and the other connects to another state outside the containing state. The purpose of introducing a&#xD;
    chain state is to separate the internal specification of the containing state from its external environment; it is a&#xD;
    matter of encapsulation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In effect, a chain state represents a &quot;pass through&quot; state that serves to chain a transition to a specific continuation&#xD;
    transition. If no continuation transition is defined, then the transition terminates in the chain state, and some&#xD;
    transition on an enclosing state must eventually fire to move things along.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The example state machine segment in Figure 7 illustrates chain states and their notation. Chain states are represented&#xD;
    in a state machine diagram by small white circles located within the appropriate hierarchical state (this notation is&#xD;
    similar to initial and final states, which they resemble). The circles are stereotype icons of the chain state&#xD;
    stereotype and are usually drawn near to the boundary for convenience. (In fact, a notational variation would be to&#xD;
    draw these on the border of the enclosing state.)&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;152&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/md_cpsl4.gif&quot; width=&quot;391&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Figure 7. Chain states and chained transitions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The chained transition in this example consists of the three chained transition segments e1/a11-/a12-/a13. When signal&#xD;
    e1 is received, the transition labeled e1/a11 is taken, its action a11 executed, and then chain state c1 is reached.&#xD;
    After that, the continuation transition between c1 and c2 is taken, and finally, since c2 is also a chain state, the&#xD;
    transition from c2 to S21. If the states along these paths all have exit and entry actions, the actual sequence of&#xD;
    action executions proceeds as follows:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        exit action of S11&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        action a11&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        exit action of S1&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        action a12&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        entry action of S2&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        action a13&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        entry action of S21&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    All of this is executed in the scope of a single run-to-completion step.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This should be compared against the action execution semantics of the direct transition e2/a2, which are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        exit action of S11&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        exit action of S1&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        action a2&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        entry action for state S2&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        entry action for state S21&#xD;
    &lt;/li>&#xD;
&lt;/ul>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
