<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1EAnotnmEdmO6L4XMImrsA" name="use-case_model,1.7617672560167394E-305" guid="_1EAnotnmEdmO6L4XMImrsA" changeDate="2005-11-15T20:01:16.101-0800" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_use-case_model__guidelines_for&quot; name=&quot;XE_use-case_model__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Explanation&quot; name=&quot;Explanation&quot;>Explanation&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A use-case model is a model of the system's intended functions and its surroundings, and serves as a contract between&#xD;
    the customer and the developers. Use cases serve as a unifying thread throughout system development. The same use-case&#xD;
    model is the result of the Requirements discipline, and is used as input to Analysis &amp;amp; Design and Test disciplines.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The diagram below shows a part of a use-case model for the Recycling-Machine System.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;213&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;resources/md_ucmo2.gif&quot; width=&quot;421&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    A use-case diagram, showing an example of a use-case model with actors and use cases.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are many ways to model a system, each of which may serve a different purpose. However, the most important purpose&#xD;
    of a use-case model is to communicate the system's behavior to the customer or user. Consequently, the model must be&#xD;
    easy to understand.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The users and any other system that may interact with the system are the actors. Because they represent system users,&#xD;
    actors help delimit the system and give a clearer picture of what it is supposed to do. Use cases are developed on the&#xD;
    basis of the actors' needs. This ensures that the system will turn out to be what the users expected.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;How the Use-Case Model Evolves&quot; name=&quot;How the Use-Case Model Evolves&quot;>How the Use-Case Model Evolves&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Both the actors and the use cases are found by using the requirements of customers and potential users as vital&#xD;
    information. As they are discovered, the use cases and the actors should be briefly described. Before the use cases are&#xD;
    described in detail, the use-case model should be reviewed by the customer to verify that all the use cases and actors&#xD;
    are found, and that together they can provide what the customer wants.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In an iterative development environment, you will select a subset of use cases to be detailed in each iteration. See&#xD;
    also &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/tasks/prioritize_use_cases_E6E4D9A0.html&quot;&#xD;
    guid=&quot;{6E23D919-D149-43C2-9D37-8AF77B667CA8}&quot;>Task: Prioritize Use Cases&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When the actors and use cases have been found, the flow of events of each use case is described in detail. These&#xD;
    descriptions show how the system interacts with the actors and what the system does in each individual case.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Finally, the completed use-case model (including the descriptions of use cases) is reviewed, and the developers and&#xD;
    customers use it to agree on what the system should do.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Avoiding Functional Decomposition&quot; name=&quot;Avoiding Functional Decomposition&quot;>Avoiding Functional&#xD;
    Decomposition&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    It is not uncommon that the use-case model degenerates into a functional decomposition of the system. To avoid this,&#xD;
    watch for the following symptoms:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &quot;Small&quot; use cases, meaning that the description of the flow of events is only one or a few sentences.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &quot;Many&quot; use cases, meaning that the number of use cases is some multiple of a hundred, rather than a multiple of&#xD;
        ten.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Use-case names that are constructions like &quot;do this operation on this particular data&quot; or &quot;do this function with&#xD;
        this particular data&quot;. For example, &quot;Enter Personal Identification Number in an ATM machine&quot; should not be modeled&#xD;
        as a separate use case for the ATM machine, since no one would use the system to do just this. A use case is a&#xD;
        complete flow of events that results in something of value to an actor.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    To avoid functional decomposition, you should make sure that the use-case model helps answer questions like:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        What is the context of the system?&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Why is the system built?&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        What does the user want to achieve when using the system?&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        What value does the system add to the users?&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Non-Functional Requirements&quot; name=&quot;Non-Functional Requirements&quot;>Non-Functional Requirements&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    It is quite easy to see that use cases are a very good way of capturing functional requirements on a system. But what&#xD;
    about the non-functional requirements? What are they and where are they captured?&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Non-functional requirements are often categorized as usability-, reliability, performance, and&#xD;
    substitutability-requirements (see also &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/requirements_62E28784.html&quot; guid=&quot;4.582668643506599E-305&quot;>Concept:&#xD;
    Requirement&lt;/a>). They are often requirements that specify need of compliance with any legal and regulatory&#xD;
    requirements. They can also be design constraints due to the operating system used, the platform environment,&#xD;
    compatibility issues, or any application standards that apply. In general, you can say that any requirement that does&#xD;
    not allow for more than one design option should be regarded as a design constraint.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Many non-functional requirements apply to an individual use case and are captured within the properties of that use&#xD;
    case. In that case, they are captured within the flow of events of the use case, or as a special requirement of the use&#xD;
    case (see &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/guidelines/use_case_CC89870D.html&quot;&#xD;
    guid=&quot;4.1983217662266927E-305&quot;>Guideline: Use Case&lt;/a>).&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In the Recycling-Machine System, a non-functional requirement specific to the Return Deposit Items use case could be:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The machine has to be able to recognize deposit items with a reliability of more than 95 percent.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Often the non-functional requirements apply to the whole system. Such requirements are captured in the Supplementary&#xD;
    Specifications (see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/workproducts/rup_supplementary_specification_F5ACAA22.html&quot;&#xD;
    guid=&quot;{B16C2941-791C-44E6-B353-354109B5C9DE}&quot;>Artifact: Supplementary Specifications&lt;/a>).&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In the Recycling-Machine System, a non-functional requirement that applies to the whole system could be:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The machine will allow only one user at a time.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;The What vs. How Dilemma&quot; name=&quot;The What vs. How Dilemma&quot;>The What Versus How Dilemma&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    One of the more difficult things is to learn how to determine at what level of detail the use cases should &quot;start and&#xD;
    end&quot;. Where does features start and use cases begin, and where does use cases end and design begin? We often say that&#xD;
    use cases or software requirements should state &quot;what&quot; the system does, but not &quot;how&quot; it does it. Consider the&#xD;
    following graph:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;196&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;resources/ucm2.gif&quot; width=&quot;382&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    One person's destination is another's starting point.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Depending on your background, you will use a different context to decide what you think is &quot;what&quot; and what is &quot;how&quot;.&#xD;
    This needs to be taken into consideration when determining whether or not a certain detail should be left out of the&#xD;
    use-case model.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Concrete and Abstract Use Cases&quot; name=&quot;Concrete and Abstract Use Cases&quot;>&lt;/a>&lt;a&#xD;
    id=&quot;XE_abstract_use_case__description_of&quot; name=&quot;XE_abstract_use_case__description_of&quot;>Concrete and Abstract Use&#xD;
    Cases&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    There is a distinction between concrete and abstract use cases. A &lt;b>concrete&lt;/b> use case is initiated by an actor and&#xD;
    constitutes a complete flow of events. &quot;Complete&quot; means that an instance of the use case performs the entire operation&#xD;
    called for by the actor.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An &lt;b>abstract&lt;/b> use case is never instantiated in itself. Abstract use cases are included in (see &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/guidelines/include-relationship_5AE2718.html&quot;&#xD;
    guid=&quot;7.259881398615376E-305&quot;>Guideline: Include-Relationship&lt;/a>), extend into (see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/extend-relationship_EF38D814.html&quot; guid=&quot;3.679940320411645E-305&quot;>Guideline:&#xD;
    Extend-Relationship&lt;/a>), or generalize (see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/use-case_generalization_B301F53B.html&quot; guid=&quot;3.7061366529594173E-305&quot;>Work&#xD;
    Product Guideline: Use-Case-Generalization&lt;/a>) other use cases. When a concrete use case is initiated, an instance of&#xD;
    the use case is created. This instance also exhibits the behavior specified by its associated abstract use cases. Thus,&#xD;
    no separate instances are created from abstract use cases.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The distinction between the two is important, because it is concrete use cases the actors will &quot;see&quot; and initiate in&#xD;
    the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You indicate that a use case is abstract by writing its name in italics.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Example:&#xD;
&lt;/h5>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;165&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;resources/ucmex3.gif&quot; width=&quot;213&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    The use case Create Task is included in the use case Register Order. Create Task is an abstract use case.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In the Depot-Handling System the abstract use case, Create Task, is included in the use case Register Order. When&#xD;
    Register Order is initiated, an instance of Register Order is created that, apart from following Register Order's flow&#xD;
    of events, also follows the flow of events described in the included use case, Create Task. Create Task is never&#xD;
    performed by itself, always as a part of Register Order (or any other use cases in which it is included). Create Task&#xD;
    is therefore an abstract use case.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Structuring the Use-Case Model&quot; name=&quot;Structuring the Use-Case Model&quot;>Structuring the Use-Case Model&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    There are three main reasons for structuring the use-case model:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        To make the use cases easier to understand.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To partition out common behavior described within many use cases&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To make the use-case model easier to maintain.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Structuring is, however, not the first thing you do. There is no point in structuring the use cases until you know a&#xD;
    bit more about their behavior, beyond a one sentence brief description. You should at least have established a&#xD;
    step-by-step outline to the flow of events of the use case, to make sure that you decisions are based on an accurate&#xD;
    enough understanding of the behavior.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To structure the use cases, we have three kinds of relationships. You will use these relationships to factor out pieces&#xD;
    of use cases that can be reused in other use cases, or that are specializations or options to the use case. The use&#xD;
    case that represents the modification is called the &lt;b>addition use case&lt;/b>. The use case that is modified is called&#xD;
    the &lt;b>base use case&lt;/b>.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        If there is a part of a base use case that represents a function of which the use case only depends on the result,&#xD;
        not the method used to produce the result, you can factor that part out to an addition use case. The addition is&#xD;
        explicitly inserted in the base use case, using the include-relationship. See also &lt;a class=&quot;elementLinkWithType&quot;&#xD;
        href=&quot;./../../../core.base_rup/guidances/guidelines/include-relationship_5AE2718.html&quot;&#xD;
        guid=&quot;7.259881398615376E-305&quot;>Guideline: Include-Relationship&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If there is a part of a base use case that is optional, or not necessary to understand the primary purpose of the&#xD;
        use case, you can factor that part out to an addition use case in order to simplify the structure of the base use&#xD;
        case. The addition is implicitly inserted in the base use case, using the extend-relationship. See also &lt;a&#xD;
        class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/guidelines/extend-relationship_EF38D814.html&quot;&#xD;
        guid=&quot;3.679940320411645E-305&quot;>Guideline: Extend-Relationship&lt;/a>.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        If there are use cases that have commonalities in behavior and structure and similarities in purpose, their common&#xD;
        parts can be factored out to a base use case (parent) that is inherited by addition use cases (children). The child&#xD;
        use cases can insert new behavior and modify existing behavior in the structure they inherit from the parent use&#xD;
        case. See also &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
        href=&quot;./../../../core.base_rup/guidances/guidelines/use-case_generalization_B301F53B.html&quot;&#xD;
        guid=&quot;3.7061366529594173E-305&quot;>Work Product Guideline: Use-Case-Generalization&lt;/a>.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    You can use actor-generalization to show how actors are specializations of one another. See also &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/guidelines/actor-generalization_2AFC6BE3.html&quot;&#xD;
    guid=&quot;2.144844789747145E-305&quot;>Guideline: Actor-Generalization&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    Consider part of the use-case model for an Order Management System.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    It is useful to separate ordinary Customer from Internet Customer, since they have slightly different properties.&#xD;
    However, since Internet Customer does exhibit all properties of a Customer, you can say that Internet Customer is a&#xD;
    specialization of Customer, indicated with an actor-generalization.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The concrete use cases in this diagram are Telephone Order (initiated by the Customer actor) and Internet Order&#xD;
    (initiated by Internet Customer). These use cases are both variations of the more general Place Order use case, which&#xD;
    in this example is abstract. The Request Catalog use case represents an optional segment of behavior that is not part&#xD;
    of the primary purpose of Place Order. It has been factored out to an abstract use case to simplify the Place Order use&#xD;
    case. The Supply Customer Data use case represents a segment of behavior that was factored out since it is a separate&#xD;
    function of which only the result is affecting the Place Order use case. The Supply Customer Data use case can also be&#xD;
    reused in other use cases. Both Request Catalog and Supply Customer Data are abstract in this example.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;366&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;resources/ucmex2.gif&quot; width=&quot;354&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    This use-case diagram shows part of the use-case model for an Order Management System.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The following table shows a more detailed comparison between the three different use-case relationships:&#xD;
&lt;/p>&#xD;
&lt;div align=&quot;center&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;85%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;th width=&quot;20%&quot;>&#xD;
                    Question&#xD;
                &lt;/th>&#xD;
                &lt;th width=&quot;20%&quot;>&#xD;
                    Extend&#xD;
                &lt;/th>&#xD;
                &lt;th width=&quot;27%&quot;>&#xD;
                    Include&#xD;
                &lt;/th>&#xD;
                &lt;th width=&quot;33%&quot;>&#xD;
                    Generalization&#xD;
                &lt;/th>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    What is the direction of the relationship?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    The addition use case references the base use case.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    The base use case references the addition use case.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    The addition use case (child) references the base use case (parent).&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Does the relationship have multiplicity?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Yes, on the addition side.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    No. If you want to include the same segment of behavior more than once, that needs to be stated in the&#xD;
                    base use case.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    No.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Does the relationship have a condition?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Yes.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    No. If you want to express a condition on the inclusion you need to say it explicitly in the base use&#xD;
                    case.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    No.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Is the addition use case abstract?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Often yes, but not necessarily.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    Yes.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    Often no, but it can be.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Is the base use case modified by the addition?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    The extension implicitly modifies the behavior of the base use case.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    The inclusion explicitly modifies the effect of the base use case.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    If the base use case (parent) is instantiated, it is unaffected by the child. To obtain the effects of&#xD;
                    the addition, the addition use case (child) must be instantiated.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Does the base use case have to be complete and meaningful?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Yes.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    Together with the additions, yes.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    If it is abstract, no.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Does the addition use case have to be complete and meaningful?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    No.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    No.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    Together with the base use case (parent), yes.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Can the addition use case access attributes of the base use case?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Yes.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    No. The inclusion is encapsulated, and only &quot;sees&quot; itself.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    Yes, by the normal mechanisms of inheritance.&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    Can the base use case access attributes of the addition use case?&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;20%&quot;>&#xD;
                    No. The base use case must be well-formed in the absence of the addition.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;27%&quot;>&#xD;
                    No. The base use case only knows about the effect of the addition. The addition is encapsulated.&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;33%&quot;>&#xD;
                    No. The base use case (parent) must in this sense be well-formed in the absence of the addition&#xD;
                    (child).&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Another aspect of organizing the use-case model for easier understanding is to group the use cases into packages. The&#xD;
    use-case model can be organized as a hierarchy of use-case packages, with &quot;leaves&quot; that are actors or use cases. See&#xD;
    also &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/guidelines/use-case_package_1EFD6458.html&quot;&#xD;
    guid=&quot;9.871865834975133E-306&quot;>Guideline: Use-Case Package&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturecenter&quot; align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;235&quot; alt=&quot;Diagram described in caption.&quot; src=&quot;resources/md_ucmo6.gif&quot; width=&quot;181&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    This graph shows the use-case model hierarchy. Arrows indicate possible ownership.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Use Cases Are Always Related to Actors&quot; name=&quot;Use Cases Are Always Related to Actors&quot;>Are Use Cases Always&#xD;
    Related to Actors?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The execution of each use case includes communication with one or more actors. A use case instance is always started by&#xD;
    an actor asking the system to do something. This implies that every use case should have communicates-associations with&#xD;
    actors. The reason for this rule is to enforce the system to provide only the functionality that users need, and&#xD;
    nothing else. Having use cases that no one requests is an indication that something is wrong in the use-case model or&#xD;
    in the requirements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    However, there are some exceptions to this rule:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        If a use case is abstract (not separately instantiable), its behavior may not include interaction with any actor.&#xD;
        In that case, there will not be any communication-associations to actors from that abstract use case.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A child use case in a generalization-relationship does not need to have an actor associated with it if the parent&#xD;
        use case describes all actor communication.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A base use case in an include-relationship does not need to have an actor associated with it if the inclusion use&#xD;
        case describes all actor communication.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A use case may be initiated according to a schedule (for example, once a week or once a day), which means the&#xD;
        system clock is the initiator. The system clock is internal to the system - and the use case is not initiated by an&#xD;
        actor, but by an internal system event. If no other actor interaction occurs in the use case, it will not have any&#xD;
        associations to actors. However, for clarity, you can use a fictive actor &quot;Time&quot; to show how the use case is&#xD;
        initiated in your use-case diagrams.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;The Survey Description&quot; name=&quot;The Survey Description&quot;>The Survey Description&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The survey description of the use-case model should:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        State which are the primary use cases of the system (the reason the system is built).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Summarize important technical facts about the system.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Point out system delimitations - things that the system is not supposed to do.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Summarize the system's environment, for example, target platforms and existing software.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Describe any sequences in which use cases are normally performed in the system.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Specify functionality not handled by the use-case model.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    &lt;font color=&quot;#000000&quot;>Following is a sample survey description of the Recycling Machine's use-case model:&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    This model contains three actors and three use cases. The primary use case is Recycle Items, which represents the main&#xD;
    purpose of the Recycling Machine.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    Supporting use cases are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;example&quot;>&#xD;
            Print Daily Report, which allows an operator to get a report on how many items have been recycled.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p class=&quot;example&quot;>&#xD;
            Administer Deposit Item, which allows an operator to change refund value for a type of deposit item, or add new&#xD;
            deposit item types.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&lt;br />&#xD;
&lt;br /></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
