<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_zgLdYNnmEdmO6L4XMImrsA" name="differences_between_uml_1_x_and_uml_2_0,4.792914878943572E-306" guid="_zgLdYNnmEdmO6L4XMImrsA" changeDate="2006-05-05T11:02:11.534-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_UML_2_._0__whats_new&quot; name=&quot;XE_UML_2_._0__whats_new&quot;>&lt;/a> &#xD;
&lt;h2 align=&quot;justify&quot;>&#xD;
    Topics&#xD;
&lt;/h2>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#overview&quot;>Overview&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#activitydiagram&quot;>Activity Diagram&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#communicationdiagram&quot;>Communication Diagram&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#component&quot;>Component&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#compositestructurediagram&quot;>Composite Structure Diagram&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#sequencediagram&quot;>Sequence Diagram&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;overview&quot; name=&quot;overview&quot;>Overview&lt;/a>&#xD;
&lt;/h2>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    This page describes some differences from UML 1.x and UML 2.0 that are relevant to RUP context. It is not intended to&#xD;
    cover all UML ([&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04&quot; guid=&quot;7.755968586980351E-308&quot;>UML04&lt;/a>])&#xD;
    Infrastructure and Superstructure Specifications, but to give an overview of relevant UML capabilities instead. Also,&#xD;
    refer to [&lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#RUM05&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>RUM05&lt;/a>] and [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#ERI04&quot; guid=&quot;7.755968586980351E-308&quot;>ERI04&lt;/a>] for more&#xD;
    information.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    Note that &quot;UML 1.x&quot; refers to UML 1.0 to UML 1.5 versions.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    The most significant diagrammatical changes in the UML 2.0 feature set are in the behavioral diagrams, specifically the&#xD;
    activity diagram and the set of interaction diagrams (see &lt;a href=&quot;#activitydiagram&quot;>Activity Diagram&lt;/a>, &lt;a&#xD;
    href=&quot;#sequencediagram&quot;>Sequence Diagram&lt;/a> and &lt;a href=&quot;#communicationdiagram&quot;>Communication Diagram&lt;/a> below).&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    Composite Structure Diagram and Structured Class are also new UML 2.0 features (see &lt;a&#xD;
    href=&quot;#compositestructurediagram&quot;>Composite Structure Diagram&lt;/a> below).&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;activitydiagram&quot; name=&quot;activitydiagram&quot;>Activity Diagram&lt;/a>&#xD;
&lt;/h2>&#xD;
&lt;h3>&#xD;
    &lt;strong>Introduction&lt;/strong>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The modeling of activities has undergone a complete revision in UML 2.0. It is fair to say that, at least for casual&#xD;
    use, the effect and appearance might be very similar, although depending on the formality of modeling in UML 1.5 (and&#xD;
    earlier versions), it is possible that the strict interpretation and the execution result of a model constructed&#xD;
    according to UML 1.x rules would not be the same in UML 2.0. Therefore we caution the modeler that even when a UML 1.x&#xD;
    activity model appears to be acceptable to UML 2.0 without change, it might not execute in the same way - particularly&#xD;
    in the case of more complex models involving concurrency. Refer to [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04&quot; guid=&quot;7.755968586980351E-308&quot;>UML04&lt;/a>] for more&#xD;
    information.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As [&lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>UML04&lt;/a>] defines it, an &lt;em>activity&lt;/em> (which will be shown in an &lt;em>activity&#xD;
    diagram&lt;/em>) is the specification of behavior as the coordinated sequencing of subordinate units whose individual&#xD;
    elements are &lt;em>actions&lt;/em>. We may have informally referred to the individual executable steps in a UML 1.x activity&#xD;
    diagram as activities or activity states or, correctly, as action states: now these steps in a UML 2.0 activity are&#xD;
    called actions - and these actions are not decomposed further within the activity. The connotation of state has&#xD;
    disappeared in UML 2.0 because an activity is no longer a kind of state machine, as it was in UML 1.x. In UML 2.0,&#xD;
    activities are composed of &lt;em>nodes,&lt;/em> of which actions are one kind; others, described further below, are&#xD;
    &lt;em>control&lt;/em> nodes and &lt;em>object&lt;/em> nodes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Flow Semantics&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Activities now have Petri Net-like semantics, based on &lt;em>token flow,&lt;/em> where the execution of one node affects the&#xD;
    execution of another through directed connections called flows. Tokens, containing objects or a locus of control, flow&#xD;
    between nodes across these connections. A node is allowed to begin execution when specified conditions on its input&#xD;
    tokens are met, and when it completes execution, it offers tokens on its output flows, so that downstream nodes may&#xD;
    begin execution. The flows connecting nodes are further refined into control and data or object flows and, as you might&#xD;
    expect, control tokens move across control flows and object or data tokens pass across object flows.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    This contrasts with UML 1.x, where the nodes were states (or pseudo states) with transitions between them, which&#xD;
    limited the modeling of flows.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Concurrency Modeling&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The modeling capability of UML 2.0 allows unrestricted parallelism: whereas in UML 1.x, the entire state machine&#xD;
    (activity) performed a run-to-completion step, the UML 2.0 capability, in its most complete form, permits multiple&#xD;
    invocations of an activity to be handled by a single execution with multiple streams of tokens moving through the nodes&#xD;
    and flow connectors of the activity. This puts the onus on the modeler to be aware of race conditions and interactions.&#xD;
    Also, see the section &lt;strong>Semantic Differences&lt;/strong> below for another example of the effect on concurrency&#xD;
    modeling of token flow semantics.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;strong>Notation&lt;/strong>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    &lt;strong>Action and Control Nodes&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The diagram below illustrates many of the UML 2.0 elements, and is presented in the usual way for UML 2.0, with a&#xD;
    rectangular frame and a name in a compartment at the upper left. Compare this diagram with the UML 1.x version shown&#xD;
    below it. They are similar in appearance (allowing for the differing orientation and color conventions used-these have&#xD;
    no semantic significance), and this model has the same execution result in UML 1.x and UML 2.0. Note that the control&#xD;
    nodes - decision, merge, fork, join, initial and final - look like their UML 1.x equivalents, and the control flows are&#xD;
    shown with an arrowed line, a visual analog to the UML 1.x transition arrow.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;404&quot;&#xD;
    alt=&quot;An activity diagram with various node types: initial, action, decision, fork, join, merge and activity final. It also shows control flow.&quot;&#xD;
     src=&quot;resources/activity20.gif&quot; width=&quot;630&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Example UML 2.0 activity diagram&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;505&quot; alt=&quot;This diagram shows the equivalent UML 1.x version.&quot; src=&quot;resources/activity1x.gif&quot;&#xD;
    width=&quot;474&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Example UML 1.x activity diagram&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    UML 2.0 has an additional control node type called &lt;em>Flow Final&lt;/em> (shown below in a diagram taken from [&lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04&quot;&#xD;
    guid=&quot;7.755968586980351E-308&quot;>UML04&lt;/a>]) that is used as an alternative to the Activity Final node to terminate a&#xD;
    flow. It is needed because in UML 2.0, when control reaches any instance of Activity Final node, the entire activity&#xD;
    (including all flows) is terminated. Flow Final simply terminates the flow to which it is attached. This was not an&#xD;
    issue in UML 1.5 because of the run-to-completion semantics, but with the unrestricted parallelism of UML 2.0, you&#xD;
    might not want all flows stopped and all tokens destroyed.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;123&quot; alt=&quot;This diagram illustrates the flow final control node.&quot; src=&quot;resources/flowfinal.gif&quot;&#xD;
    width=&quot;314&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Flow final control node&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Object Nodes&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    UML 2.0 activity modeling also supports object nodes. An object node is an activity node that indicates that an&#xD;
    instance of a particular classifier, possibly in a particular state, might be available at a particular point in the&#xD;
    activity (for example, as output from, or input to an action). Object nodes act as containers to and from which objects&#xD;
    of a particular type (and possibly in a particular state) might flow. New notation, called a &lt;em>pin&lt;/em>, has been&#xD;
    introduced for object nodes in UML 2.0. Pins represent inputs to an action or outputs from an action and are drawn as&#xD;
    small rectangles that are attached to the action rectangles, as shown below.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;114&quot;&#xD;
    alt=&quot;This diagram shows the pin notation for object nodes, with an output pin connected to an input pin by an object flow.&quot;&#xD;
     src=&quot;resources/pins.gif&quot; width=&quot;262&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Pin notation&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The arrows represent object flows. These are solid lines, unlike the dashed lines used for transitions to and from&#xD;
    object flow states in UML 1.x. When the output pin on an action has the same name as the input pin on the connected&#xD;
    action, the output and input pins may be merged to give a standalone pin. This again gives a visual analog to object&#xD;
    flow in UML 1.x.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;127&quot; alt=&quot;This diagram shows the alternative standalone pin notation.&quot; src=&quot;resources/standalonepin.gif&quot;&#xD;
    width=&quot;267&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    Standalone pin notation&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Structured Activity Nodes&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A structured activity node is an executable activity node that may have an expansion into subordinate activity nodes.&#xD;
    The subordinate nodes belong to only one structured activity node, but they may be nested. It may have control flows&#xD;
    connected to it and pins attached to it. A structured activity node is drawn as a dashed round cornered rectangle&#xD;
    enclosing its nodes and flows, with the keyword &amp;lt;&amp;lt;structured&amp;gt;&amp;gt; at the top.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Activity Partitions&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An &lt;em>activity partition&lt;/em> is a way of grouping the nodes and flows of an activity according to some shared&#xD;
    characteristic. In UML 1.x, the idea of swimlanes (which were regarded as partitions) was used in activity diagrams to&#xD;
    group actions according to some criterion - for example, in business modeling, by performing organization. UML 2.0&#xD;
    extends this partitioning capability to multiple dimensions for activity diagrams and provides additional notation so&#xD;
    that, for example, individual actions can be labeled with the name of the partition to which they belong. The diagram&#xD;
    below shows an example of multidimensional swimlanes as they would appear according to UML 2.0, where actions are&#xD;
    grouped according to location and responsibility.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;328&quot; alt=&quot;An illustration of the UML 2.0 style of activity partitions, with two dimensional swimlanes.&quot;&#xD;
    src=&quot;resources/partitions.gif&quot; width=&quot;627&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Activity partitions example using two-dimensional swimlane&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Semantic Differences&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The token flow semantics and the unrestricted parallelism of UML 2.0 activity models require the modeler accustomed to&#xD;
    UML 1.x to exercise caution when constructing new models or converting existing models, to ensure the execution result&#xD;
    is that intended. For example, in the processPassenger example above, the passenger checking in might be a frequent&#xD;
    flyer member, in which case, the agent needs to award the passenger frequent flyer miles, as shown below in a UML 1.x&#xD;
    model fragment.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;256&quot; alt=&quot;This diagram shows a UML 1.x model fragment with a guarded concurrent transition.&quot;&#xD;
    src=&quot;resources/concurguard1.gif&quot; width=&quot;333&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Using guarded concurrent transition&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Placing the guard on the optional concurrent transition means that, in UML 1.x, the transition never starts, and the&#xD;
    behavior is as if the transition were not shown in the model; accordingly, when the other two transitions complete,&#xD;
    execution continues after the join. In UML 2.0, if the passenger is not a frequent flyer, no token will ever reach the&#xD;
    join along that flow and the model will stall because the join waits for tokens on all its flows before continuing. The&#xD;
    model should be constructed as shown below, with the condition treated in the same way as the baggage handling flow. It&#xD;
    is permissible to place guards directly on concurrent flows as long as you are sure no downstream join depends on them.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;307&quot;&#xD;
    alt=&quot;A UML 2.0 version of the previous diagram, using decision and merge nodes instead of the guarded concurrent flow.&quot;&#xD;
    src=&quot;resources/concurguard2.gif&quot; width=&quot;333&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Using decision and merge nodes instead of the guarded concurrent flow&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;communicationdiagram&quot; name=&quot;communicationdiagram&quot;>Communication Diagram&lt;/a>&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    The UML 1.x collaboration diagram has been renamed to &lt;em>communication diagram&lt;/em> in UML 2.0. There are no semantic&#xD;
    differences from previous versions. The communication diagram is based on the former collaboration diagram and still is&#xD;
    one type of interaction diagram.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;strong>Notation&lt;/strong>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A communication diagram focuses on the interaction between lifelines. It is shown as a graph whose nodes are rectangles&#xD;
    representing parts of a structured class or roles of a collaboration. A rectangular frame around the diagram with a&#xD;
    name in a compartment in the upper left corner is used, which is a notational change from previous UML versions.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        The nodes correspond to the lifelines in an interaction.&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        Lines between parts represent connectors that form communication paths.&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        Multiplicities may be shown on connectors.&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        Messages between parts are shown by labeled arrows near connector lines.&#xD;
    &lt;/li>&#xD;
&lt;/ul>A communication diagram is used to model interactions that represent the implementation of an operation or usecase. &#xD;
&lt;p>&#xD;
    Example of a communication diagram:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img alt=&quot;Example of Communication Diagram for an Ordering system.&quot; src=&quot;resources/communicdiag.jpg&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Example of Communication Diagram for an Ordering system&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;component&quot; name=&quot;component&quot;>Component&lt;/a>&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    In UML 2.0, a component is notated by a class symbol without the two protruding rectangles, as defined in UML 1.4. A&#xD;
    &amp;lt;&amp;lt;component&amp;gt;&amp;gt; stereotype is used instead. Optionally, a component icon that is similar to the UML 1.4 icon&#xD;
    can still be used in the upper-right corner of the component symbol.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    UML 2.0 defines a component as being a structured class, which means that the collaboration between elements in its&#xD;
    internal structure (parts) can be modeled to better describe its behavior. Parts are connected through connectors.&#xD;
    Ports can be used to increase encapsulation level of a component through its provided and required interfaces. Refer to&#xD;
    &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/concepts/component_A2E2B3B1.html&quot;&#xD;
    guid=&quot;3.524150980437479E-305&quot;>Concept: Component&lt;/a> and &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html&quot; guid=&quot;1.1994826813129747E-304&quot;>Concept:&#xD;
    Structured Class&lt;/a> for more information.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Earlier versions of UML defined a special modeling element called &lt;em>subsystem&lt;/em>, which was modeled as a package&#xD;
    with interface. Also, components were used to structure the model in the physical architecture. In UML 2.0, components&#xD;
    are used in a broad sense, across all parts of the model. Thus, there is no need for a special element to model&#xD;
    subsystems anymore. Separate compartments for subsystem realization and subsystem specification in UML 1.x have become&#xD;
    separate stereotypes (&amp;lt;&amp;lt;realization&amp;gt;&amp;gt; and &amp;lt;&amp;lt;specification&amp;gt;&amp;gt;, respectively) applied to&#xD;
    components in UML 2.0. Another new component stereotype is &amp;lt;&amp;lt;subsystem&amp;gt;&amp;gt;, indicated to model large-scale&#xD;
    components.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    RUP suggests using components to model subsystems (refer to &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html&quot; guid=&quot;1.2314266786534317E-305&quot;>Guideline:&#xD;
    Design Subsystem&lt;/a> for more information).&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;compositestructurediagram&quot; name=&quot;compositestructurediagram&quot;>Composite Structure Diagram&lt;/a>&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    Architectures can have specific collaboration between its elements, with parts and connectors not necessarily known at&#xD;
    design time. A typical class diagram (as well as other static diagrams) wouldn't be sufficient to clearly represent the&#xD;
    roles, responsibilities, relationships and rules that apply on those elements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To address these issues, UML 2.0 has added the composite structure diagram. It can depict the internal structure of a&#xD;
    structured class (for example, component or class), including the interaction points of the structured class to other&#xD;
    parts of the system. It shows the configuration of parts that jointly perform the behavior of the containing structured&#xD;
    class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Composite Structure Diagrams are used to draw internal content of Structured Classes (refer to &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html&quot;&#xD;
    guid=&quot;1.1994826813129747E-304&quot;>Concept: Structured Class&lt;/a> for details and examples of Composite Structure Diagrams).&#xD;
&lt;/p>&#xD;
&lt;h2>&#xD;
    &lt;a id=&quot;sequencediagram&quot; name=&quot;sequencediagram&quot;>Sequence Diagram&lt;/a>&#xD;
&lt;/h2>&#xD;
&lt;p>&#xD;
    UML 2.0 has several new features for sequence diagrams:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        Fragments provide clearer semantics for how the behavior occurs within a sequence diagram. A combined fragment&#xD;
        encapsulates portions of a sequence diagram, where separate flows can be modeled, showing how conditions lead to&#xD;
        alternative paths of execution.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        Interaction occurrences enable decomposition of interactions into reusable chunks. It is a useful way to share&#xD;
        portions of an interaction between several other interactions.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        In UML 1.x, one possible representation for loops was to use the loop condition written inside a Note. The Note was&#xD;
        attached to the message or set of messages to be executed while the loop condition was true. In UML 2.0, there is a&#xD;
        specific representation for loops.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        In UML 2.0, sequence diagrams can show how objects are created and destroyed.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        Execution of Occurrence shows the focus of control which an object executes at some point in time, when it receives&#xD;
        a message.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    With the new capabilities to represent fragments, interaction occurrences and loops, sequence diagrams can be used in&#xD;
    two forms:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        Instance form: describes a specific scenario in detail, documenting one possible interaction, without conditions,&#xD;
        branches, or loops. This form is used to represent one use case scenario. Different scenarios of the same use-case&#xD;
        are represented in different sequence diagrams. Modeling tools that support UML 1.x semantics only allow this form&#xD;
        of representation.&lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        Generic form: describes all possible alternatives in a scenario, taking advantage of new UML 2.0 capabilities like&#xD;
        conditions, branches, and loops. This form can be used to represent several scenarios of the same use case in a&#xD;
        unique sequence diagram, where it makes sense.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    The figure below shows an example of a sequence diagram modeling different scenarios. The &lt;strong>alt&lt;/strong> fragment&#xD;
    shows two possible alternatives of message sequencing depending on if a condition is satisfied or not:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img alt=&quot;Sequence diagram showing branches, loops and conditions&quot; src=&quot;resources/seqdiag.jpg&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Example: Sequence diagram showing branches, loops and conditions&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
