<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:TaskDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_1zQTQNnmEdmO6L4XMImrsA" name="use_case_design,{76E2B93D-051C-4B8C-BEA1-B40A40CBD986}" guid="_1zQTQNnmEdmO6L4XMImrsA" changeDate="2005-08-23T17:00:39.749-0700" version="7.1.0">
  <mainDescription>&lt;p>&#xD;
    &lt;a id=&quot;XE_interaction__describing_interactions_between_design_objects&quot;&#xD;
    name=&quot;XE_interaction__describing_interactions_between_design_objects&quot;>&lt;/a>The behavior of a system can be described&#xD;
    using a number of techniques - collaborations or interactions. This task describes the use of interactions,&#xD;
    specifically sequence diagrams, to describe the behavior of the system. Sequence diagrams are most useful where the&#xD;
    behavior of the system or subsystem can be primarily described by synchronous messaging. Asynchronous messaging,&#xD;
    especially in event-driven systems, is often more easily described in terms of state machines and collaborations,&#xD;
    allowing a compact way of defining possible interactions between objects. Asynchronous messages play an important role&#xD;
    in real-time or reactive systems, and are used for communication between instances of &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html&quot; guid=&quot;{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}&quot;>Artifact:&#xD;
    Capsule&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &amp;nbsp;UML 1.x Representation&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    You can use a proxy class to represent the subsystem on sequence diagrams. This proxy class is contained within the&#xD;
    subsystem and is used to represent the subsystem in diagrams which do not support the direct use of packages and&#xD;
    subsystems as behavioral elements. Use the proxy class in cases where you want to show that a specific subsystem&#xD;
    responds to a message. In this case, you can show messages being sent from the subsystem proxy to other objects.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Refer to &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html&quot;&#xD;
    guid=&quot;4.792914878943572E-306&quot;>Differences Between UML 1.x and UML 2.0&lt;/a> for more information.&lt;br />&#xD;
&lt;/p></mainDescription>
  <sections xmi:id="_Su48INnnEdmO6L4XMImrsA" name=" Create Use-Case Realizations " guid="_Su48INnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Create Use-Case Realizations&quot; name=&quot;Create Use-Case Realizations&quot;>&lt;/a>&#xD;
&lt;p>&#xD;
    The &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/workproducts/rup_use_case_realization_E4F713BD.html&quot;&#xD;
    guid=&quot;{87EB094F-095B-4981-ACC3-319B3B298641}&quot;>Artifact: Use-Case Realization&lt;/a> provides a way to trace behavior in&#xD;
    the Design Model back to the Use-Case Model, and it organizes collaborations in the Design Model around the Use-Case&#xD;
    concept.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Create a Design Use-Case Realization in the Design Model for each Use Case to be designed. The name for the Design&#xD;
    Use-Case Realization should be the same as the associated Use Case, and a &quot;realizes&quot; relationship should be established&#xD;
    from the use-case realization to its associated use case.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_Su48IdnnEdmO6L4XMImrsA" name=" Describe Interactions Between Design Objects" guid="_Su48IdnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Describe Interactions Between Design Objects&quot; name=&quot;Describe Interactions Between Design Objects&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    For each use-case realization, you should illustrate the interactions between its participating design objects by&#xD;
    creating one or more sequence diagrams. Early versions of these may have been created during &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/tasks/use_case_analysis_A6990185.html&quot;&#xD;
    guid=&quot;{28014615-A62F-452D-B821-30C7CAB0EC44}&quot;>Task: Use-Case Analysis&lt;/a>.&amp;nbsp; Such &quot;analysis versions&quot; of the&#xD;
    use-case realizations describe interactions between &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_analysis_class_DAF7CE03.html&quot; guid=&quot;{1E20603F-A5B8-42D5-BDBC-69DCE9C0FCDB}&quot;>analysis&#xD;
    classes&lt;/a>.&amp;nbsp; They need to be evolved to describe interactions between design elements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Updating the sequence diagrams involves the following steps:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Identify each object that participates in the flow of the use case. This is done by instantiating the design&#xD;
        classes and subsystems identified in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
        href=&quot;./../../core.base_rup/tasks/identify_design_elements_E884AB82.html&quot; guid=&quot;{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}&quot;>Task:&#xD;
        Identify Design Elements&lt;/a>. In real-time systems, you will also be identifying the capsule instances that&#xD;
        participate in the flow of the use case.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Represent each participating object in a sequence diagram. Make a lifeline for each participating object in the&#xD;
        sequence diagram. In order to represent the design subsystems you have some choices: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                You can show instances of the subsystem on the sequence diagram.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                You can use the interfaces realized by the subsystem. This is preferred in cases where you'd like to show&#xD;
                that any model element which realizes the same interface might be used in place of the interface. If you&#xD;
                choose to show interfaces on the sequence diagram, be aware that you will want to ensure that no messages&#xD;
                are sent from the interface to other objects. The reason for this is that interfaces completely encapsulate&#xD;
                the internal realization of their operations. Therefore, we cannot be certain that all model elements which&#xD;
                realize the interface will in fact actually be designed the same way. So on sequence diagrams no messages&#xD;
                should be shown being sent from interfaces.&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                You can use the component to represent the subsystem on sequence diagrams. Use the component in cases where&#xD;
                you want to show that a specific subsystem responds to a message. In this case, you can show messages being&#xD;
                sent from the component to other objects.&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&#xD;
        &lt;p>&#xD;
            Note that these are system-level sequence diagrams, which show how instances of top level design elements&#xD;
            (typically subsystems and subsystem interfaces) interact. Sequence diagrams showing the internal design of&#xD;
            subsystems are produced separately, as part of &lt;a class=&quot;elementLinkWithType&quot;&#xD;
            href=&quot;./../../core.base_rup/tasks/subsystem_design_5D1BCC0C.html&quot; guid=&quot;{CAA385CA-2BA2-40F2-8FE3-E21089D02119}&quot;>Task:&#xD;
            Subsystem Design&lt;/a>.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p>&#xD;
            Note that active object interactions are typically described using specification collaborations and state&#xD;
            machines. They would be used here to show how messages can be sent to active objects by other elements in the&#xD;
            system in a larger use-case realization. In typical usage, active objects are encapsulated within subsystems&#xD;
            for the purpose of this task, such that the use-case realization consists of a set of interacting subsystems.&#xD;
            The interactions define the responsibilities and interfaces of the subsystems. Within the subsystems, active&#xD;
            objects represent concurrent threads of execution. The subsystems allow work to be divided between development&#xD;
            teams, with the interfaces serving as the formal contracts between the teams. For real-time systems, you will&#xD;
            use &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html&quot;&#xD;
            guid=&quot;{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}&quot;>Artifact: Capsule&lt;/a>s to represent the active objects.&#xD;
        &lt;/p>&#xD;
        &lt;p>&#xD;
            A minor note on showing messages emanating from subsystems: restricting messages only to interfaces reduces&#xD;
            coupling between model elements and improves the resiliency of the design. Where possible, you should try to&#xD;
            achieve this, and in cases where there are messages emanating from subsystems to non-interface model elements,&#xD;
            you should look for opportunities to change these to messages to interfaces to improve decoupling in the model.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Represent the interaction that takes place with actors. Represent each actor instance and external object that the&#xD;
        participating objects interacts with by a lifeline in the sequence diagram.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Illustrate the message sending between participating objects. The flow of events begins at the top of the diagram&#xD;
        and continues downward, indicating a vertical chronological axis. Illustrate the message sending between objects by&#xD;
        creating messages (arrows) between the lifelines. The name of a message should be the name of the operation invoked&#xD;
        by the message. In the early stages of design, not many operations will be assigned to the objects, so you may have&#xD;
        to leave this information out and give the message a temporary name; such messages are said to be &quot;unassigned.&quot;&#xD;
        Later, when you have found more of the participating objects' operations, you should update the sequence diagram by&#xD;
        &quot;assigning&quot; the messages with these operations.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Describe what an object does when it receives a message. This is done by attaching a script to the corresponding&#xD;
        message. Place these scripts in the margin of the diagram. Use either structured text or pseudocode. If you use&#xD;
        pseudocode, be sure to use constructs in the implementation language so that the implementation of the&#xD;
        corresponding operations will be easier. When the person responsible for an object's class assigns and defines its&#xD;
        operations, the object's scripts will provide a basis for that work.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;417&quot; alt=&quot;Diagram described in accompanying text.&quot;&#xD;
    src=&quot;./../../core.base_rup/guidances/guidelines/resources/seqdiag1.gif&quot; width=&quot;672&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    You document the use-case behavior performed by the objects in a sequence diagram.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When you have distributed behavior among the objects, you should consider how the flow will be controlled. You found&#xD;
    the objects by assuming they would interact a certain way in the use-case realization, and have a certain role. As you&#xD;
    distribute behavior, you can begin to test those assumptions. In some parts of the flow, you might want to use a&#xD;
    decentralized structure; in others, you might prefer a centralized structure. For definitions of these variants and&#xD;
    recommendations on when to use the two types of structure, see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/guidelines/sequence_diagram_AFA76EBB.html#Distributing%20Control&quot;&#xD;
    guid=&quot;3.211008403369512E-306&quot;>Technique: Sequence Diagrams&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    You might need new objects at this point, for example if you are using a centralized structure and need a new object to&#xD;
    control the flow. Remember that any object you add to the design model must fulfill the requirements made on the object&#xD;
    model.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Incorporate Applicable Design Mechanisms&quot; name=&quot;Incorporate Applicable Design Mechanisms&quot;>Incorporate Applicable&#xD;
    Design Mechanisms&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    During &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/tasks/architectural_analysis_2B9BE03.html&quot;&#xD;
    guid=&quot;{8CB48402-D4C5-4E17-BB33-507315CB1BBF}&quot;>Task: Architectural Analysis&lt;/a>, analysis mechanisms were&#xD;
    identified.&amp;nbsp; During &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html&quot; guid=&quot;{C7A26BD7-3820-48D9-830F-684C3AF155F9}&quot;>Task:&#xD;
    Identify Design Mechanisms&lt;/a>, analysis mechanisms re refined into design mechanisms, the mapping from the analysis&#xD;
    mechanisms to the design mechanisms is captured in the &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
    guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Software Architecture Document&lt;/a>, and the design mechanisms are&#xD;
    documented in the &lt;a class=&quot;elementLink&quot; href=&quot;./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot;&#xD;
    guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>Project-Specific Guidelines&lt;/a>.&amp;nbsp;&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    During this task, Use-Case Design, any applicable design mechanisms are incorporated into the use-case&#xD;
    realizations.&amp;nbsp; The Designer surveys the available design mechanisms and determines those that apply to the&#xD;
    use-case realization being developed, working within the recommendations and guidelines documented in the Software&#xD;
    Architecture Document and the Design Guidelines.&amp;nbsp;&amp;nbsp;&lt;br />&#xD;
     &lt;b>Note:&lt;/b> Applicable design mechanism may have been identified in &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/tasks/use_case_analysis_A6990185.html&quot; guid=&quot;{28014615-A62F-452D-B821-30C7CAB0EC44}&quot;>Task: Use-Case&#xD;
    Analysis&lt;/a>, during which analysis classes may have been &quot;tagged&quot; with a particular analysis mechanism, indicating&#xD;
    that a particular piece of functionality needed to be handled in the design.&amp;nbsp; In such a case, the applicable&#xD;
    design mechanisms are those associated with the analysis mechanisms that analysis classes participating in the use-case&#xD;
    realization were tagged with&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Designer incorporates the applicable design mechanisms into the use-case realizations by including the necessary&#xD;
    design elements and design element interactions into the use-case realizations following the rules of use documented in&#xD;
    the Design Guidelines.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Handle All Variants of the Flow of Events&quot; name=&quot;Handle All Variants of the Flow of Events&quot;>Handle All Variants&#xD;
    of the Flow of Events&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    You should describe each flow variant in a separate sequence diagram. Sequence diagrams are generally preferable to&#xD;
    communication diagram as they tend to be easier to read when the diagram must contain the level of detail we typically&#xD;
    want in when designing the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Start with describing the basic flow, which is the most common or most important flow of events. Then describe variants&#xD;
    such as exceptional flows. You do not have to describe all the flows of events, as long as you employ and exemplify all&#xD;
    operations of the participating objects. Given this, very trivial flows can be omitted, such as those that concern only&#xD;
    one object.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Study the use case to see if there are flow variants other than those already described in requirements capture and&#xD;
    analysis, for example, those that depend on implementation. As you identify new flows, describe each one in a sequence&#xD;
    diagram. Examples of exceptional flows include the following.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Error handling&lt;/b>. If an interface reports that an error has occurred in its communication with some external&#xD;
        system, for example, the use case should deal with this. A possible solution is to open a new communication route.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Time-out handling&lt;/b>. If the user does not reply within a certain period, the use case should take some special&#xD;
        measures.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Handling of erroneous input to the objects that participate in the use case&lt;/b>. Errors like this might stem&#xD;
        from incorrect user input.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Handle Optional Parts of the Use Case&quot; name=&quot;Handle Optional Parts of the Use Case&quot;>Handle Optional Parts of the&#xD;
    Use Case&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    You can describe an alternative path of a flow as an optional flow instead of as a variant. The following list includes&#xD;
    two examples of optional flows.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        By sending a signal, the actor decides-from a number of options-what the use case is to do next. The use case has&#xD;
        asked the actor to answer yes or no to a question, for example, or provided the actor with a variety of functions&#xD;
        the system can perform in the use case's current state.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The flow path varies depending on the value of stored attributes or relationships. The subsequent flow of events&#xD;
        depends on the type of data to be processed.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    If you want an optional flow, or any complex sub-flow, to be especially noticeable, use a separate sequence diagram.&#xD;
    Each separate sequence diagram should be referred to from the sequence diagram for the main flow of events using&#xD;
    scripts, margin text or notes to indicate where the optional or sub-flow behavior occurs.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In cases where the optional or exceptional flow behavior could occur anywhere, for example behavior which executes when&#xD;
    a particular event occurs, the sequence diagram for the main flow of events should be annotated to indicate that when&#xD;
    the event occurs, the behavior described in the optional/exceptional sequence diagram will be executed. Alternately, if&#xD;
    there is significant event-driven behavior, consider using statechart diagrams to describe the behavior of the system.&#xD;
    For more information, see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html&quot; guid=&quot;1.4528459404144188E-304&quot;>Guideline:&#xD;
    Statechart Diagram&lt;/a>.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_SvCtINnnEdmO6L4XMImrsA" name=" Simplify Sequence Diagrams Using Subsystems (optional) " guid="_SvCtINnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Simplify Sequence Diagrams Using Subsystems (optional)&quot;&#xD;
name=&quot;Simplify Sequence Diagrams Using Subsystems (optional)&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    When a use case is realized, the flow of events is usually described in terms of the executing objects, i.e. as&#xD;
    interaction between design objects. To simplify diagrams and to identify re-usable behavior, there may be a need to&#xD;
    encapsulate a sub-flow of events within a subsystem. When this is done, large subsections of the sequence diagram are&#xD;
    replaced with a single message to the subsystem. Within the subsystem, a separate sequence diagram may illustrate the&#xD;
    internal interactions within the subsystem that provide the required behavior (for more information, see &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/tasks/subsystem_design_5D1BCC0C.html&quot;&#xD;
    guid=&quot;{CAA385CA-2BA2-40F2-8FE3-E21089D02119}&quot;>Task: Subsystem Design&lt;/a>).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Sub-sequences of messages within sequence diagrams should be encapsulated within a subsystem when:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        The sub-sequence occurs repeatedly in different use-case realizations; that is, the same (or similar) messages are&#xD;
        sent to the same (or similar) objects, providing the same end result. The phrase 'similar' is used because some&#xD;
        design work might be needed to make the behavior reusable.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The sub-sequence occurs in only one use-case realization, but it is expected to be performed repeatedly in future&#xD;
        iterations, or in similar systems in the future. The behavior might make a good reusable component.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The sub-sequence occurs in only one use-case realization, but is complex but easily encapsulated, needs to be the&#xD;
        responsibility of one person or a team, and provides a well-defined result. In these kinds of situations, the&#xD;
        complex behavior usually requires special technical knowledge, or special domain knowledge, and as a result is&#xD;
        well-suited to encapsulating it within a subsystem.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The sub-sequence is determined to be encapsulated within a replaceable component (see &lt;a&#xD;
        class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/guidances/concepts/component_A2E2B3B1.html&quot;&#xD;
        guid=&quot;3.524150980437479E-305&quot;>Concept: Component&lt;/a>). In this case, a subsystem is the appropriate representation&#xD;
        for the component within the design model.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;121&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/seqdiag6.gif&quot; width=&quot;409&quot; border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    A use-case realization can be described, if necessary, at several levels in the subsystem hierarchy. The lifelines in&#xD;
    the middle diagram represent subsystems; the interactions in the circles represent the internal interaction of&#xD;
    subsystem members in response to the message.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The advantages of this approach are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Use-case realizations become less cluttered, especially if the internal design of some subsystems is complex.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Use-case realizations can be created before the internal designs of subsystems are created; this is useful for&#xD;
        example in parallel development environments (see &quot;&lt;a href=&quot;#How%20to%20Work%20in%20Parallel&quot;>How to Work in&#xD;
        Parallel&lt;/a>&quot;).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Use-case realizations become more generic and easy to change, especially if a subsystem needs to be substituted&#xD;
        with another subsystem.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    Consider the following sequence diagram, which is part of a realization of the &lt;b>Local Call&lt;/b> use case:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;396&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/seqdiag7.gif&quot; width=&quot;729&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    In this diagram, the gray classes belong to a Network Handling subsystem; the other classes belong to a Subscriber&#xD;
    Handling subsystem. This implies that this is a multi-subsystem sequence diagram, i.e. a diagram where all the objects&#xD;
    that participate in the flow of events are included, regardless of whether their classes lie in different subsystems or&#xD;
    not.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    As an alternative, we can show invocation of behavior on the Network Handling subsystem, and the exercise of a&#xD;
    particular interface on that subsystem. Let's assume that the Network Handling subsystem provides an ICoordinator&#xD;
    interface, which is used by the Subscriber Handling subsystem:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;100&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/subs_if.gif&quot; width=&quot;425&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    The ICoordinator interface is realized by the Coordinator class within Network Handling. Given this, we can use the&#xD;
    Network Handling subsystem itself and its ICoordinator interface in the sequence diagram, instead of instances of&#xD;
    classes within Network Handling:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;417&quot; alt=&quot;Diagram described in accompanying text.&quot;&#xD;
    src=&quot;./../../core.base_rup/guidances/guidelines/resources/seqdiag1.gif&quot; width=&quot;672&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    Note that the Coordinator, Digit Information, and Network class instances are substituted by their containing&#xD;
    subsystem. All calls to the subsystem are instead done via the ICoordinator interface.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Showing Interfaces on Lifelines&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In order to achieve true substitutability of subsystems realizing the same interface, only their interface should be&#xD;
    visible in interactions (and in diagrams in general); otherwise the interactions (or diagrams) need to be changed when&#xD;
    subsystems are substituted with each other.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;exampleheading&quot;>&#xD;
    Example:&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot; align=&quot;left&quot;>&#xD;
    We can include only the ICoordinator interface, but not its providing subsystem, in a sequence diagram:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;309&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/seqdiag2.gif&quot; width=&quot;519&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;example&quot;>&#xD;
    Sending a message to an interface lifeline means that any subsystem which realizes the interface can be substituted for&#xD;
    the interface in the diagram. Note that the ICoordinator interface lifeline does not have messages going out from it,&#xD;
    since different subsystems realizing the interface might send different messages. However, if you want to describe what&#xD;
    messages should be sent (or are allowed to be sent) from any subsystem realizing the interface, such messages can go&#xD;
    out from the interface lifeline.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;How to Work in Parallel&quot; name=&quot;How to Work in Parallel&quot;>How to Work in Parallel&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In some cases it can be appropriate to develop a subsystem more or less independently and in parallel with the&#xD;
    development of other subsystems. To achieve this, we must first find subsystem dependencies by identifying the&#xD;
    interfaces between them.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The work can be done as follows:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Concentrate on the requirements that affect the interfaces between the subsystems.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Make outlines of the required interfaces, showing the messages that are going to pass over the subsystem borders.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Draw sequence diagrams in terms of subsystems for each use case.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Refine the interfaces needed to provide messages.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Develop each subsystem in parallel, and use the interfaces as synchronization instruments between development&#xD;
        teams.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    You can also choose whether to arrange the sequence diagrams in term of subsystems or in terms of their interfaces&#xD;
    only. In some projects, it might even be necessary to implement the classes providing the interfaces before you&#xD;
    continue with the rest of the modeling.&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_SyUqoNnnEdmO6L4XMImrsA" name=" Describe Persistence-Related Behavior" guid="_SyUqoNnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;XE_persistent_object__describing&quot; name=&quot;XE_persistent_object__describing&quot;>&lt;/a>&lt;a&#xD;
id=&quot;Describe Persistence-Related Behavior&quot; name=&quot;Describe Persistence-Related Behavior&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    The whole goal of the object-oriented paradigm is to &lt;b>encapsulate&lt;/b> implementation details. Therefore, with respect&#xD;
    to persistence, we would like to have a persistent object look &lt;b>just like&lt;/b> a transient object. We should not have&#xD;
    to be aware that the object is persistent, or treat it any differently than we would any other object. At least that's&#xD;
    the goal.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In practice, there might be times when the application needs to control various aspects of persistence:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        when persistent objects are read and written&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        when persistent objects are deleted&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        how transactions are managed&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        how locking and concurrency control is achieved&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Writing Persistent Objects&quot; name=&quot;Writing Persistent Objects&quot;>Writing Persistent Objects&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    There are two cases to be concerned with here: the initial time the object is written to the persistent object store,&#xD;
    and subsequent times when the application wants to update the persistent object store with a change to the object.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In either case, the specific mechanism depends on the operations supported by the persistence framework. Generally, the&#xD;
    mechanism used is to send a message to the persistence framework to create the persistent object. Once an object is&#xD;
    persistent, the persistence framework is smart enough to detect subsequent changes to the persistent object and write&#xD;
    them to the persistent object store when necessary (usually when a transaction is committed).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    An example of a persistent object being created is shown below:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;230&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/vbos1.gif&quot; width=&quot;325&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot; align=&quot;center&quot;>&#xD;
    The object PersistenceMgr is an instance of VBOS, a persistence framework. The OrderCoordinator creates a persistent&#xD;
    Order by sending it as the argument to a 'createPersistentObject' message to the PersistenceMgr.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    It is &lt;b>generally&lt;/b> not necessary to explicitly model this unless it is important to know that the object is being&#xD;
    explicitly stored at a specific point in some sequence of events. If subsequent operations need to query the object,&#xD;
    the object must exist in the database, and therefore it is important to know that the object will exist there.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Reading Persistent Objects&quot; name=&quot;Reading Persistent Objects&quot;>Reading Persistent Objects&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Retrieval of objects from the persistent object store is necessary before the application can send messages to that&#xD;
    object. Recall that work in an object-oriented system is performed by sending messages to objects. But if the object&#xD;
    that you want to send a message to is in the database but not yet in memory, you have a problem: you cannot send a&#xD;
    message to something which does not yet exist!&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In short, you need to send a message to an object that knows how to query the database, retrieve the correct object,&#xD;
    and instantiate it. Then, and only then, can you send the original message you originally intended. The object that&#xD;
    instantiates a persistent object is sometimes called a &lt;i>factory&lt;/i> object. A &lt;b>factory&lt;/b> object is responsible&#xD;
    for creating instances of objects, including persistent objects. Given a query, the &lt;b>factory&lt;/b> could be designed to&#xD;
    return a set of one or more objects which match the query.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Generally objects are richly connected to one another through their associations, so it is usually only necessary to&#xD;
    retrieve the &lt;b>root&lt;/b> object in an object graph; the rest are essentially transparently 'pulled' out of the database&#xD;
    by their associations with the root object. (A good persistence mechanism is smart about this: it only retrieves&#xD;
    objects when they are needed; otherwise, we might end up trying to instantiate a large number of objects needlessly.&#xD;
    Retrieving objects before they are needed is one of the main performance problems caused by simplistic persistence&#xD;
    mechanisms.)&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The following example shows how object retrieval from the persistent object store can be modeled. In an actual sequence&#xD;
    diagram, the DBMS would not be shown, as this should be encapsulated in the &lt;b>factory&lt;/b> object.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;297&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/retriev.gif&quot; width=&quot;489&quot; />&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Deleting Persistent Objects&quot; name=&quot;Deleting Persistent Objects&quot;>Deleting Persistent Objects&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The problem with persistent objects is, well, they persist! Unlike transient objects which simply disappear when the&#xD;
    process that created them dies, persistent objects exist until they are explicitly deleted. So it's important to delete&#xD;
    the object when it's no longer being used.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Trouble is, this is hard to determine. Just because one application is done with an object does not mean that all&#xD;
    applications, present and future, are done. And because objects can and do have associations that even they don't know&#xD;
    about, it is not always easy to figure out if it is okay to delete an object.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In design, this can be represented semantically using &lt;b>state charts&lt;/b>: when the object reaches the &lt;b>end&lt;/b>&#xD;
    state, it can be said to be &lt;b>released&lt;/b>. Developers responsible for implementing persistent classes can then use&#xD;
    the state chart information to invoke the appropriate persistence mechanism behavior to release the object. The&#xD;
    responsibility of the Designer of the use-case realization is to invoke the appropriate operations to cause the object&#xD;
    to reach its &lt;b>end&lt;/b> state when it is appropriate for the object to be deleted.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If an object is richly connected to other objects, it might be difficult to determine whether the object can be&#xD;
    deleted. Since a &lt;b>factory&lt;/b> object knows about the structure of the object as well as the objects to which it is&#xD;
    connected, it is often useful to charge the factory object for a class with the responsibility of determining whether a&#xD;
    particular instance can be deleted. The persistence framework can also provide support for this capability.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Modeling Transactions&quot; name=&quot;Modeling Transactions&quot;>Modeling Transactions&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Transactions define a set of operation invocations which are &lt;b>atomic&lt;/b>; they are either all performed, or none of&#xD;
    them are performed. In the context of persistence, a transaction defines a set of changes to a set of objects which are&#xD;
    either all performed or none are performed. Transactions provide consistency, ensuring that sets of objects move from&#xD;
    one consistent state to another.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    There are several options for showing transactions in Use Case Realizations:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Textually&lt;/b>. Using scripts in the margin of the sequence diagram, transaction boundaries can be documented as&#xD;
        shown below. This method is simple, and allows any number of mechanisms to be used to implement the transaction.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;466&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/txn1.gif&quot; width=&quot;496&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Representing transaction boundaries using textual annotations.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Using Explicit Messages&lt;/b>. If the transaction management mechanism being used uses explicit messages to begin&#xD;
        and end transactions, these messages can be shown explicitly in the sequence diagram, as shown below:&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;575&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/txn2.gif&quot; width=&quot;558&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    A sequence diagram showing explicit messages to start and stop transactions.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Handling Error Conditions&quot; name=&quot;Handling Error Conditions&quot;>&lt;/a>Handling Error Conditions&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    If all operations specified in a transaction cannot be performed (usually because an error occurred), the transaction&#xD;
    is &lt;b>aborted&lt;/b>, and all changes made during the transaction are reversed. Anticipated error conditions often&#xD;
    represent exceptional flows of events in use cases. In other cases, error conditions occur because of some failure in&#xD;
    the system. Error conditions should be documented in interactions was well. Simple errors and exceptions can be shown&#xD;
    in the interaction where they occur; complex errors and exception may require their own interactions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Failure modes of specific objects can be shown on state charts. Conditional flow of control handling of these failure&#xD;
    modes can be shown in the interaction in which the error or exception occurs.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &lt;a id=&quot;Handling Concurrency Control&quot; name=&quot;Handling Concurrency Control&quot;>Handling Concurrency Control&lt;/a>&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Concurrency describes the control of access to critical system resources in the course of a transaction. In order to&#xD;
    keep the system in a consistent state, a transaction may require that it have exclusive access to certain key resources&#xD;
    in the system. The exclusivity may include the ability to read a set of objects, write a set of objects, or both read&#xD;
    and write a set of objects.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Let's look at a simple example of why we might need to restrict access to a set of objects. Let's say we a running a&#xD;
    simple order entry system. People call-in to place orders, and in turn we process the orders and ship the orders. We&#xD;
    can view the order as a kind of transaction.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To illustrate the need for concurrency control, let's say I call in to order a new pair of hiking boots. When the order&#xD;
    is entered into the system, it checks to see if the hiking boots I want, in the correct size, are in inventory. If they&#xD;
    are, we want to &lt;b>reserve&lt;/b> that pair, so that no one else can purchase them before the order can be shipped out.&#xD;
    Once the order is shipped, the boots are removed from inventory.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    During the period between when the order is placed and when it ships, the boots are in a special state&amp;amp;#151they are&#xD;
    in inventory, but they are &quot;committed&quot; to my order. If my order gets canceled for some reason (I change my mind, or my&#xD;
    credit card has expired), the boots get returned to inventory. Once the order is shipped, we will assume that our&#xD;
    little company does not want to keep a record that it once had the boots.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The goal of concurrency, like transactions, is to ensure that the system moves from one consistent state to another. In&#xD;
    addition, concurrency strives to ensure that a transaction has all the resources it needs to complete its work.&#xD;
    Concurrency control may be implemented in a number of different ways, including resource locking, semaphores, shared&#xD;
    memory latches, and private workspaces.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In an object-oriented system, it is difficult to tell from just the message patterns whether a particular message might&#xD;
    cause a state change on an object. Also, different implementations may obviate the need to restrict access to certain&#xD;
    types of resources; for example, some implementations provide each transaction with its own view of the state of the&#xD;
    system at the beginning of the transaction. In this case, other processes may change the state of and object without&#xD;
    affecting the 'view' of any other executing transactions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To avoid constraining the implementation, in design we simply want to indicate the resources to which the transaction&#xD;
    must have exclusive access. Using our earlier example, we want to indicate that we need exclusive access to the boots&#xD;
    that were ordered. A simple alternative is to annotate the description of the message being sent, indicating that the&#xD;
    application needs exclusive access to the object. The Implementer then can use this information to determine how best&#xD;
    to implement the concurrency requirement. An example sequence diagram showing annotation of which messages require&#xD;
    exclusive access is shown below. The assumption is that all locks are released when the transaction is completed.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;569&quot; alt=&quot;Diagram described in accompanying text.&quot; src=&quot;resources/locking.gif&quot; width=&quot;630&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    An example showing annotated access control in a sequence diagram.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The reason for not restricting access to all objects needed in a transaction is that often only a few objects should&#xD;
    have access restrictions; restricting access to all objects participating in a transaction wastes valuable resources&#xD;
    and could create, rather than prevent, performance bottlenecks.&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_S2CtANnnEdmO6L4XMImrsA" name=" Refine the Flow of Events Description" guid="_S2CtANnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Refine the Flow of Events Description&quot; name=&quot;Refine the Flow of Events Description&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    In the flow of events of the use-case realization you may need to add additional description to the sequence diagrams,&#xD;
    in cases where the flow of events is not fully clear from just examining the messages sent between participating&#xD;
    objects. Some examples of these cases include cases where timing annotations, notes on conditional behavior, or&#xD;
    clarification of operation behavior is needed to make it easier for external observers to read the diagrams.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The flow of events is initially outlined in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/tasks/use_case_analysis_A6990185.html&quot; guid=&quot;{28014615-A62F-452D-B821-30C7CAB0EC44}&quot;>Task: Use-Case&#xD;
    Analysis&lt;/a>. In this step you refine the flow of events as needed to clarify the sequence diagrams.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Often, the name of the operation is not sufficient to understand why the operation is being performed. Textual notes or&#xD;
    scripts in the margin of the diagram may be needed to clarify the sequence diagram. Textual notes and scripts may also&#xD;
    be needed to represent control flow such as decision steps, looping, and branching. In addition, textual tags may be&#xD;
    needed to correlate extension points in the use case with specific locations in sequence diagrams.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Previous examples within this task have illustrated a number of different ways of annotating sequence diagrams.&#xD;
&lt;/p>&lt;br />&#xD;
&lt;br /></sectionDescription>
  </sections>
  <sections xmi:id="_S2CtAdnnEdmO6L4XMImrsA" name=" Unify Design Classes and Subsystems" guid="_S2CtAdnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;XE_design_subsystem__unifying&quot; name=&quot;XE_design_subsystem__unifying&quot;>&lt;/a>&lt;a id=&quot;Unify Classes and Subsystems&quot;&#xD;
name=&quot;Unify Classes and Subsystems&quot;>&lt;/a>&#xD;
&lt;p>&#xD;
    As use cases are realized, you need to unify the identified design classes and subsystems to ensure homogeneity and&#xD;
    consistency in the &lt;a class=&quot;elementLink&quot; href=&quot;./../../core.base_rup/workproducts/rup_design_model_2830034D.html&quot;&#xD;
    guid=&quot;{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}&quot;>Design Model&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Points to consider:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Names of model elements should describe their function.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Avoid similar names and synonyms because they make it difficult to distinguish between model elements.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Merge model elements that define similar behavior, or that represent the same phenomenon.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Merge entity classes that represent the same concept or have the same attributes, even if their defined behavior is&#xD;
        different.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Use inheritance to abstract model elements, which tends to make the model more robust.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        When updating a model element, also update the corresponding flow of events description of the use-case&#xD;
        realizations.&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul></sectionDescription>
  </sections>
  <sections xmi:id="_S2MeANnnEdmO6L4XMImrsA" name=" Evaluate Your Results" guid="_S2MeANnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Evaluate Your Results&quot; name=&quot;Evaluate Your Results&quot;>&lt;/a> &#xD;
&lt;p>&#xD;
    You should check the design model at this stage to verify that your work is headed in the right direction. There is no&#xD;
    need to review the model in detail, but you should consider the &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/checklists/design_model_18BE347C.html&quot; guid=&quot;1.4639852935143625E-305&quot;>Design Model&lt;/a>&#xD;
    while you are working on it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    See especially &lt;a class=&quot;elementLink&quot; href=&quot;./../../core.base_rup/guidances/checklists/use-case_realization_444C8317.html&quot;&#xD;
    guid=&quot;9.828360528787822E-305&quot;>Use-Case Realization&lt;/a> in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/tasks/review_the_design_34CB80A9.html&quot; guid=&quot;{9574768B-7886-40C9-9938-A7E36E9B0739}&quot;>Task: Review the&#xD;
    Design&lt;/a>.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <purpose>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a>&lt;a id=&quot;XE_use_case__design&quot; name=&quot;XE_use_case__design&quot;>&lt;/a> &#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        To refine use-case realizations in terms of interactions&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To refine requirements on the operations of design classes&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        To refine requirements on the operations of design subsystems and/or their interfaces&#xD;
    &lt;/li>&#xD;
    &lt;li class=&quot;reactive&quot;>&#xD;
        To refine requirements on the operations of capsules&#xD;
    &lt;/li>&#xD;
&lt;/ul></purpose>
</org.eclipse.epf.uma:TaskDescription>
