<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:TaskDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_13kykNnmEdmO6L4XMImrsA" name="identify_design_elements,{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}" guid="_13kykNnmEdmO6L4XMImrsA" changeDate="2005-08-23T20:24:42.084-0700" version="7.1.0">
  <mainDescription>&lt;p>&#xD;
    The &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../core.base_rup/tasks/use_case_analysis_A6990185.html&quot;&#xD;
    guid=&quot;{28014615-A62F-452D-B821-30C7CAB0EC44}&quot;>Task: Use Case Analysis&lt;/a> results in &lt;b>analysis classes&lt;/b>, which&#xD;
    represent &lt;b>conceptual things which can perform behavior&lt;/b>. In design, &lt;b>analysis classes&lt;/b> evolve into a number&#xD;
    of different kinds of design elements:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        classes, to represent a set of rather fine-grained responsibilities;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        subsystems, to represent a set of coarse-grained responsibilities, perhaps composed of a further set of subsystems,&#xD;
        but ultimately a set of classes;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        active classes, which represent threads in the system;&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        interfaces, to represent abstract declarations of responsibilities provided by a class or subsystem.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In addition, in design we shall also identify:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        events, which are specifications of interesting occurrences in time and space that usually (if they are noteworthy)&#xD;
        require some response from the system; and&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        signals, to represent asynchronous mechanisms used to communicate certain types of events within the system.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    These finer distinctions enable us to examine different aspects of the design:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Events and the Signals that are used to communicate them, allow us to describe the asynchronous triggers of&#xD;
        behavior to which the system must respond.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Classes and Subsystems allow us to group related responsibilities into units which can be developed in relative&#xD;
        independence; classes fulfill an atomic set of related responsibilities, while subsystems are composite building&#xD;
        blocks which are in turn composed of classes or other subsystems. Subsystems are used to represent the work&#xD;
        products of a development team as a single, integral unit of functionality, and as such are used both as units of&#xD;
        control and configuration management as well as logical design elements.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Active classes are used to represent control threads in the system, allowing the modeling of concurrency. Active&#xD;
        classes are often used in composition with other classes that are usually, but not necessarily, passive: such a&#xD;
        composition can then be used - in the same way as a collaboration - to model complex behavior. &#xD;
        &lt;p class=&quot;reactive&quot;>&#xD;
            In real-time systems, capsules are used in place of active classes, offering stronger semantics to simplify the&#xD;
            design and increase the reliability of concurrent applications. Capsules share some aspects of both classes and&#xD;
            subsystems: they are in fact encapsulated collaborations of classes which together represent a thread of&#xD;
            control in the system. They differ from subsystems in the sense that a capsule is the responsibility of a&#xD;
            single designer, whereas a subsystem is the responsibility (typically) of a team of developers; a subsystem may&#xD;
            contain capsules, however.&amp;nbsp;&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Interfaces allow us to examine and capture the 'seams' of the system, defining in precise terms how the constituent&#xD;
        parts of the system will interoperate.&#xD;
    &lt;/li>&#xD;
    &lt;li class=&quot;reactive&quot;>&#xD;
        In real-time systems, we shall use Protocols to define precisely the messages that may be sent and received on a&#xD;
        port of a capsule.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    By separating concerns and handling each issue represented by these concepts separately, we simplify the design process&#xD;
    and clarify our solution.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If traceability is to be maintained between system models, it should be documented during this task.&amp;nbsp; For more&#xD;
    information on documenting the traceability between the Design Model and other system models, see &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/guidances/guidelines/design_model_A82D7B3E.html&quot;&#xD;
    guid=&quot;2.3158107674855575E-306&quot;>Guideline: Design Model&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    &amp;nbsp;UML 1.x Representation&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    According UML 1.5, a subsystem is, effectively, a special kind of package which has only interfaces as public elements.&#xD;
    The interfaces provide a layer of encapsulation, allowing the internal design of the subsystem to remain hidden from&#xD;
    other model elements. The concept subsystem is used to distinguish it from &quot;ordinary&quot; packages, which are semantic-free&#xD;
    containers of model elements; the subsystem represents a particular usage of packages with class-like (behavioral)&#xD;
    properties.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    In RUP, Capsules are represented using UML 1.5 notation. Much of this can be represented in UML 2.0 using the &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html&quot;&#xD;
    guid=&quot;1.1994826813129747E-304&quot;>Concept: Structured Class&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Refer to &lt;a class=&quot;elementLink&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html&quot;&#xD;
    guid=&quot;4.792914878943572E-306&quot;>Differences Between UML 1.x and UML 2.0&lt;/a> for more information.&#xD;
&lt;/p></mainDescription>
  <sections xmi:id="_T0B_QNnnEdmO6L4XMImrsA" name=" Identify Events and Signals " guid="_T0B_QNnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;XE_events__identification_of&quot; name=&quot;XE_events__identification_of&quot;>&lt;/a>&lt;a id=&quot;Identify and Specify Events&quot;&#xD;
name=&quot;Identify and Specify Events&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To identify the external and internal events and signals to which the system must respond.&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&#xD;
    &lt;p>&#xD;
        Events are external and internal occurrences which cause some action within the system. Events and their&#xD;
        characteristics can help drive the identification of key design elements, such as active classes.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        An initial list of external events can be derived from the Use-Case Model, from the actors' interactions with use&#xD;
        cases. Internal events may be derived from text in the use case flows, or may be identified as the design evolves.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Important characteristics of events are:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            internal vs. external - Is the event external or internal?&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            priority - Does this event need to cause the suspension of other processing in order to be handled?&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            frequency - How often does the event occur?&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            frequency distribution - Does the event occur at regular intervals, or are there spikes?&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            response requirements - How the quickly the system must respond to the event (may need to distinguish between&#xD;
            average and worst case).&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            kind - Is this a Call Event, Time Event, Signal Event, or Change Event (see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
            href=&quot;./../../core.base_rup/guidances/concepts/events_and_signals_734567DC.html&quot; guid=&quot;1.800598287887014E-305&quot;>Concept:&#xD;
            Events and Signals&lt;/a> for definitions)?&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        Events' characteristics should be captured as needed to drive the identification of the design elements that handle&#xD;
        them. Capturing event characteristics tends to be most important in reactive (event-driven) systems, but it can be&#xD;
        useful in other systems, such as those with concurrency and/or asynchronous messaging.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Asynchronous communication events can be modeled as Signals to express the data that they carry, or to express&#xD;
        relationships between signals, such as generalization. In some systems, in particular reactive systems, it is&#xD;
        important to relate signals received from external devices to specific mechanisms, such as interrupts or specific&#xD;
        polling messages.&lt;br />&#xD;
    &lt;/p>&#xD;
&lt;/div></sectionDescription>
  </sections>
  <sections xmi:id="_T0LwQNnnEdmO6L4XMImrsA" name=" Identify Classes, Active Classes and Subsystems " guid="_T0LwQNnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;Identify Classes, Active Classes and Subsystems&quot; name=&quot;Identify Classes, Active Classes and Subsystems&quot;>&lt;/a>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; style=&quot;border: 1px solid rgb(128,128,128)&quot;&#xD;
    bordercolorlight=&quot;#808080&quot; bordercolordark=&quot;#808080&quot;>&#xD;
        &lt;tr>&#xD;
            &lt;td width=&quot;5%&quot;>&#xD;
                &lt;b>Purpose&lt;/b>&#xD;
            &lt;/td>&#xD;
            &lt;td width=&quot;95%&quot;>&#xD;
                To refine the &lt;b>analysis classes&lt;/b> into appropriate design model elements&amp;nbsp;&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    &lt;b>Identify Classes.&lt;/b> When the analysis class is simple and already represent a single logical abstraction, it can&#xD;
    be directly mapped, 1:1, to a &lt;b>design class&lt;/b>. Typically, entity classes survive relatively intact into Design.&#xD;
    Since entity classes are typically also persistent, determine whether the design class should be persistent and note it&#xD;
    accordingly in the class description.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    When identifying classes, they should be grouped into &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_design_package_8376BC8E.html&quot;&#xD;
    guid=&quot;{80CC5437-F481-487B-A69B-957D9D236D8D}&quot;>Artifact: Design Package&lt;/a>s, for organizational and configuration&#xD;
    management purposes. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/guidelines/design_package_8CF100B8.html&quot; guid=&quot;3.3691722315666536E-305&quot;>Guideline: Design&#xD;
    Package&lt;/a> for more information on how to make packaging decisions.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Identify Active Classes.&lt;/b> Consider the concurrency requirements of the system in the context of the analysis&#xD;
    objects identified: is there a need for the system to respond to externally generated events, and if so, which analysis&#xD;
    classes are 'active' when the events occur? External events in the Use-Case Model are represented by stimuli coming&#xD;
    from actors, interacting with a use case. Look at the corresponding Use-Case Realizations to see which objects interact&#xD;
    when an event occurs. Start by grouping the objects together into autonomous sets of collaborating objects - these&#xD;
    groupings represent an initial cut at a group that may form a composite active class.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    If the events have important attributes that need to be captured, consider modeling them as classes, stereotyped&#xD;
    &amp;lt;&amp;lt;signal&amp;gt;&amp;gt;. In real-time systems, these identified sets of objects should be grouped into capsules, which&#xD;
    have strong encapsulation semantics.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The instances of active classes represent independent 'logical' threads of execution. These 'logical' threads of&#xD;
    execution are not to be confused with or mapped literally to threads of execution in the operating system (though at&#xD;
    some point we will map them to operating system threads of execution). Instead, they represent independent conceptual&#xD;
    threads of execution in the solution space. Our goal in identifying them at this point in design is to be able to&#xD;
    partition the solution into independent units based on natural 'concurrency seams' in the system. Dividing the work in&#xD;
    this way makes the problems of dealing with concurrency conceptually simpler, since independent threads of execution&#xD;
    can be dealt with separately except to the extent that they share underlying passive classes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In general, an active class should be considered whenever there exist concurrency and concurrency conflicts in the&#xD;
    problem domain. An active class should be used to represent some external concurrent object or concurrent activity&#xD;
    within the computer. This gives us the ability to monitor and control concurrent activities.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another natural choice is to use active classes as &lt;b>internal representatives of external physical devices&lt;/b> that&#xD;
    are connected to a computer since those physical entities are inherently concurrent. These &quot;device driver&quot; classes&#xD;
    serve not only to monitor and control the corresponding physical devices but they also isolate the rest of the system&#xD;
    from the specifics of the devices. This means that the rest of the system may not be affected even if the technology&#xD;
    behind the devices evolves.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Another common place for using active classes is to represent logical concurrent activities. A logical activity&#xD;
    represents a conceptual concurrent &quot;object&quot;, such as, for example, a financial transaction or a telephone call. Despite&#xD;
    the fact that these are not directly manifested as physical entities (although they take place in the physical world),&#xD;
    there are often reasons to treat them as such. For instance, we may need to temporarily hold back a particular&#xD;
    financial transaction to avoid a concurrency conflict or we may need to abort it due to failures within the system.&#xD;
    Since these conceptual objects need to be manipulated as a unit, it is convenient to represent them as objects with&#xD;
    interfaces of their own that provide the appropriate functional capabilities.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A particular example of this type of conceptual object is an &lt;b>active object controller&lt;/b>. Its purpose is to&#xD;
    continuously manage one or more other active objects. This normally involves bringing each object into the desired&#xD;
    operational state, maintaining it in that state in the face of various disruptions such as partial failures, and&#xD;
    synchronizing its operation with the operation of other objects. These active object controllers often evolve from&#xD;
    Control objects identified during &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/tasks/use_case_analysis_A6990185.html&quot; guid=&quot;{28014615-A62F-452D-B821-30C7CAB0EC44}&quot;>Task: Use-Case&#xD;
    Analysis&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Because of their capacity to simply and elegantly resolve concurrency conflicts, active classes are also useful as&#xD;
    &lt;b>guardians of shared resources&lt;/b>. In this case, one or more resources that are required by multiple concurrent&#xD;
    activities are encapsulated within an active class. By virtue of their built-in mutual exclusion semantics, such&#xD;
    guardians automatically protect these resources against concurrency conflicts.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>For real-time systems, capsules should be used in place of active classes: wherever you identified the need for an&#xD;
    active class according to the heuristics described above, a capsule should be substituted.&lt;/b>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Identify Subsystems.&lt;/b> When the analysis class is complex, such that it appears to embody behaviors that cannot be&#xD;
    the responsibility of a single class acting alone, the analysis class should be mapped to a design subsystem. The&#xD;
    design subsystem is used to encapsulate these collaborations in such a way that clients of the subsystem can be&#xD;
    completely unaware of the internal design of the subsystem, even as they use the services provided by the subsystem.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A subsystem is modeled as a UML component, which has only interfaces as public elements. The interfaces provide a layer&#xD;
    of encapsulation, allowing the internal design of the subsystem to remain hidden from other model elements. The concept&#xD;
    subsystem is used to distinguish it from packages, which are semantic-free containers of model elements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The decision to create a subsystem from a set of collaborating analysis classes is based largely on whether the&#xD;
    collaboration can be or will be developed independently by a separate design team. If the collaborations can be&#xD;
    completely contained within a package along with the collaborating classes, a subsystem can provide a stronger form of&#xD;
    encapsulation than that provided by a simple package. The contents and collaborations within a subsystem are completely&#xD;
    isolated behind one or more interfaces, so that the client of the subsystem is only dependent upon the interface. The&#xD;
    designer of the subsystem is then completely isolated from external dependencies; the designer (or design team) is&#xD;
    required to specify how the interface is realized, but they are completely free to change the internal subsystem design&#xD;
    without affecting external dependencies. In large systems with largely independent teams, this degree of de-coupling&#xD;
    combined with the architectural enforcement provided by formal interfaces is a strong argument for the choice of&#xD;
    subsystems over simple packages. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html&quot; guid=&quot;1.2314266786534317E-305&quot;>Guideline: Design&#xD;
    Subsystem&lt;/a> for more information about the factors which affect the choice to use subsystems as design elements.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_T0LwQdnnEdmO6L4XMImrsA" name=" Identify Subsystem Interfaces " guid="_T0LwQdnnEdmO6L4XMImrsA">
    <sectionDescription>&lt;a id=&quot;XE_interfaces__identifying_a_subsystem's&quot; name=&quot;XE_interfaces__identifying_a_subsystem's&quot;>&lt;/a>&lt;a&#xD;
id=&quot;XE_design_subsystem__identifying_interfaces&quot; name=&quot;XE_design_subsystem__identifying_interfaces&quot;>&lt;/a>&lt;a&#xD;
id=&quot;Identify Interfaces&quot; name=&quot;Identify Interfaces&quot;>&lt;/a> &#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;100%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;5%&quot;>&#xD;
                    &lt;b>Purpose&lt;/b>&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;95%&quot;>&#xD;
                    To identify the design elements which formalize the seams in the system.&amp;nbsp;&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Interfaces define a set of operations which are realized by some classifier. In the Design Model, interfaces are&#xD;
    principally used to define the interfaces for subsystems. This is not to say that they cannot be used for classes as&#xD;
    well, but for a single class it is usually sufficient to define public operations on the class which, in effect, define&#xD;
    its 'interface'. Interfaces are important for subsystems because they allow the separation of the declaration of&#xD;
    behavior (the interface) from the realization of behavior (the specific classes within the subsystem which realize the&#xD;
    interface). This de-coupling provides us with a way to increase the independence of development teams working on&#xD;
    different parts of the system, while retaining precise definitions of the 'contracts' between these different parts.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>For each subsystem, identify a set of candidate interfaces&lt;/b>. Using the grouped collaborations identified in the&#xD;
    previous step, identify the responsibility which is 'activated' when the collaboration is initiated. This&#xD;
    responsibility is then refined by determining what information must be provided by the 'client' and what information is&#xD;
    returned when the collaboration is complete; these sets of information become the prototype input and output parameters&#xD;
    and return value for an operation which the subsystem will realize. Define a name for this operation, using the naming&#xD;
    conventions defined in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot;&#xD;
    guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>Artifact: Project-Specific Guidelines&lt;/a>. Repeat this until all&#xD;
    operations which will be realized by the subsystem have been defined.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Next, group operations together according to their related responsibilities. Smaller groups are preferable to larger&#xD;
    groups, since it is more likely that a cohesive set of common responsibilities will exist if there are fewer operations&#xD;
    in the group. Keep an eye toward reuse as well - look for similarities that may make it easier to identify related&#xD;
    reusable functionality. At the same time, though, don't spend a great deal of time trying to find the ideal grouping of&#xD;
    responsibilities; remember, this is just a first-cut grouping and refinement will proceed iteratively throughout the&#xD;
    elaboration phase.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Look for similarities between interfaces.&lt;/b> From the candidate set of interfaces, look for similar names, similar&#xD;
    responsibilities, and similar operations. Where the same operations exist in several interfaces, re-factor the&#xD;
    interfaces, extracting the common operations into a new interface. Be sure to look at existing interfaces as well,&#xD;
    re-using them where possible. The goal is to maintain the cohesiveness of the interfaces while removing redundant&#xD;
    operations between interfaces. This will make the interfaces easier to understand and evolve over time.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Define interface dependencies.&lt;/b> The parameters and return value of each interface operation each have a&#xD;
    particular type: they must realize a particular interface, or they must be instances of a simple data type. In cases&#xD;
    where the parameters are objects that realize a particular interface, define dependency relationships between the&#xD;
    interface and the interfaces on which it depends. Defining the dependencies between interfaces provides useful coupling&#xD;
    information to the software architect, since interface dependencies define the primary dependencies between elements in&#xD;
    the design model.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Map the interfaces to subsystems.&lt;/b> Once interfaces have been identified, create &lt;b>realization&lt;/b> associations&#xD;
    between the subsystem and the interfaces it realizes. A realization from the subsystem to an interface indicates that&#xD;
    there are one or more elements within the subsystem that realize the operations of the interface. Later, when the&#xD;
    subsystem is designed, these subsystem-interface realizations will be refined, with the subsystem designer specifying&#xD;
    which specific elements within the subsystem realize the operations of the interface. These refined realizations are&#xD;
    visible only to the subsystem designer; from the perspective of the subsystem client, only the subsystem-interface&#xD;
    realization is visible.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Define the behavior specified by the interfaces.&lt;/b> Interfaces often define an implicit state machine for the&#xD;
    elements that realize the interface. If the operations on the interface must be invoked in a particular order (e.g. the&#xD;
    database connection must be opened before it can be used), a state machine that illustrates the publicly visible (or&#xD;
    inferred) states that any design element that realizes the interface must support should be defined. This state machine&#xD;
    will aid the user of the interface to better understand the interface, and will aid the designer of elements which&#xD;
    realize the interface to provide the correct behavior for their element.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Package the interfaces.&lt;/b> Interfaces are owned by the software architect; changes to interfaces are always&#xD;
    architecturally significant. To manage this, the interfaces should be grouped into one or more packages owned by the&#xD;
    software architect. If each interface is realized by a single subsystem, the interfaces can be placed in the same&#xD;
    package with the subsystem. If the interfaces are realized by more than one subsystem, they should be placed within a&#xD;
    separate package owned by the software architect. This allows the interfaces to be managed and controlled independently&#xD;
    of the subsystems themselves.&#xD;
&lt;/p>&#xD;
&lt;h3 class=&quot;reactive&quot;>&#xD;
    &lt;a id=&quot;XE_protocol__identification_of&quot; name=&quot;XE_protocol__identification_of&quot;>&lt;/a>&lt;a id=&quot;Identify Capsule Protocols&quot;&#xD;
    name=&quot;Identify Capsule Protocols&quot;>Identify Capsule Protocols&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table&#xD;
    style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;&#xD;
     cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;100%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;5%&quot;>&#xD;
                    &lt;p class=&quot;reactive&quot;>&#xD;
                        &lt;b>Purpose&lt;/b>&#xD;
                    &lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td width=&quot;95%&quot;>&#xD;
                    To identify the design elements which formalize the seams in the system (RT design only).&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Protocols are similar to interfaces in event-driven systems: they identify the 'contract' between capsules by defining&#xD;
    a matched set of signals which are used to communicate between independent threads of control. While interfaces are&#xD;
    primarily used to define synchronous messaging using a function call model of invocation, protocols are primarily used&#xD;
    to define asynchronous communication using signal-based messaging. Protocols allow the separation of the declaration of&#xD;
    behavior (the set of signals) from the realization of behavior (the elements within the subsystem which realize the&#xD;
    interface). This de-coupling provides us with a way to increase the independence of development teams working on&#xD;
    different parts of the system, while retaining precise definitions of the 'contracts' between these different parts.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    &lt;b>For each capsule, identify a set of in and out signals&lt;/b>. Using the grouped collaborations identified in earlier&#xD;
    steps, identify the responsibility which is 'activated' when the collaboration is initiated. This responsibility is&#xD;
    then refined by determining what information must be provided by the 'client' and what information is returned when the&#xD;
    collaboration is complete; these sets of information become the prototype input parameters for a signal which the&#xD;
    capsule will realize through one of its ports. Define a name for this signal, using the naming conventions defined in&#xD;
    the &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html&quot;&#xD;
    guid=&quot;{E5501201-7EE6-4243-AE91-73880FF76FC1}&quot;>Artifact: Project-Specific Guidelines&lt;/a>. Repeat this until all signals&#xD;
    which will be realized by the capsule have been defined.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    Next, group signals together according to their related responsibilities. Smaller groups are preferable to larger&#xD;
    groups, since it is more likely that a cohesive set of common responsibilities will exist if there are fewer signals in&#xD;
    the group. Keep an eye toward reuse as well - look for similarities that may make it easier to identify related&#xD;
    reusable functionality. At the same time, though, don't spend a great deal of time trying to find the ideal grouping of&#xD;
    responsibilities; remember, this is just a first-cut grouping and refinement will proceed iteratively throughout the&#xD;
    elaboration phase. Give the protocol a meaningful name, one that describes the role the protocol plays in capsule&#xD;
    collaborations.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    &lt;b>Look for similarities between protocols.&lt;/b> From the candidate set of protocols, look for similar names, similar&#xD;
    responsibilities, and similar signals. Where the same signals exist in several protocols, re-factor the protocols,&#xD;
    extracting the common signals into a new interface. Be sure to look at existing protocols as well, re-using them where&#xD;
    possible. The goal is to maintain the cohesiveness of the protocols while removing redundant signals between protocols.&#xD;
    This will make the protocols easier to understand and evolve over time.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    &lt;b>Map the protocols to capsules.&lt;/b> Once protocols have been identified, create &lt;b>ports&lt;/b> on the capsules which&#xD;
    realize the protocols. The ports of the capsule define its 'interfaces', the behavior that can be requested from the&#xD;
    capsule. Later, when the capsule is designed, the behavior specified by the ports will be described by the state&#xD;
    machine for the capsule.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    &lt;b>Define the behavior specified by the protocols.&lt;/b> Protocols often define an implicit state machine for the&#xD;
    elements that realize the interface. If the input signals on the interface must be received in a particular order (e.g.&#xD;
    a 'system-ready' signal must be received before a particular error signal can be received), a state machine that&#xD;
    illustrates the publicly visible (or inferred) states that any design element that realizes the protocol must support&#xD;
    should be defined. This state machine will aid the user of the capsules which realize the protocol to better understand&#xD;
    their behavior, and will aid the designer of capsules to provide the correct behavior for their element.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;reactive&quot;>&#xD;
    &lt;b>Package the protocols.&lt;/b> Protocols are owned by the software architect; changes to protocols are always&#xD;
    architecturally significant. To manage this, the protocols should be grouped into one or more packages owned by the&#xD;
    software architect. This allows the protocols to be managed and controlled independently of the capsules which realize&#xD;
    the protocols.&#xD;
&lt;/p>&lt;br /></sectionDescription>
  </sections>
  <purpose>&lt;a id=&quot;Top&quot; name=&quot;Top&quot;>&lt;/a> &#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a id=&quot;XE_class__refining_analysis_classes&quot; name=&quot;XE_class__refining_analysis_classes&quot;>&lt;/a>To analyze interactions&#xD;
        of analysis classes to identify design model elements&#xD;
    &lt;/li>&#xD;
&lt;/ul></purpose>
</org.eclipse.epf.uma:TaskDescription>
