<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_q6CSgPS3EdmIX5Pw7v8pRw" name="state_management_for_services,4.2228409903513537E-306" guid="_q6CSgPS3EdmIX5Pw7v8pRw" changeDate="2006-08-22T20:55:37.616-0700" version="7.1.0">
  <mainDescription>&lt;a id=&quot;XE_state_management_for_services__guidelines_for&quot; name=&quot;XE_state_management_for_services__guidelines_for&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The notion of stateful and stateless components is particularly important in the development of distributed&#xD;
    applications and systems, although it has only recently tended to become part of the common vocabulary. Essentially,&#xD;
    the notion is that if two components or services are communicating and there is some state managed by the server&#xD;
    component for the duration of the conversation with the client, it is possible for a crash in the server component (or&#xD;
    network failure) to mean that the client is unable to complete the conversation and must start over. Also, it makes the&#xD;
    redirecting of client requests to one of a set of components harder unless the set of components share some common&#xD;
    store for the state of the conversation. This has become a well known issue in the development of Web applications&#xD;
    where its state is carefully managed so as to be avoided where possible and managed either by the client, by the&#xD;
    conversation itself (passing the state in each message), or in carefully designed stateful server-side components. For&#xD;
    example, the common example for stateful Web interaction is the shopping cart. Users will expect that the shopping cart&#xD;
    persists while they briefly walk away from the computer, but how is this accomplished with 100,000 concurrent users?&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Now, this is not to say that stateful components are inherently bad, they just represent a possible area of performance&#xD;
    and resilience failure unless carefully managed and developed to more rigorous standards. In fact, all business&#xD;
    applications contain services which by their very nature manage or represent entities that are inherently stateful or&#xD;
    contain services which must be accessed in certain logical sequences. In fact the J2EE architecture defines separate&#xD;
    Stateless and Stateful Session Beans to explicitly denote these issues and defines certain restrictions on stateful&#xD;
    components. This brings us to a simple classification for stateful services, the reasons why we cannot avoid them in&#xD;
    the first place. A service may have to be stateful for one of the following reasons:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        &lt;b>The Service Holds State on behalf of the Client&lt;/b>; this is the shopping-cart example. Somehow, some data has&#xD;
        to be persisted between calls between client and the service, this data is part of the conversation, and so,&#xD;
        without care, it can bind a client to a given server resource.&#xD;
    &lt;/p>&lt;b>The Service Manages a Stateful Resource&lt;/b>; in this case the service tends to manage a set of resources or&#xD;
    entities, each of which has state. For example a customer order has state, a network switch has state, and so on.&#xD;
    Therefore, the interface for a service that manages that object by closing or deferring an order or rebooting a switch&#xD;
    is changing the state of a particular entity. &#xD;
    &lt;p>&#xD;
        &lt;b>The Service Has a Stateful Protocol&lt;/b>; in this case the service has some logical ordering to the operations it&#xD;
        provides. For example it has login(), dostuff() and logoff() operations, which we can deduce means that you cannot&#xD;
        call the dostuff() or logoff() operation unless the login() operation is called.&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Another form of state which is found in many component architectures, but is not applicable in the services world, is&#xD;
    the notion of transactional state. It is possible in a component world to denote that a get() and update() method on a&#xD;
    component may be called by a client within the scope of a transaction created and maintained by the client. The&#xD;
    update() method is assumed to change some underlying transactional store. This almost always requires the intervention&#xD;
    of the middleware platform to coordinate the transactions and ensure that methods requiring transactions are called by&#xD;
    a client with an open transaction. For services, it is not considered appropriate or desirable to follow a model where&#xD;
    transactions in the classic two-phase commit sense are held open over a number of service invocations. Now, standards&#xD;
    are being developed for transactions across service invocations, but they follow a fundamentally different paradigm&#xD;
    (compensation) and are supported differently by middleware platforms.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The most obvious technique, which was hinted at above, for the successful development of stateful services is to&#xD;
    externalize service state, thus making it not only explicit that the service has state, but that this state can be&#xD;
    identified as part of the service specification. This is discussed for the two classes of stateful service below.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As most software services will be developed on top of an existing middleware platform such as J2EE or Microsoft .NET,&#xD;
    there are implementation techniques described within those platform architectures to help with state management.&#xD;
    Therefore, this guideline focuses on design techniques for certain classes of stateful services. It is also worth&#xD;
    noting that this is by no means a new area of concern. In mainframe development, the development of conversational and&#xD;
    non-conversational transactions in CICS (IBM Customer Information Control System) with green screen (actually 3270&#xD;
    terminal) clients have been known and described by developers, designers, and architects for many years.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Stateful_Conversation&quot; name=&quot;Stateful_Conversation&quot;>Persistent Conversation State&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    This is a case where the easiest advise is to avoid the situation in the first place. Wherever possible, if a design&#xD;
    calls for the management of state during a conversation between a service and its consumers, it would be best to try to&#xD;
    decide if another approach can be taken. If not, externalize this state by passing all of the required state data&#xD;
    between service and consumer with each message making up the entire conversation. This approach may mean that the size&#xD;
    of the messages are significantly increased, but the service itself is now entirely stateless. Another approach is to&#xD;
    carry a conversation identifier within each message and persist all conversation state into a permanent store such as a&#xD;
    database. While this has significant performance consequences on the server side, it may be countered against the&#xD;
    network and client performance saved with the smaller messages.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    One of the primary purposes of making these services stateless is to be able to provide a set of identical services&#xD;
    that can service any request using load-balancing techniques to distribute clients. This load balancing is possible if&#xD;
    all state is completely externalized or persisted in a common store.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Stateful_Resources&quot; name=&quot;Stateful_Resources&quot;>Managing Stateful Resources&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    In this case, we look at the management of resources themselves that have explicit state. In fact, that state is an&#xD;
    important aspect of the resource itself. It may be that we can describe the state of the resource, the customer order&#xD;
    or network switch mentioned above using a state machine, describing not only the valid states but also the manner in&#xD;
    which the operations provided by the service affect the state of the underlying resource(s).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    However we accomplish this description, it is important to note that this state is an intrinsic part of the resource.&#xD;
    However, it may not be explicitly expressed in the information model representing it. It is also important to note that&#xD;
    where we are managing any set of entities, we have to be able to identify any individual resource that we are acting&#xD;
    upon whether or not they again have an explicit identifier.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note that where a service represents the access to, or query of the state of a physical entity such as a network switch&#xD;
    or a process-control element, it is not possible to consider externalizing the state of the entity. The state of a&#xD;
    valve is only known by querying the valve. Although we can construct and reply with a message describing the current&#xD;
    state of the valve, this is not a permanent situation. The state of the valve can change during transmission or&#xD;
    processing of this message.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In the Web services area, there is a set of emerging standards known as the Web Services Resource Framework (WSRF)&#xD;
    which discusses patterns of stateful services and approaches to the encoding of state, particularly in the case of&#xD;
    services representing the management of stateful resources. For more information, see the &lt;a&#xD;
    href=&quot;http://www.ibm.com/developerworks/library/ws-resource/&quot;>&lt;i>IBM WS-ResourceFramework site&lt;/i>&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Stateful_Specifications&quot; name=&quot;Stateful_Specifications&quot;>Stateful Service Specifications&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The example mentioned above involves a service that has some logical sequencing to the operations it provides. Many&#xD;
    services will provide interfaces of this form. In some cases, this relates back to stateful resources except that in&#xD;
    that case, the ordering of the operations is based on the state of the managed resource. In this case, the ordering is&#xD;
    based on the conversation itself. The following example demonstrates a service specification that has some associated&#xD;
    protocol, first the structural specification and then a state machine is shown that describes the behavioral&#xD;
    specification.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;121&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_state-01.gif&quot; width=&quot;119&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The Purchase Order can be in one of the states &lt;i>{Open, Canceled, Fulfilled, Closed}&lt;/i> and changes state based on&#xD;
    the operations provided on the specification above. We also denote that in the case of the self transition on the state&#xD;
    Open, we execute the OrderChanged operation sending notifications of the change.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;275&quot; alt=&quot;Diagram is described in the textual content.&quot; src=&quot;resources/soa_svce_state-02.gif&quot; width=&quot;365&quot;&#xD;
    border=&quot;0&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In many cases where services are developed all within a single business and technical scope, detailed behavioral&#xD;
    specifications may not be developed or will be described less formally in text. Where services are exposed outside of&#xD;
    such a scope, for example, exposed between partitions, they represent a logical specification for interaction between&#xD;
    partitions and should be developed in far more detail. Also, detailed specifications allow for more efficient and&#xD;
    effective reuse by consumers when services are expected to be reused frequently.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
