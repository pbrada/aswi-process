<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:TaskDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="-0amduQpzI5BvZ2bwOuGVcQ" name=",_m8lcIDIyEduePY7oPsXsLA" guid="-0amduQpzI5BvZ2bwOuGVcQ" changeDate="2006-11-01T08:11:20.982-0800" version="1.0.0">
  <mainDescription>&lt;p>&#xD;
    The goal of this task is to allow architects to identify high-level security patterns appropriate to attach to&#xD;
    architectural elements in response to security requirements and policies. These patterns are then refined with detailed&#xD;
    patterns appropriate to particular technology and platform choices by down-stream design and implementation tasks.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    For more information on security patterns, see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../soa.rup_soma/guidances/concepts/sec_security_patterns_C10334C3.html&quot;&#xD;
    guid=&quot;_zJPhoDx3EduNwuGvuWPNZA&quot;>Concept: Security Patterns&lt;/a>.&#xD;
&lt;/p></mainDescription>
  <sections xmi:id="_yiZBoDIyEduePY7oPsXsLA" name="Identify Security Requirements" guid="_yiZBoDIyEduePY7oPsXsLA">
    <sectionDescription>&lt;p>&#xD;
    During this step the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../soa.rup_soma/roles/sec_security_architect_277ED003.html&quot; guid=&quot;_zseEkDIxEduePY7oPsXsLA&quot;>Role: Security&#xD;
    Architect&lt;/a>&amp;nbsp;is responsible for the capture of the high-level security requirements for a project and the&#xD;
    key&amp;nbsp;architectural elements of that project. These requirements are captured in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
    guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Artifact: Software Architecture Document&lt;/a>&amp;nbsp;and &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/workproducts/rup_supplementary_specification_F5ACAA22.html&quot;&#xD;
    guid=&quot;{B16C2941-791C-44E6-B353-354109B5C9DE}&quot;>Artifact: Supplementary Specifications&lt;/a> and where these requirements&#xD;
    significantly constrain the architecture of the solution then they should also be included in the &lt;a&#xD;
    class=&quot;elementLinkWithType&quot; href=&quot;./../../core.base_rup/workproducts/rup_reference_architecture_13D031C0.html&quot;&#xD;
    guid=&quot;{855CE09A-D297-4373-BEEA-D38B8AB348DA}&quot;>Artifact: Reference Architecture&lt;/a>. The role of the security architect&#xD;
    is to elicit these complex requirements from the stakeholders in the project and capture them in easy to understand&#xD;
    statements (intents).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The reason for the emphasis on intent at this stage is that in many cases when asked about security in a requirements&#xD;
    gathering session (see &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/guidances/guidelines/requirements_workshop_EEF2B469.html&quot; guid=&quot;4.234130639739827E-305&quot;>Guideline:&#xD;
    Requirements Workshop&lt;/a>) most stakeholders will respond that &quot;&lt;em>of course, everything must be secure&lt;/em>&quot;, well&#xD;
    does that mean that everything is encrypted, audited, and so on to which the reply is &quot;&lt;em>oh yes, please&lt;/em>&quot;. At&#xD;
    this point the security architect explains the implications of such a decision, the cost, the complexity, and the group&#xD;
    starts to have a meaningful discussion about which patterns are relevant to which elements in the architecture. It is&#xD;
    these patterns that express the intent of the system with regard to security, whereas the design level patterns express&#xD;
    the mechanisms for fulfilling the intent and finally implementation patterns express the technology used to fulfill the&#xD;
    intent.&#xD;
&lt;/p></sectionDescription>
  </sections>
  <sections xmi:id="_fQihEE67EduTfJnFpamAUg" name="Identify Trust Boundaries" guid="_fQihEE67EduTfJnFpamAUg">
    <sectionDescription>&lt;p>&#xD;
    Trust is a key aspect in any security solution. The need for security is based on the premise that two parties share&#xD;
    some level of trust and that level can be on a scale from &quot;completely trusted&quot; (therefore no need for security) or&#xD;
    &quot;completely untrusted&quot; (where paranoia rules).&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        &lt;b>No trust ... aka blind trust&lt;/b>: The provider may be providing a public service and has no need to trust the&#xD;
        invoking system. The invoking system may send an identity with no proof and expect the provider to assume the&#xD;
        identity when processing the request. There may be no measures taken to prevent impersonation attacks.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Network configuration based trust&lt;/b>: There is no software configuration that provides trust. The network is&#xD;
        configured, possibly through division into firewalled subnets, in such a way to restrict the number of machines&#xD;
        that could transmit a message to the provider. The degenerative case would see only the intended invoking system&#xD;
        and provider system on the subnet. Sometimes VPN's are used to restrict the potential invoking systems.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Infrastructure based trust&lt;/b>: The infrastructure (e.g. transport protocol ... possibly MA SSL, or SSL + BA) is&#xD;
        configured to identify the invoking system in order to validate that it's a trusted system. There is nothing in the&#xD;
        web services (SOAP) message other than the invoker identity that the provider should assume when processing the&#xD;
        request.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Token based trust&lt;/b>: Point to point token trust - There is a token in the message that asserts an invoker&#xD;
        identity and which was provably created by a trusted invoking system (e.g. SAML, LTPA). Third party token trust -&#xD;
        There is a token in the message that asserts an invoker identity and which was provably created by a trusted third&#xD;
        party system KDC/STS (e.g. SAML, Kerberos).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Token context based trust&lt;/b>: Signature that covers the token and message -&amp;nbsp;There is a signature in the&#xD;
        message created by a trusted invoking system that covers the message and the token asserting the invoker identity&#xD;
        and which authenticates the invoking system. Two tokens in the message - There is a token in the message that&#xD;
        authenticates the invoking system as a trusted system and another token that identifies the invoker. There needs to&#xD;
        be some mechanism to bind the two tokens together and to the message, such as a signature.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        The extreme end of &quot;trust&quot; is &lt;b>authentication&lt;/b>. Any token that provides proof removes the need for an extra&#xD;
        mechanism whose purpose it to establish trust.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h4>&#xD;
    Trust Zones&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    In large organizations it is often efficient to subdivide the enterprise into administrative regions and establish&#xD;
    different trust zones. Between different zones there are various subtypes of trust relationships that can be&#xD;
    established. These are examples of some of the ways two parties can establish a trust relationship when only one of the&#xD;
    parties has a relationship with the end user.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Direct Trust - Token Exchange&lt;/b>: Trust Domain 1 authenticates the end user and Trust Domain 2 requires an&#xD;
        identity or identifier (identity propagation). In some cases ( i.e. only personalization is required)&#xD;
        authentication may not be needed.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Direct Trust - Token Validation&lt;/b>: Trust Domain 1 may create a new assertion (an identity assertion) offering&#xD;
        its own proof that it has authenticated the identified user. Trust domain 2, evaluates that this assertion came&#xD;
        from someone it trusts (Trust Domain 1) and uses it in place of authenticating the user itself&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Token Services and ISPs&lt;/b>: Sometimes trust relationships are established between multiple parties and the&#xD;
        authentication of the user is separated out into an independent service (identity service provider). These identity&#xD;
        service providers have varying degrees of functionality. Some can look at the destination of the request and&#xD;
        determine if the user has been authenticated, and know if the current token needs to be exchanged for a second&#xD;
        token and can redirect this request to the appropriate parties.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Indirect Trust&lt;/b>: Sometimes parties do not have a direct trust relationship, but they do share a third party&#xD;
        that they both trust to &quot;broker&quot; an exchange.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Delegation&lt;/b>: Combinations of direct and indirect trust relationships can be established&#xD;
    &lt;/li>&#xD;
&lt;/ul></sectionDescription>
  </sections>
  <sections xmi:id="_6yz_sDIyEduePY7oPsXsLA" name="Identify High-Level Security Patterns" guid="_6yz_sDIyEduePY7oPsXsLA">
    <sectionDescription>&lt;p>&#xD;
    The high-level security patterns identified in this task are as follows. Elements of the&amp;nbsp;System Architecture&#xD;
    affected by security requirements (security affects both software and hardware elements) may now be associated with one&#xD;
    or more of these patterns (preferrably documented in the &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html&quot;&#xD;
    guid=&quot;{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}&quot;>Artifact: Software Architecture Document&lt;/a>) such that they may be&#xD;
    refined during design time activities.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Identity &amp;amp; Authentication&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    An end user has possession of an identifier (username) and/or a set of identifiers (titles, roles, alias) and proofs&#xD;
    (password), which it keeps somewhere perhaps on a client system like a laptop or PDA. To authenticate, the user&#xD;
    presents the identifier and proof to an application when prompted to identify itself to the application. If the&#xD;
    application validates the identifier and proof, the user has successfully &quot;authenticated&quot; and the identity is now an&#xD;
    &quot;authenticated identity&quot;. When an application implements business logic and enforces its own security policies it needs&#xD;
    to keep its data/metadata in an identity data/metadata repository (file system, database, etc). With the advent of the&#xD;
    web, the end user no longer solely has application client code on its own system but often accesses applications&#xD;
    through a browser, and the network locates the application through a URI (universal resource identifier) supplied by&#xD;
    the end user.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Single Sign-On&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    When a user has multiple applications&amp;nbsp;with different identifiers&amp;nbsp;and proofs, it sometimes becomes difficult&#xD;
    to manage the identity data and metadata to make the appropriate decisions. Single Sign-On (SSO) is a term applied to&#xD;
    various techniques (human and automated) to reduce this complexity.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Solutions for SSO can be client based or server/service based and they can be tightly coupled or loosely coupled to the&#xD;
    applications. Web based SSO refers to browser based solutions and typically include cookies. In tightly-coupled&#xD;
    client-based SSO, the responsibility is on the user to register and synchronize multiple id/passwords which are&#xD;
    maintained in multiple application repositories. Some SSO relies on &quot;identity mapping&quot; others provide &quot;identity&#xD;
    propagation&quot; or &quot;identity assertions&quot;. New initiatives in Federated SSO allow a user to register with a third party&#xD;
    Identity Service Provider who then manages the user information thus providing a loosely-coupled alternative. In&#xD;
    enterprises, a backend SSO can include the enterprise acting as the ISP. Backend SSO includes a common repository for&#xD;
    all applications, and each application/server is reconfigured to not use a local repository. Backend SSO can also&#xD;
    maintain multiple repositories for user information and utilize a management process to force the synchronization of&#xD;
    the identity data in multiple repositories. When multiple identities are involved there are often requirements to&#xD;
    isolate applications into realms, which often correlate to administrative domains.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Digital Identities&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    As people and businesses have become more dependent on computer technology, there has been a proliferation of identity&#xD;
    related information created. With the awareness of identity theft, governments are legislating requirements for&#xD;
    businesses on the protection of the identity information for which they are a custodian.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Digital Identity Solutions - There are two major strategies for managing Digital Identities. One is &quot;user centric&quot;, and&#xD;
    relies on a user actively participating in identity protection, by &quot;registering&quot; with third party providers and then&#xD;
    granting permission to access their identity data &amp;amp; metadata to providers that they trust. The Liberty Alliance is&#xD;
    a consortium that has been leading this strategy, but there is also an open source effort underway with the Higgins&#xD;
    initiative in partnership within The&amp;nbsp;Apache Foundation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The second is a business centered model in which a business provides identity management services to its customers,&#xD;
    partners and employees. The underlying technology is the same for each approach, but the governance and responsibility&#xD;
    for providing digital identity management is different. Businesses deal with different volumes of information than&#xD;
    individuals and therefore have different scaling requirements. Businesses also need to have their own systems for&#xD;
    managing user access based on business roles and changing business conditions (i.e., you are always &quot;My Self&quot;, but you&#xD;
    may not always work for company xyz.)&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Authorization&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    As people and businesses have become more dependent on computer technology, rules about who can access what resource&#xD;
    have become codified. When designing applications, the decision of who can access what information, might depend on&#xD;
    business context information or it may be externalized to the application and handled by a separate set of middleware.&#xD;
    Most products and computer systems have implemented a set of &quot;access control&quot; mechanisms, but each one usually keeps&#xD;
    its own mapping of authorized usernames to resource name and these are called &quot;access control lists&quot;.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Message Protection&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    There are two basic types of protection; integrity protection (proof that the message has not been changed while in&#xD;
    transit) and confidentiality ( application of cryptography to ensure that only authorized recipients can see the&#xD;
    message). When messages are sent over a protocol each message can be digitally signed or encrypted or the network&#xD;
    protocol can sign/encrypt all traffic between the two entry points. When the protocol provides the protection, it is&#xD;
    often said to be &quot;point to point&quot; (i.e. network endpoint to network endpoint).&#xD;
&lt;/p></sectionDescription>
  </sections>
  <keyConsiderations>The security patterns identified during this task are high-level and have no dependency on particular technologies or&#xD;
platforms; each such pattern will in turn be supported by any number of technology and platform specific patterns. The&#xD;
definition of these detailed patterns must be available to the implementor for the technology and platform chosen by a&#xD;
project.</keyConsiderations>
  <purpose>&lt;p>&#xD;
    To provide key mechanisms for the development of secure solutions by selecting from pre-defined patterns.&#xD;
&lt;/p></purpose>
</org.eclipse.epf.uma:TaskDescription>
